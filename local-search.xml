<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从零开始的量化交易</title>
    <link href="/2021/04/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    <url>/2021/04/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/</url>
    
    <content type="html"><![CDATA[<p>看了下文件创建时间，<code>2019-08-21</code>，真是早啊哈哈哈哈哈哈。</p><p>前阵子又拾起这块东西，想在 OKEX 上进行下实验，权当培养兴趣爱好2333。</p><a id="more"></a><h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><h3 id="手工交易经验"><a href="#手工交易经验" class="headerlink" title="手工交易经验"></a>手工交易经验</h3><p>在开始量化之前，我在 OKEX 上玩了大概一年半。本金约 720USDT，操作到 1794.37USDT。</p><p>有几个体会（经验）：</p><ul><li>随资金增长，再增长的效率快很多。（也可能是因为不会轻易折损本金所以心态不一样）</li><li>只要肯花时间等，即使跌很多也总能涨回到原来的位置（暴跌后躺着装死，等几周就能回来，但估计这是错觉）</li></ul><h3 id="量化交易经验"><a href="#量化交易经验" class="headerlink" title="量化交易经验"></a>量化交易经验</h3><p>目前策略 α 收益并不多（10USDT+/Day），主要是 β 收益：</p><table><thead><tr><th align="center">日期</th><th align="center">量化天数</th><th align="center">总资产 (USDT)</th></tr></thead><tbody><tr><td align="center">2021.04.22 02:39</td><td align="center">0</td><td align="center">1794.37</td></tr><tr><td align="center">2021.04.22 11:19</td><td align="center">1</td><td align="center">1749.39</td></tr><tr><td align="center">2021.04.23 10:53</td><td align="center">2</td><td align="center">1402.96</td></tr><tr><td align="center">2021.04.24 15:00</td><td align="center">3</td><td align="center">1775.87</td></tr><tr><td align="center">2021.04.26 19:31</td><td align="center">5</td><td align="center">1854.68</td></tr><tr><td align="center">2021.04.28 02:32</td><td align="center">6</td><td align="center">1907.34</td></tr><tr><td align="center">2021.04.28 08:52</td><td align="center">7</td><td align="center">1923.11</td></tr><tr><td align="center">2021.04.29 09:38</td><td align="center">8</td><td align="center">1984.20</td></tr><tr><td align="center">2021.04.29 21:28</td><td align="center">8.5</td><td align="center">2048.80</td></tr><tr><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>体会（经验）：</p><ul><li>永远要控制仓位，以防大跌情况（04.23 这天遇到<a href="https://finance.sina.com.cn/blockchain/roll/2021-04-23/doc-ikmxzfmk8463700.shtml" target="_blank" rel="noopener">拜登提高资本利得税</a>的黑天鹅事件，直接跌去30%）</li></ul><p>##0x01 配置环境</p><p>我用的是开源的 <code>vn.py</code> <a href="https://github.com/vnpy/vnpy" target="_blank" rel="noopener">框架</a>，由于很多接口只支持Win和Linux，Mac只能用 <code>REST/WebSocket</code>（OKEX用的是 <code>REST</code>） ，所以官方没有提供Mac的安装流程。根据社区的这个帖子完成了安装：<a href="https://www.vnpy.com/forum/topic/395-mac-xia-an-zhuang-yun-xing-vnpy-2-0" target="_blank" rel="noopener">Mac下安装运行vnpy2.0</a></p><p>在项目目录下配置 <code>config.yaml</code> 和 <code>run_ui.py</code> 两个文件，目录结构如下：</p><pre><code class="hljs plain">vnpy&#x2F;├── config.yaml├── run_ui.py├── vnpy&#x2F;</code></pre><pre><code class="hljs bash">» cat config.yaml<span class="hljs-string">"API Key"</span>: <span class="hljs-string">"******"</span> <span class="hljs-comment"># 在OKEX上申请V3 API，V3不支持统一账户交易，vnpy在下个版本会对V5进行支持</span><span class="hljs-string">"Secret Key"</span>: <span class="hljs-string">"******"</span><span class="hljs-string">"Passphrase"</span>: <span class="hljs-string">"******"</span><span class="hljs-string">"会话数"</span>: 3<span class="hljs-string">"代理地址"</span>: <span class="hljs-string">""</span> <span class="hljs-comment"># 由于数字货币服务器均在国外，需要挂上代理</span><span class="hljs-string">"代理端口"</span>: <span class="hljs-string">""</span></code></pre><pre><code class="hljs bash">» cat run_ui.pyfrom vnpy.event import EventEnginefrom vnpy.trader.engine import MainEnginefrom vnpy.trader.ui import MainWindow, create_qappfrom vnpy.gateway.okex import OkexGatewayfrom vnpy.app.algo_trading import AlgoTradingAppimport yamldef get_okex_setting(config_path):    with open(config_path) as f:        <span class="hljs-built_in">return</span> yaml.load(f, Loader=yaml.SafeLoader)def main():    okex_setting = get_okex_setting(<span class="hljs-string">"config.yaml"</span>)    qapp = create_qapp()    event_engine = EventEngine()    main_engine = MainEngine(event_engine)    main_engine.add_gateway(OkexGateway)    main_engine.add_app(AlgoTradingApp)    main_engine.add_app(DataManagerApp)    main_engine.connect(okex_setting, <span class="hljs-string">"OKEX"</span>)    main_window = MainWindow(main_engine, event_engine)    main_window.restore_window_setting()    qapp.exec()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><p>执行 <code>python run_ui.py</code> 即可弹出 GUI 窗口进行操作。</p><h2 id="0x02-Naive-网格策略-2021-04-22"><a href="#0x02-Naive-网格策略-2021-04-22" class="headerlink" title="0x02 Naive 网格策略 @2021.04.22"></a>0x02 Naive 网格策略 @2021.04.22</h2><blockquote><p>我本身并不认可数字货币的价值，只是将加密货币市场视作赌场，以这种心态来看，币值只是随机波动的曲线。而使用网格策略，恰好能收割这些价格波动，以达到获利的目的。</p></blockquote><p>因为对金融指标完全不了解，所以找到了网格交易策略。这是一种对新手相当友好的策略，只需要设定好几个参数就可以！<a href="https://www.vnpy.com/docs/cn/algo_trader.html#id14" target="_blank" rel="noopener">vnpy文档</a>对网格算法描述如下：</p><ol><li>基于<code>网格大小</code>（价格步进）计算 <code>目标格数</code>，<code>目标格数 = (上界价格 - 当前价格) / 网格大小</code></li><li>计算 <code>目标仓位</code>，<code>目标仓位 = 取整后的目标格数 * 每格委托数量</code>。注意卖卖方向取整的方式是不同的：买入方向向下取整（floor）；卖出方向要向上取整（ceil）</li><li>根据 <code>目标仓位</code> 执行操作。若目标仓位大于当前仓位，执行买入操作；若目标仓位低于当前仓位，执行卖出操作</li></ol><p>选好币，凭感觉设定好<strong>价格上界</strong>，根据15min价格浮动设定好<strong>网格大小</strong>（计划15min一次操作，单次利率虽少但次数多），根据目测的价格下界设定好<strong>每格委托数量</strong>，就开始执行策略！</p><p>然而开始量化的第三天，遇到大跌行情，资产一度折损到 1300USDT，跌去 30%。这让我意识到网格策略的局限性：无法应对单边跌和单边涨的情况，故考虑对其进行改进。</p><h2 id="0x03-改进的网格策略-2021-04-24"><a href="#0x03-改进的网格策略-2021-04-24" class="headerlink" title="0x03 改进的网格策略 @2021.04.24"></a>0x03 改进的网格策略 @2021.04.24</h2><p>主要考虑的是单边跌，毕竟踏空不要紧，但不能跌去本金。</p><h3 id="单边跌"><a href="#单边跌" class="headerlink" title="单边跌"></a>单边跌</h3><p>考虑跌倒一定程度，对网格策略的网格大小进行扩展。</p><ol><li>用网格<code>上界价格</code>（price）初始化<code>浮动上界</code>（ceil），根据 <code>扩展阈值百分比</code> 计算出 <code>扩展阈值</code>， <code>扩展阈值 = 浮动上界 * (1 - 扩展阈值百分比)</code></li><li>根据当前价格大小关系做扩展/收缩操作：<ol><li>如果当前价格低于 <code>扩展阈值</code> ，进行扩展操作：<code>网格大小 *= 扩展因子</code>，<code>每格委托数量 *= 扩展委托数增长因子</code>，<code>浮动上界 -= 上界价格 * 扩展阈值百分比</code>， <code>扩展阈值 -= 上界价格 * 扩展阈值百分比</code></li><li>如果当前价格高于 <code>浮动上界</code> ，进行收缩操作：<code>网格大小 /= 扩展因子</code>， <code>每格委托数量 /= 扩展委托数增长因子</code>，<code>浮动上界 += 上界价格 * 扩展阈值百分比</code>， <code>扩展阈值 += 上界价格 * 扩展阈值百分比</code></li></ol></li><li>扩展/收缩操作后，再执行Naive网格策略</li></ol><p>进行扩展操作后，通常 <code>目标仓位</code> 会下降，以低价卖出一部分仓位来回收资金；而进行收缩操作后，<code>目标仓位</code>会增加，在稍高点重新建立仓位，期望后续增长。</p><p>但这样一来，短时间内扩展、收缩来回操作会损耗大量资金。为了避免反复横跳，设置一个 <code>冷静时间</code>，即在扩展（收缩）操作后需要等一段时间后才允许进行收缩（扩展）操作。</p><h3 id="单边涨"><a href="#单边涨" class="headerlink" title="单边涨"></a>单边涨</h3><p>为了应对单边涨行情，上调各种阈值。</p><ol><li>当前价格高于 <code>上界价格</code> （price）时，考虑上调阈值：<code>上界价格 = 当前价格 * (1 + 扩展阈值百分比 / 2)</code>， <code>扩展阈值 = 上界价格 * (1 - 扩展阈值百分比)</code>， <code>浮动上界 = 上界价格</code></li></ol><p>为了防止短时间疯涨回落，在上调前也等待一个 <code>等待时间</code>。</p><h2 id="0x04-后续计划"><a href="#0x04-后续计划" class="headerlink" title="0x04 后续计划"></a>0x04 后续计划</h2><p>计划参考 <a href="https://tianzhuqin.github.io/assets/work/Tianzhu_Qin_AI_Stock-Market-Trading.html" target="_blank" rel="noopener">Stock Market Trading Strategy Research – Hire an AI to make you money!</a> 用机器学习方法进行尝试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>兴趣爱好</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11解放Python GIL</title>
    <link href="/2020/04/18/pybind11%E8%A7%A3%E6%94%BEPython-GIL/"/>
    <url>/2020/04/18/pybind11%E8%A7%A3%E6%94%BEPython-GIL/</url>
    
    <content type="html"><![CDATA[<p>由于GIL(Global Interpreter Lock)，在Python中使用多线程容易遇到 “一核有难多核围观” 的情况，在计算密集场景下Python的多线程基本处于不可用的状态。本文将给出一种解放GIL的方法。</p><a id="more"></a><h2 id="Python的GIL"><a href="#Python的GIL" class="headerlink" title="Python的GIL"></a>Python的GIL</h2><p>由于历史原因（Python发布于1989年，当时的程序都是运行在单核计算机上），Python解释器自带全局锁（Global Interpreter Lock，GIL），当使用多线程时，不同线程共用这个锁，使得在同一时刻仅有一个线程在执行指令。</p><p>GIL使得Python的多线程处于鸡肋状态。</p><h2 id="规避GIL的几种方法"><a href="#规避GIL的几种方法" class="headerlink" title="规避GIL的几种方法"></a>规避GIL的几种方法</h2><ul><li>使用多进程替代多线程</li><li>异步编程（针对IO密集场景）</li><li>将关键组件用其他语言编写拓展（如使用pybind11用C++拓展）</li></ul><p>下面介绍最后一种方法。</p><h2 id="pybind11"><a href="#pybind11" class="headerlink" title="pybind11"></a>pybind11</h2><p><a href="https://github.com/pybind/pybind11" target="_blank" rel="noopener">Pybind11</a>提供了一种将C++（C++11以上）代码供Python调用的简单方法，其在深度学习领域（TensorFlow，paddlepaddle）广泛应用。</p><p>参考<a href="https://pybind11.readthedocs.io/en/master/basics.html" target="_blank" rel="noopener">官方文档</a>进行安装。</p><h3 id="编译链接库时可能会遇到的问题"><a href="#编译链接库时可能会遇到的问题" class="headerlink" title="编译链接库时可能会遇到的问题"></a>编译链接库时可能会遇到的问题</h3><pre><code class="hljs shell">ld: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation)</code></pre><p>参考该<a href="https://github.com/pybind/pybind11/issues/382" target="_blank" rel="noopener">issue</a>，Python lib不在搜索路径中，编译命令上加上<code>-undefined,dynamic_lookup</code>参数即可。</p><h3 id="使用pybind11编译一个module"><a href="#使用pybind11编译一个module" class="headerlink" title="使用pybind11编译一个module"></a>使用pybind11编译一个module</h3><p>下面用C++编写了一个简单的module，用pybind11编译后将得到一个链接库文件（记得关掉<code>O3</code>优化选项）。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><span class="hljs-keyword">namespace</span> py = pybind11;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; num; ++j) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; num; ++k) &#123;        <span class="hljs-keyword">double</span> x = <span class="hljs-number">1.0</span> * i * j * k;      &#125;    &#125;  &#125;&#125;PYBIND11_MODULE(test_pybind, m) &#123;  m.def(<span class="hljs-string">"loop"</span>, &amp;loop);&#125;</code></pre><p>Python端可以直接<code>import</code>该module，具体调用如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> test_pybindtest_pybind.loop(<span class="hljs-number">1000</span>)</code></pre><h2 id="pybind11解放GIL"><a href="#pybind11解放GIL" class="headerlink" title="pybind11解放GIL"></a>pybind11解放GIL</h2><p>接下来将会用下面的Python代码来测试多线程性能：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> test_pybind<span class="hljs-keyword">if</span> len(sys.argv) != <span class="hljs-number">2</span>:    print(<span class="hljs-string">'usage: python multi-thread.py thread_num'</span>)    exit(<span class="hljs-number">-1</span>)thread_num = int(sys.argv[<span class="hljs-number">1</span>])threads = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(thread_num):    th = threading.Thread(target=test_pybind.loop, args=(<span class="hljs-number">1000</span>, ))    th.start()    threads.append(th)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(thread_num):    threads[i].join()</code></pre><h3 id="Code-with-GIL"><a href="#Code-with-GIL" class="headerlink" title="Code with GIL"></a>Code with GIL</h3><p>简单测试下我们刚刚定义的<code>loop</code>函数在单线程和四线程下的表现：</p><pre><code class="hljs shell">» time python multi-thread.py 1python multi-thread.py 1  3.16s user 0.05s system 99% cpu 3.214 total» time python multi-thread.py 4python multi-thread.py 4  12.57s user 0.09s system 99% cpu 12.699 total</code></pre><p>四线程下的程序耗时差不多是单线程的四倍，同时程序cpu利用率一直保持在<code>100%</code>左右，这就是GIL在起作用辣。</p><p>程序进入C++函数始终会保持持有GIL锁，让其他线程处于wait状态。</p><h3 id="Release-GIL"><a href="#Release-GIL" class="headerlink" title="Release GIL"></a>Release GIL</h3><p><a href="https://pybind11.readthedocs.io/en/stable/advanced/misc.html" target="_blank" rel="noopener">pybind11</a>中提供了<code>py::gil_scoped_release</code>和<code>py::gil_scoped_acquire</code>类用于获取和释放C++函数调用主体中的GIL锁，这样就可以使用多个Python线程并行运行C++代码。</p><p>一般情况，也可以使用简化的<code>call_guard</code>策略<code>py::call_guard&lt;py::gil_scoped_release&gt;()</code>。</p><p>于是我们可以更改module中<code>loop</code>相关的代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><span class="hljs-keyword">namespace</span> py = pybind11;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; num; ++j) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; num; ++k) &#123;        <span class="hljs-keyword">double</span> x = <span class="hljs-number">1.0</span> * i * j * k;      &#125;    &#125;  &#125;&#125;PYBIND11_MODULE(test_pybind, m) &#123;  m.def(<span class="hljs-string">"loop"</span>, &amp;loop)   .def(<span class="hljs-string">"loop_without_gil"</span>, &amp;loop,        py::call_guard&lt;py::gil_scoped_release&gt;());&#125;</code></pre><p>Python端改调用<code>loop_without_gil</code>函数。测试下<code>loop_without_gil</code>函数在单线程和四线程下的表现：</p><pre><code class="hljs shell">» time python multi-thread.py 1python multi-thread.py 1  3.19s user 0.04s system 99% cpu 3.245 total» time python multi-thread.py 4python multi-thread.py 4  12.53s user 0.07s system 390% cpu 3.225 total</code></pre><p>单线程和四线程的耗时差不多，同时四线程的cpu使用率保持在<code>400%</code>左右。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[WIP] C++11: 右值引用与转移语义</title>
    <link href="/2020/04/15/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E8%BD%AC%E7%A7%BB%E8%AF%AD%E4%B9%89/"/>
    <url>/2020/04/15/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E8%BD%AC%E7%A7%BB%E8%AF%AD%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>之前在Paddle的<a href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/fluid/operators/reader/blocking_queue.h" target="_blank" rel="noopener">blocking_queue</a>里看到了<code>std::move</code>的用法，与之相关的是C++11（2011年）引入的新特性右值引用（Rvalve Reference），这里简单学习了一下。</p><a id="more"></a><p>右值引用主要目的有下面两个方面：</p><ol><li>消除两个对象交互时不必要的对象拷贝</li><li>能够更简洁明确地定义泛型函数。</li></ol><h1 id="左值与右值的定义"><a href="#左值与右值的定义" class="headerlink" title="左值与右值的定义"></a>左值与右值的定义</h1><p>C/C++中，所有的表达式和变量要么是左值，要么是右值。</p><p>通俗地理解，左值的定义是非临时对象，可以在多条语句中使用，所有的变量都是左值。而右值是指临时的对象，只在当前的语句中有效。例如下面这个简单的赋值语句：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</code></pre><p>在这条语句中，<code>i</code> 是左值，<code>0</code>是右值（临时值）。<code>i</code>可以被引用，而<code>0</code>不可以。立即数都是右值。</p><p>右值也可以出现在赋值表达式的左边，但是不能作为赋值的对象，因为右值只在当前语句有效，赋值没有意义。例如下面这个例子：</p><pre><code class="hljs c++">((i &gt; <span class="hljs-number">0</span>) ? i : j) = <span class="hljs-number">1</span>;</code></pre><p>在这个例子中，<code>0</code>作为右值出现在了<code>=</code>的左边。但是赋值对象是<code>i</code> 或<code>j</code>，都是左值。</p><p>在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用绑定一个右值，如 :</p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a = <span class="hljs-number">1</span>;</code></pre><p>在这种情况下，右值不能被修改的。但是实际上右值是可以被修改的，如 :</p><pre><code class="hljs c++">T().<span class="hljs-built_in">set</span>().<span class="hljs-built_in">get</span>();</code></pre><p>既然右值可以被修改，那么就可以实现右值引用。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC初探: 基于brpc写一个简单的Add服务</title>
    <link href="/2020/04/12/RPC%E5%88%9D%E6%8E%A2:%20%E5%9F%BA%E4%BA%8Ebrpc%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Add%E6%9C%8D%E5%8A%A1/"/>
    <url>/2020/04/12/RPC%E5%88%9D%E6%8E%A2:%20%E5%9F%BA%E4%BA%8Ebrpc%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Add%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>本篇将介绍RPC原理，以及如何基于bprc编写一个简单的Add服务。</p><a id="more"></a><h2 id="PRC原理"><a href="#PRC原理" class="headerlink" title="PRC原理"></a>PRC原理</h2><p>RPC（Remote procedure call）的原理可以简述为下图，Client调用Server上的进程时，Client的调用进程将被挂起，而Server上的被调用进程开始执行，调用方将参数传到被调用过程，得到回传结果。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr0yn0uclj30y00dgjt2.jpg" srcset="/img/loading.gif" alt="image-20200412144302504" style="zoom:30%;" /><p>RPC通常借助stub来实现，stub是一组RPC机制的操作原语，这些原语构成了RPC的实现细节。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr0ypc997j31640t4k2k.jpg" srcset="/img/loading.gif" alt="image-20200412144503030" style="zoom:40%;" /><ol><li>Client调用本地stub中的一个过程，开始远程过程调用请求</li><li>这个stub过程把有关的参数组装成一个信息包或一组信息包，形成一条消息。运行此执行过程的远程场点的<code>IP地址</code>和执行该过程的<code>进程ID号</code>也包含在这条消息中。</li><li>stub把这条消息发送给对应的RPC runtime（RPC运行库）子程序，由这个子程序将详细发送到远程场点。</li><li>Server端的RPC runtime子程序在接收到这条消息时，引用与被调用者对应的stub中的一个子程序，并让它来处理消息。</li><li>与被调用者对应的stub中的这个子程序卸载信息，解析出相关参数，并用本地调用方式执行所指定的过程。</li><li>返回调用结果，调用者对应的stub子程序执行return语句返回到Client，整个RPC过程结束。</li></ol><h2 id="brpc"><a href="#brpc" class="headerlink" title="brpc"></a>brpc</h2><p>brpc是百度开源的工业级RPC框架，支持多种传输协议，目前只开源了C++版本。</p><p>在bprc中，参数传递使用protobuf协议，避免了指针类参数等问题。</p><h2 id="如何使用brpc"><a href="#如何使用brpc" class="headerlink" title="如何使用brpc"></a>如何使用brpc</h2><p>下面将以Add Service为例，来展示如何使用brpc。</p><p>Client的调用进程调用Server中的Add过程后被挂起，直到收到调用结构，参数为一组整数。Server计算这组整数的和，并回传调用结果。</p><h3 id="编译brpc"><a href="#编译brpc" class="headerlink" title="编译brpc"></a>编译brpc</h3><p>根据<a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/getting_started.md#macos" target="_blank" rel="noopener">快速文档</a>编译brpc，以macOS用户为例：</p><pre><code class="hljs shell">brew install openssl git gnu-getopt coreutilsbrew install gflags protobuf leveldbgit clone https://github.com/apache/incubator-brpccd incubator-brpcsh config_brpc.sh --headers=/usr/local/include --libs=/usr/local/lib --cc=clang --cxx=clang++make -j10</code></pre><h3 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service</h3><p>brpc中将远程过程称为Service，采用protobuf协议。</p><p>这里Request参数为Client调用远程过程的参数（一组整数），Response参数为Server过程的调用结果（一组整数的和），AddService即是所定义的远程过程。</p><p>通过<code>protoc --cpp_out=. --proto_path=.  add.proto</code>命令即可生成对应的头文件<code>add.pb.h</code>，包含AddRequest、AddResponse，以及AddService_Stub等相关的定义。</p><pre><code class="hljs protobuf">syntax=<span class="hljs-string">"proto2"</span>;<span class="hljs-keyword">option</span> cc_generic_services = <span class="hljs-literal">true</span>;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">AddRequest</span> </span>&#123;    <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">int32</span> adds = <span class="hljs-number">1</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">AddResponse</span> </span>&#123;    <span class="hljs-keyword">required</span> <span class="hljs-built_in">int32</span> result = <span class="hljs-number">1</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">AddService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Add(AddRequest) <span class="hljs-keyword">returns</span> (AddResponse)</span>;&#125;;</code></pre><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;brpc/channel.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"add.pb.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;    brpc::Channel channel;    <span class="hljs-comment">// Initialize the channel</span>    brpc::ChannelOptions options;    options.protocol = <span class="hljs-string">"baidu_std"</span>;    options.connection_type = <span class="hljs-string">""</span>;    options.timeout_ms = <span class="hljs-number">100</span>;    options.max_retry = <span class="hljs-number">3</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> endpoints = <span class="hljs-string">"0.0.0.0:8000"</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> load_balancer = <span class="hljs-string">""</span>; <span class="hljs-comment">// single server</span>    <span class="hljs-keyword">if</span> (channel.Init(endpoints.c_str(), load_balancer.c_str(), &amp;options) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Fail to initialize channel"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">// Create stub</span>    <span class="hljs-function">AddService_Stub <span class="hljs-title">stub</span><span class="hljs-params">(&amp;channel)</span></span>;    AddRequest request;    AddResponse response;    brpc::Controller cntl;    cntl.request_attachment().append(<span class="hljs-string">""</span>);    <span class="hljs-comment">// Pack params</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;        request.add_adds(i);    &#125;    <span class="hljs-comment">// Start Add service</span>    stub.Add(&amp;cntl, &amp;request, &amp;response, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span> (!cntl.Failed()) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"get: "</span> &lt;&lt; response.result() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"get: failed"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在bprc中没有Client对应的实体，取而代之的是<code>brpc::Channel</code>，代表和一台或一组服务器的交互通道。在实践中中Client和Channel的角色基本没有差别，可以将Channel视作Client。Channel的创建和初始化并不是线程安全的，初始化结束后可以被多线程共用。</p><p>Client端将相关参数打包好后，通过调用本地stub中的Add过程，来执行Server端的AddService。</p><p><code>tub.Add(&amp;cntl, &amp;request, &amp;response, NULL)</code>的最后一个参数表示本次调用为同步调用。</p><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;brpc/server.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"add.pb.h"</span></span><span class="hljs-comment">// implementation of AddService</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddServiceImpl</span> :</span> <span class="hljs-keyword">public</span> AddService &#123;<span class="hljs-keyword">public</span>:    AddServiceImpl() &#123;&#125;;    <span class="hljs-keyword">virtual</span> ~AddServiceImpl() &#123;&#125;;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(google::protobuf::RpcController* cntl_base,</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> AddRequest* request,</span></span><span class="hljs-function"><span class="hljs-params">                     AddResponse* response,</span></span><span class="hljs-function"><span class="hljs-params">                     google::protobuf::Closure* done)</span> </span>&#123;        <span class="hljs-function">brpc::ClosureGuard <span class="hljs-title">done_guard</span><span class="hljs-params">(done)</span></span>;        brpc::Controller* cntl = <span class="hljs-keyword">static_cast</span>&lt;brpc::Controller*&gt;(cntl_base);        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"request form ["</span> &lt;&lt; cntl-&gt;remote_side()                  &lt;&lt; <span class="hljs-string">"] to ["</span> &lt;&lt; cntl-&gt;local_side() &lt;&lt; <span class="hljs-string">"]: "</span>;        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-comment">// Parse request and calculate call result</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; request-&gt;adds_size(); ++i) &#123;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; request-&gt;adds(i) &lt;&lt; <span class="hljs-string">", "</span>;            result += request-&gt;adds(i);        &#125;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-comment">// Pack result</span>        response-&gt;set_result(result);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;    brpc::<span class="hljs-built_in">Server</span> server;    AddServiceImpl add_service_impl;    <span class="hljs-comment">// Add the service into server.</span>    <span class="hljs-keyword">if</span> (server.AddService(&amp;add_service_impl,                          brpc::SERVER_DOESNT_OWN_SERVICE) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Fail to add service"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">// Start the server.</span>    brpc::ServerOptions options;    options.idle_timeout_sec = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span> (server.Start(<span class="hljs-number">8000</span>, &amp;options) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Fail to start EchoServer"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    server.RunUntilAskedToQuit();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Server端添加Add Service后启动Server，等待被调用。当接收到Client端stub发来的消息时，解析request参数，执行相关过程，最后将结果打包回传。</p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>Server端：</p><pre><code class="hljs shell">» ./serverI0412 15:31:48   775 src/brpc/server.cpp:1045] Server[AddServiceImpl] is serving on port=8000.I0412 15:31:48   775 src/brpc/server.cpp:1048] Check out http://barrierys-MBP.local:8000 in web browser.request form [127.0.0.1:51830] to [127.0.0.1:8000]: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,</code></pre><p>Client端：</p><pre><code class="hljs shell">» ./clientget: 4950</code></pre>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Docker的Slurm环境搭建</title>
    <link href="/2020/02/25/%E5%9F%BA%E4%BA%8EDocker%E7%9A%84Slurm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/02/25/%E5%9F%BA%E4%BA%8EDocker%E7%9A%84Slurm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>要学习Slurm的GPU调度，首先要搭建Slurm环境。奈何实验室机器没有sudo权限，安装软件成了很大的问题，遂在自己电脑上用docker进行Slurm的环境搭建（顺便学习一下docker操作）。</p><a id="more"></a><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><ol><li><p>拉取centos镜像</p><pre><code class="hljs bash">docker pull centos:7</code></pre></li><li><p>以特权模式创建容器，准备安装必要的环境（直接创建的容器不能运行后台服务：<code>Failed to get D-Bus connection: Operation not permitted</code>）:</p><pre><code class="hljs bash">docker run --privileged -it --name=centos-with-ssh centos:7 /sbin/init</code></pre><p>一直卡在当前界面，重新开启一个新的终端，进入容器内部打开sshd服务：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it centos-with-ssh /bin/bash</code></pre></li></ol><ol start="3"><li><p>在刚创建好的容器里安装SSHD环境</p><pre><code class="hljs bash">yum install -y wget vim passwd net-toolsyum install -y openssh-server openssh-clients<span class="hljs-comment"># 修改容器密码</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"slurm"</span> |passwd --stdin root<span class="hljs-comment"># 生成ssh秘钥</span>ssh-keygen -t rsacp ~/.ssh/id_rsa.pub ~/.ssh/authorized_keysssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyssh-keygen -t rsa -f /etc/ssh/ssh_host_ecdsa_keyssh-keygen -t rsa -f /etc/ssh/ssh_host_ed25519_key</code></pre><p>开启sshd服务</p><pre><code class="hljs bash">systemctl restart sshd.servicenetstat  -nplt | grep 22 <span class="hljs-comment"># 查看ssh的22端口状态</span>&gt; tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      127/sshd&gt; tcp6       0      0 :::22                   :::*                    LISTEN      127/sshd</code></pre><p>免密码登录配置</p><pre><code class="hljs bash"><span class="hljs-comment"># 与ssh-copy-id相同，将宿主机的公钥复制到容器的authorized_keys中</span>docker cp ~/.ssh/id_rsa.pub centos-with-ssh:/root <span class="hljs-comment"># 宿主机</span>cat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys <span class="hljs-comment"># 容器</span></code></pre></li></ol><ol start="4"><li><p>安装slurm环境</p><p>创建slurm用户</p><pre><code class="hljs bash">useradd slurm</code></pre><p>安装munge</p><pre><code class="hljs bash">yum -y install epel-release gtk2 gtk-develyum -y install munge munge-devel</code></pre><p>创建munge需要的目录（一般会自动生成）</p><pre><code class="hljs bash">mkdir -p /etc/mungemkdir -p /var/run/mungemkdir -p /var/lib/mungemkdir -p /var/<span class="hljs-built_in">log</span>/munge</code></pre><p>修改这些目录的属主为slurm</p><pre><code class="hljs bash">chown slurm:slurm /etc/mungechown slurm:slurm /var/run/mungechown slurm:slurm /var/lib/mungechown slurm:slurm /var/<span class="hljs-built_in">log</span>/munge</code></pre><p>生成munge的秘钥，存储在<code>/etc/munge</code>中（所有节点的<code>munge.key</code>都要相同）</p><pre><code class="hljs bash">create-munge-keychown slurm:slurm /etc/munge/munge.key <span class="hljs-comment"># 同样要修改属主</span></code></pre><p>安装slurm</p><pre><code class="hljs bash"><span class="hljs-comment"># 或者从宿主机传上去：docker cp slurm-19.05.5.tar.bz2 centos-with-ssh:/root</span>wget https://download.schedmd.com/slurm/slurm-19.05.5.tar.bz2<span class="hljs-comment"># 若解压失败则是由于缺少bzip的包：yum install -y bzip2</span>tar -jxvf slurm-19.05.5.tar.bz2 &amp;&amp; <span class="hljs-built_in">cd</span> slurm-19.05.5<span class="hljs-comment"># 可能需要安装gcc：yum install -y gcc</span>./configure <span class="hljs-comment"># 可能会出错：Try re-running configure with the '--disable-dependency-tracking' option</span><span class="hljs-comment"># 可能需要安装make：yum install -y automake autoconf libtool make </span>make &amp;&amp; make checkmake install</code></pre><p>修改slurm配置文件</p><pre><code class="hljs bash">cp ~/slurm-19.05.5/etc/slurm.conf.example /usr/<span class="hljs-built_in">local</span>/etc/slurm.confvim /usr/<span class="hljs-built_in">local</span>/etc/slurm.conf</code></pre><pre><code class="hljs bash"><span class="hljs-comment">#</span><span class="hljs-comment"># Example slurm.conf file. Please run configurator.html</span><span class="hljs-comment"># (in doc/html) to build a configuration file customized</span><span class="hljs-comment"># for your environment.</span><span class="hljs-comment">#</span><span class="hljs-comment">#</span><span class="hljs-comment"># slurm.conf file generated by configurator.html.</span><span class="hljs-comment">#</span><span class="hljs-comment"># See the slurm.conf man page for more information.</span><span class="hljs-comment">#</span>ClusterName=linuxControlMachine=linux0<span class="hljs-comment">#ControlAddr=</span><span class="hljs-comment">#BackupController=</span><span class="hljs-comment">#BackupAddr=</span><span class="hljs-comment">#</span>SlurmUser=slurm<span class="hljs-comment">#SlurmdUser=root</span>SlurmctldPort=6817SlurmdPort=6818AuthType=auth/munge<span class="hljs-comment">#JobCredentialPrivateKey=</span><span class="hljs-comment">#JobCredentialPublicCertificate=</span>StateSaveLocation=/tmp <span class="hljs-comment">#/var/spool/slurm/ctld</span>SlurmdSpoolDir=/tmp/slurmd <span class="hljs-comment">#/var/spool/slurm/d</span>SwitchType=switch/noneMpiDefault=noneSlurmctldPidFile=/var/run/slurmctld.pidSlurmdPidFile=/var/run/slurmd.pidProctrackType=proctrack/pgid<span class="hljs-comment">#PluginDir=</span><span class="hljs-comment">#FirstJobId=</span>ReturnToService=0<span class="hljs-comment">#MaxJobCount=</span><span class="hljs-comment">#PlugStackConfig=</span><span class="hljs-comment">#PropagatePrioProcess=</span><span class="hljs-comment">#PropagateResourceLimits=</span><span class="hljs-comment">#PropagateResourceLimitsExcept=</span><span class="hljs-comment">#Prolog=</span><span class="hljs-comment">#Epilog=</span><span class="hljs-comment">#SrunProlog=</span><span class="hljs-comment">#SrunEpilog=</span><span class="hljs-comment">#TaskProlog=</span><span class="hljs-comment">#TaskEpilog=</span><span class="hljs-comment">#TaskPlugin=</span><span class="hljs-comment">#TrackWCKey=no</span><span class="hljs-comment">#TreeWidth=50</span><span class="hljs-comment">#TmpFS=</span><span class="hljs-comment">#UsePAM=</span><span class="hljs-comment">#</span><span class="hljs-comment"># TIMERS</span>SlurmctldTimeout=300SlurmdTimeout=300InactiveLimit=0MinJobAge=300KillWait=30Waittime=0<span class="hljs-comment">#</span><span class="hljs-comment"># SCHEDULING</span>SchedulerType=<span class="hljs-built_in">sched</span>/backfill <span class="hljs-comment">#sched/backfill</span><span class="hljs-comment">#SchedulerAuth=</span>SelectType=select/linearFastSchedule=1<span class="hljs-comment">#PriorityType=priority/multifactor</span><span class="hljs-comment">#PriorityDecayHalfLife=14-0</span><span class="hljs-comment">#PriorityUsageResetPeriod=14-0</span><span class="hljs-comment">#PriorityWeightFairshare=100000</span><span class="hljs-comment">#PriorityWeightAge=1000</span><span class="hljs-comment">#PriorityWeightPartition=10000</span><span class="hljs-comment">#PriorityWeightJobSize=1000</span><span class="hljs-comment">#PriorityMaxAge=1-0</span><span class="hljs-comment">#</span><span class="hljs-comment"># LOGGING</span>SlurmctldDebug=infoSlurmctldLogFile=/var/<span class="hljs-built_in">log</span>/slurmctld.logSlurmdDebug=infoSlurmdLogFile=/var/<span class="hljs-built_in">log</span>/slurmd.logJobCompType=jobcomp/none<span class="hljs-comment">#JobCompLoc=</span><span class="hljs-comment">#</span><span class="hljs-comment"># ACCOUNTING</span><span class="hljs-comment">#JobAcctGatherType=jobacct_gather/linux</span><span class="hljs-comment">#JobAcctGatherFrequency=30</span><span class="hljs-comment">#</span><span class="hljs-comment">#AccountingStorageType=accounting_storage/slurmdbd</span><span class="hljs-comment">#AccountingStorageHost=</span><span class="hljs-comment">#AccountingStorageLoc=</span><span class="hljs-comment">#AccountingStoragePass=</span><span class="hljs-comment">#AccountingStorageUser=</span><span class="hljs-comment">#</span><span class="hljs-comment"># COMPUTE NODES</span>NodeName=linux[0-2] Procs=1 State=UNKNOWNPartitionName=debug Nodes=ALL Default=YES MaxTime=INFINITE State=UP</code></pre></li><li><p>制作成镜像</p><pre><code class="hljs bash">docker commit centos-with-ssh centos-with-slurm</code></pre></li></ol><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><ol><li><p>为防止docker每次启动ip变动，使用自定义网络后每次增加一个新的容器的host 列进去</p><pre><code class="hljs bash">docker network create --subnet=172.18.0.0/16 shadownet</code></pre></li><li><p>并以这个镜像创建三个节点（默认仅一个CPU，用<code>--cpus=</code>参数设置）：linux0，linux1，linux2</p><pre><code class="hljs bash">docker run -d -p 220:22 --name slurm-linux0 -h linux0 --net shadownet --ip 172.18.0.10 --add-host=linux1:172.18.0.11 --add-host=linux2:172.18.0.12 centos-with-slurm /usr/sbin/sshd -Ddocker run -d -p 221:22 --name slurm-linux1 -h linux1 --net shadownet --ip 172.18.0.11 --add-host=linux0:172.18.0.10 --add-host=linux2:172.18.0.12 centos-with-slurm /usr/sbin/sshd -Ddocker run -d -p 222:22 --name slurm-linux2 -h linux2 --net shadownet --ip 172.18.0.12 --add-host=linux0:172.18.0.10 --add-host=linux1:172.18.0.11 centos-with-slurm /usr/sbin/sshd -D</code></pre></li></ol><h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><p>各个节点以slurm用户启动munge（以linux0节点为例）</p><pre><code class="hljs bash">ssh -p220 root@localhostsu slurmmunged</code></pre><p>各个节点以root用户开启<code>slurmd</code></p><pre><code class="hljs bash">slurmd -c</code></pre><p>控制节点（linux0）以root用户开启<code>slurmctld</code></p><pre><code class="hljs bash">slurmctld -c</code></pre><p><code>slurmd</code>与<code>slurmctld</code>运行时均会读取slurm.conf配置文件，要确保所有节点的配置与slurmctld的配置相同。</p><p>验证</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8khc6qe4j314k0qowhj.jpg" srcset="/img/loading.gif" alt="image-20200225130941173"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>也可以借助virtualbox创建多个虚拟机进行搭建，默认配置了必要的环境（比如sshd服务，配置网络等）。不过这样（应该）不能复制配置，需要在每台机器配置slurm环境。</p><p>用<code>docker-machine</code>创建虚拟节点（创建虚拟节点时默认按virtualbox驱动，需要安装virtualbox）</p><p><code>docker-machine</code>创建虚拟节点时默认按virtualbox驱动，相当于使用docker管理virtualbox里的虚拟机，需要安装virtualbox。<code>docker-machine</code>默认配置了些必要的环境，比如开启sshd服务、配置网络环境等（这里可以事先下载<strong>最新</strong>的<a href="https://github.com/boot2docker/boot2docker/releases" target="_blank" rel="noopener"><code>boot2docker.iso</code></a>放到<code>~/.docker/machine/cache/</code>下，或者让docker在创建的时候自行下载）。</p><pre><code class="hljs bash">docker-machine create linux0docker-machine create linux1docker-machine create linux2</code></pre><p>查看虚拟机环境信息：</p><pre><code class="hljs bash">docker-machine env linux0&gt; <span class="hljs-built_in">export</span> DOCKER_TLS_VERIFY=<span class="hljs-string">"1"</span>&gt; <span class="hljs-built_in">export</span> DOCKER_HOST=<span class="hljs-string">"tcp://192.168.99.103:2376"</span>&gt; <span class="hljs-built_in">export</span> DOCKER_CERT_PATH=<span class="hljs-string">"/Users/barriery/.docker/machine/machines/linux0"</span>&gt; <span class="hljs-built_in">export</span> DOCKER_MACHINE_NAME=<span class="hljs-string">"linux0"</span>&gt; <span class="hljs-comment"># Run this command to configure your shell:</span>&gt; <span class="hljs-comment"># eval $(docker-machine env linux0)</span></code></pre><p>查看各个虚拟机的情况，可以看到docker自动为其分配的IP地址：</p><pre><code class="hljs bash">docker-machine ls&gt; NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS&gt; linux0  -        virtualbox   Running   tcp://192.168.99.103:2376           v19.03.5&gt; linux1  -        virtualbox   Running   tcp://192.168.99.104:2376           v19.03.5&gt; linux2  -        virtualbox   Running   tcp://192.168.99.105:2376           v19.03.5</code></pre><p>也可以打开virtualbox查看虚拟机状态：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc7i9j01f8j31830u0nbu.jpg" srcset="/img/loading.gif" alt="image-20200224150725244"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通过frp进行内网穿透</title>
    <link href="/2020/02/22/%E9%80%9A%E8%BF%87frp%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2020/02/22/%E9%80%9A%E8%BF%87frp%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>通常会有通过外网访问内网服务器的需求，比如在<del>寝室搬砖</del>，新冠隔离在家搬砖等。frp是一个十分方便的内网穿透工具，它可以实现对外网环境提供ssh，http或https服务。</p><a id="more"></a><p>暂时只用到ssh连接，所以本文只有介绍如何用frp工具实现内网穿透ssh连接。</p><h1 id="用到的东西"><a href="#用到的东西" class="headerlink" title="用到的东西"></a>用到的东西</h1><ol><li>具有外网访问权的云服务器</li><li>内网服务器</li><li>frp工具: <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></li></ol><h1 id="内网穿透实现ssh连接"><a href="#内网穿透实现ssh连接" class="headerlink" title="内网穿透实现ssh连接"></a>内网穿透实现ssh连接</h1><ol><li><p>下载<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp工具</a>，注意云服务器与内网服务器的frp版本要相同。</p></li><li><p>配置内网服务器</p><p>内网服务器需要配置的是<code>frpc.ini</code>文件：</p><pre><code class="hljs bash">cat frpc.ini&gt; [common]&gt; server_addr = &lt;云服务器的公网ip&gt;&gt; server_port = &lt;云服务器的监听端口&gt;&gt; &gt; [ssh01] <span class="hljs-comment"># 多个连接需要使用不同名字和端口</span>&gt; <span class="hljs-built_in">type</span> = &lt;配置类型，ssh为tcp&gt; <span class="hljs-comment"># tcp</span>&gt; local_ip = &lt;内网服务器的ip，可以填127.0.0.1&gt; <span class="hljs-comment"># 127.0.0.1</span>&gt; local_port = &lt;内网服务器需要监听的端口，ssh为22&gt; <span class="hljs-comment"># 22</span>&gt; remote_port = &lt;需要映射到公网服务器上的端口，之后的ssh连接需要这个端口&gt; <span class="hljs-comment"># 6001</span></code></pre><p>运行<code>frpc</code>：</p><pre><code class="hljs bash">nohup ./frpc -c ./frpc.ini &amp;&gt;elog.txt &amp;</code></pre><p>需要注意的是，内网服务器需要开放配置文件里的端口。</p></li><li><p>配置云服务器</p><p>云服务器需要配置的是<code>frps.ini</code>文件：</p><pre><code class="hljs bash">cat frps.ini&gt; [common]&gt; bind_port = &lt;监听端口，对应frpc.ini中的server_port&gt;</code></pre><p>运行<code>frps</code>：</p><pre><code class="hljs bash">nohup ./frps -c frps.ini &amp;&gt;elog.txt &amp;</code></pre><p>需要注意的是，云服务器需要开放配置文件里的端口（例如阿里云服务器需要手动开启端口）。</p></li><li><p>通过云服务器公网ip和内网服务器的<code>remote_port</code>端口来连接内网服务器：</p><pre><code class="hljs bash">ssh -p remote_port username@server_addr</code></pre></li><li><p>为了方便，可以在<code>~/.zshrc</code>中进行alias配置：</p><pre><code class="hljs bash"><span class="hljs-comment"># frp</span><span class="hljs-built_in">alias</span> sshtoserver=<span class="hljs-string">'frp &lt;server_addr&gt; &lt;client_addr&gt; &lt;remote_port&gt; &lt;username&gt;'</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">frp</span></span>()&#123;    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 4 ]; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: frp SERVER_IP CLIENT_IP PORT USR"</span>        <span class="hljs-comment"># plog ERROR red "Usage: frp SERVER_IP CLIENT_IP PORT USR"</span>        <span class="hljs-built_in">return</span> 1    <span class="hljs-keyword">fi</span>    server_ip=<span class="hljs-variable">$1</span>    client_ip=<span class="hljs-variable">$2</span>    port=<span class="hljs-variable">$3</span>    usr=<span class="hljs-variable">$4</span>    <span class="hljs-comment"># 检查是否可以在内网直接连接</span>    gtimeout 1 nc -z -n <span class="hljs-variable">$&#123;client_ip&#125;</span> 22 &amp;&gt;/dev/null    <span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"SSH by FRP"</span>        <span class="hljs-comment"># plog INFO green "SSH by FRP"</span>        ssh -p <span class="hljs-variable">$&#123;port&#125;</span> <span class="hljs-variable">$&#123;usr&#125;</span>@<span class="hljs-variable">$&#123;server_ip&#125;</span>    <span class="hljs-keyword">else</span>        ssh <span class="hljs-variable">$&#123;usr&#125;</span>@<span class="hljs-variable">$&#123;client_ip&#125;</span>    <span class="hljs-keyword">fi</span>&#125;</code></pre></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 一稚杨.Frp实现内网穿透[EB/OL].<a href="https://zhuanlan.zhihu.com/p/45445979,2018-09-27" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45445979,2018-09-27</a>.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>macOS静态编译问题</title>
    <link href="/2019/09/29/macOS%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"/>
    <url>/2019/09/29/macOS%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>看到群里在讨论boost，于是想着装个boost试试，但前后用了差不多一整天，最后发现是macOS上不能进行静态编译。</p><a id="more"></a><h2 id="首先是安装编译Boost"><a href="#首先是安装编译Boost" class="headerlink" title="首先是安装编译Boost"></a>首先是安装编译Boost</h2><p><a href="https://solarianprogrammer.com/2018/08/07/compiling-boost-gcc-clang-macos/" target="_blank" rel="noopener">https://solarianprogrammer.com/2018/08/07/compiling-boost-gcc-clang-macos/</a></p><p>我按照这个教程编译boost，用的是clang。</p><h2 id="测试Boost"><a href="#测试Boost" class="headerlink" title="测试Boost"></a>测试Boost</h2><h3 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h3><p>我用下面的程序进行测试：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/regex.hpp&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">" who,lives:in-a,pineapple        under  the  sea? "</span>;    <span class="hljs-function">boost::regex <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">",|:|-|//s+"</span>)</span></span>;    <span class="hljs-function">boost::sregex_token_iterator <span class="hljs-title">p</span><span class="hljs-params">(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), re, <span class="hljs-number">-1</span>)</span></span>;    boost::sregex_token_iterator <span class="hljs-built_in">end</span>;    <span class="hljs-keyword">while</span> (p != <span class="hljs-built_in">end</span>) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *p++ &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    &#125;&#125;</code></pre><p>测试编译：</p><pre><code class="hljs bash">g++ test_boost.cc -I<span class="hljs-variable">$BOOST_ROOT</span>/include -L<span class="hljs-variable">$BOOST_ROOT</span>/lib -lboost_regex</code></pre><p>编译成功，运行可执行文件报错：</p><pre><code class="hljs bash">dyld: Library not loaded: @rpath/libboost_regex.dylib  Referenced from: /Users/barriery/Desktop/CodeTest/./a.out  Reason: image not found[1]    1746 abort      ./a.out</code></pre><p>报错信息是找不到动态链接库<code>libboost_regex.dylib</code>，故在<code>LD_LIBRARY_PATH</code>中添加路径：</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-string">"<span class="hljs-variable">$LD_LIBRARY_PATH</span>:<span class="hljs-variable">$BOOST_PATH</span>/lib"</span></code></pre><p>顺利运行。</p><h3 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h3><p>上面采用了动态编译，接下来我想试下静态编译：</p><pre><code class="hljs bash">g++ test_boost.cc -I<span class="hljs-variable">$BOOST_ROOT</span>/include -L<span class="hljs-variable">$BOOST_ROOT</span>/lib -lboost_regex -static</code></pre><p>编译失败：</p><pre><code class="hljs bash">ld: library not found <span class="hljs-keyword">for</span> -lcrt0.oclang: error: linker <span class="hljs-built_in">command</span> failed with <span class="hljs-built_in">exit</span> code 1 (use -v to see invocation)</code></pre><p>关于<code>lcrt0.o</code>这个文件，我找到了这个：</p><blockquote><p><a href="https://stackoverflow.com/questions/3801011/ld-library-not-found-for-lcrt0-o-on-osx-10-6-with-gcc-clang-static-flag" target="_blank" rel="noopener">https://stackoverflow.com/questions/3801011/ld-library-not-found-for-lcrt0-o-on-osx-10-6-with-gcc-clang-static-flag</a>: </p><p>This option will not work on Mac OS X unless all libraries (including libgcc.a) have also been compiled with -static. Since neither a static version of libSystem.dylib nor crt0.o are provided, this option is not useful to most people.</p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/5259249/creating-static-mac-os-x-c-build" target="_blank" rel="noopener">https://stackoverflow.com/questions/5259249/creating-static-mac-os-x-c-build</a>: </p><p>Tying user binaries to the internal implementation of Mac OS X libraries and interfaces would limit our ability to update and enhance Mac OS X. Instead, dynamic linking is supported </p></blockquote><p>这里指出将二进制文件绑定到macOS库和接口的内部实现将限制更新和增强macOS的能力，故不提供<code>libSystem</code>文件的静态版本，所以macOS上无法进行静态编译。</p><p>不使用<code>static</code>选项重新编译了一下：</p><pre><code class="hljs bash">g++ test_boost.cc -I<span class="hljs-variable">$BOOST_ROOT</span>/include <span class="hljs-variable">$BOOST_ROOT</span>/lib/liblboost_regex.a</code></pre><p>查看生成的可执行文件使用的动态链接库：</p><pre><code class="hljs bash">» otool a.out -La.out:/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)</code></pre><p>其中<code>libSystem</code>不允许被静态绑定。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程关系</title>
    <link href="/2019/08/27/Linux%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/"/>
    <url>/2019/08/27/Linux%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://barriery.cn/2019/08/19/自动部署博客脚本/" target="_blank" rel="noopener">自动部署博客脚本</a>中，我提到了用<code>nohup</code>让程序在后台运行（nohup的原理是使进程不对SIGHUP信号进行处理），并用<code>ps</code>命令查找”auto-blog-submit.sh”的进程号，用<code>kill</code>干掉进程。但这种做法其实存在问题，杀掉”auto-blog-submit.sh”后用<code>ps</code>仍然可以找到”fswatch”的进程，于是就有了这篇文章。</p><a id="more"></a><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>为了便于研究测试，将原脚本简化如下：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span>nohup fswatch -o ./<span class="hljs-built_in">test</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span><span class="hljs-keyword">do</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"file changed."</span><span class="hljs-keyword">done</span> &amp;</code></pre><p>当上述脚本运行结束后，<code>ps -Ao pid,pgid,ppid,command</code>得到由该脚本启动的进程有两个：</p><pre><code class="hljs bash">  PID  PGID  PPID COMMAND24719 24716     1 fswatch -o ./<span class="hljs-built_in">test</span>24720 24716     1 sh ./test.sh</code></pre><p>这两个进程是怎么来的，如何优雅地杀掉这些进程？就是接下来的内容。</p><h1 id="什么是进程-Process"><a href="#什么是进程-Process" class="headerlink" title="什么是进程 - Process"></a>什么是进程 - Process</h1><p>首先要有进程的概念，进程是程序的具体实现，即执行程序的过程。程序与进程的关系和面向对象语言中的类与实例的关系类似。同个类可以实例化多次；而同个程序也可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。</p><p>每一个进程都有一个唯一的PID来代表自己的身份，进程也可以根据PID来识别其他的进程。</p><h1 id="进程的创建-fork-amp-exec"><a href="#进程的创建-fork-amp-exec" class="headerlink" title="进程的创建 - fork&amp;exec"></a>进程的创建 - fork&amp;exec</h1><p>当计算机启动时，内核（kernel）只建立了一个init进程。Linux内核并不提供直接建立新进程的系统调用，剩下的所有进程都是init进程通过fork机制建立的。当进程fork的时候，Linux在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。需要注意的是，实际执行fork时，物理空间上两个进程的数据段和堆栈段都还是共享着的，当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别（Copy-on-write）。下面这段代码演示了使用fork的基本框架：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 子进程</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 父进程</span>  &#125;&#125;</code></pre><p>通常fork与exec函数簇结合使用来实现一个进程启动另一个程序的执行。exec函数的作用是”启动参数指定的程序，代替自身进程”，如果不配合fork使用，它是”当前进程结束，执行指定进程”；配合fork使用，就成了”当前进程启动另一个进程”。一个进程一旦调用exec类函数，它本身就”死亡”了，系统把代码段替换成新的程序的代码，并为新程序分配新的数据段与堆栈段，唯有进程号不变，对系统而言虽然还是同一个进程，但已经是另一个程序了。下面以exec函数簇中的execlp为例（该程序从终端读入命令并执行，执行完成后父进程继续等待从终端读入命令）：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">char</span> command[<span class="hljs-number">256</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-keyword">int</span> rtn; <span class="hljs-comment">// 子进程的返回值</span>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// 从终端读取要执行的命令</span>    fgets(command, <span class="hljs-number">256</span>, <span class="hljs-built_in">stdin</span>);    command[<span class="hljs-built_in">strlen</span>(command)<span class="hljs-number">-1</span>] = <span class="hljs-string">'\0'</span>;    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// 子进程执行此命令</span>      execlp(command, <span class="hljs-literal">NULL</span>);      perror(command); <span class="hljs-comment">// 如果exec函数返回，则表明命令没有正常执行，打印错误信息</span>      <span class="hljs-built_in">exit</span>(errno);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 父进程等待子进程结束，并打印子进程的返回值</span>      wait(&amp;rtn);      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child process return %d\n"</span>, rtn);    &#125;  &#125;&#125;</code></pre><p>当一个进程通过fork建立一个新的进程，老进程作为新进程的父进程（parent process），相应的新进程作为老进程的子进程（child process）。一个进程除了有一个PID之外，还会有一个PPID（parent PID）来存储的父进程PID。如果我们循着PPID不断向上追溯的话，总会发现其源头是init进程。所以说，所有的进程也构成一个以init为根的树状结构。</p><h1 id="进程组与会话-Process-Group-amp-Session"><a href="#进程组与会话-Process-Group-amp-Session" class="headerlink" title="进程组与会话 - Process Group&amp;Session"></a>进程组与会话 - Process Group&amp;Session</h1><p>每个进程都会属于一个进程组（process group），每个进程组中可以包含多个进程。进程组的第一个进程即进程组领导进程 （process group leader），领导进程的PID成为进程组ID (process group ID, PGID)，以识别进程组。</p><p>多个进程组还可以构成一个会话 （session），会话通常由登录过程设置。同样，会话的第一个进程即会话领导进程(session leader)，会话领导进程的PID成为识别会话的SID(session ID)。会话中的每个进程组称为一个工作(job)。会话可以有一个进程组成为会话的前台工作(foreground)，而其他的进程组是后台工作(background)。每个会话可以连接一个控制终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。由终端产生的信号，比如CTRL+Z， CTRL+\，会传递到前台进程组。</p><p>会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。</p><p>下面这张图说明在一个终端执行下列命令后，各个进程之间的进程组和会话关系：</p><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> $$                            <span class="hljs-comment"># Display the PID of the shell</span>400$ find / 2 &gt; /dev/null | wc -l &amp;     <span class="hljs-comment"># Creates 2 processes in background group</span>[1] 659$ sort &lt; longlist | uniq -c          <span class="hljs-comment"># Creates 2 processes in foreground group</span></code></pre><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6kh3whjqsj31110u0q5z.jpg" srcset="/img/loading.gif" alt="进程组、会话和控制终端之间的关系"></p><p>find, wc, sort, uniq都是bash的子进程，当子进程的父进程终结时，子进程的PPID会发生改变（变为已终结的父进程的PPID）。进程组领导进程的PID即进程组PGID，进程组领导进程可以先终结，此时进程组依然存在，并且PGID不发生改变。会话领导进程的PID即会话SID，当会话领导进程终结时，会向前台进程组中的所有进程发送SIGHUP信号。</p><h1 id="之前的脚本在运行中发生了什么"><a href="#之前的脚本在运行中发生了什么" class="headerlink" title="之前的脚本在运行中发生了什么"></a>之前的脚本在运行中发生了什么</h1><p>回到最开始的问题，如何优雅地杀掉脚本中的进程。</p><p>如果用<code>pstree</code>命令来显示脚本运行过程中的进程树，将得到如下结构：</p><pre><code class="hljs bash">...─┬─...    └─sh test.sh─┬─fswatch -o ./<span class="hljs-built_in">test</span>                 └─sh test.sh</code></pre><p>他们的PID，PGID与PPID如下：</p><pre><code class="hljs bash"> PID  PGID  PPID COMMAND5068  5068   599 sh test.sh5071  5068  5068 fswatch -o ./<span class="hljs-built_in">test</span>5072  5068  5068 sh test.sh</code></pre><p>这里PID=5068的<code>sh test.sh</code>进程作为父进程新创建了PID=5072的子进程<code>sh test.sh</code>，这里新进程其实是脚本中的<code>do...while</code>部分。可以看到这些进程同属于同一个进程组，PGID为该进程组的第一个进程的PID即5068。</p><p>当脚本执行结束，PID=5068的父进程终结，进程组依然存在，且PGID不发生改变。两个子进程PPID发生变更：</p><pre><code class="hljs bash">...─┬─fswatch -o ./<span class="hljs-built_in">test</span>    └─sh test.sh</code></pre><pre><code class="hljs bash"> PID  PGID  PPID COMMAND5071  5068     1 fswatch -o ./<span class="hljs-built_in">test</span>5072  5068     1 sh test.sh</code></pre><p>因此，我们可以根据这些进程在同一个进程组这个特点，一次性将进程组内所有进程kill掉，就达成了目标。</p><h1 id="修改后的自动部署博客脚本"><a href="#修改后的自动部署博客脚本" class="headerlink" title="修改后的自动部署博客脚本"></a>修改后的自动部署博客脚本</h1><p>修改后的脚本在原来弹窗的基础上添加了”Kill Processes”按钮，以便遇到异常直接杀掉进程。同时为了代码复用，我将几个比较通用的函数分离出来，构建一个自己的Helper库。</p><h4 id="auto-blog-submit-sh"><a href="#auto-blog-submit-sh" class="headerlink" title="auto-blog-submit.sh"></a>auto-blog-submit.sh</h4><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span>. ~/Helper/Bash/plog.sh <span class="hljs-comment"># log function</span>. ~/Helper/Bash/showDialog.sh <span class="hljs-comment"># show dialog function</span>BLOG_PATH=/Users/barriery/Blog/LOG_PATH=<span class="hljs-variable">$&#123;BLOG_PATH&#125;</span>/auto-blog-submit.logARTICLE_PATH=<span class="hljs-variable">$&#123;BLOG_PATH&#125;</span>/<span class="hljs-built_in">source</span>/_posts<span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;BLOG_PATH&#125;</span> <span class="hljs-comment"># Otherwise the script will run in the home path</span><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-variable">$&#123;LOG_PATH&#125;</span> ]; <span class="hljs-keyword">then</span>    touch <span class="hljs-variable">$&#123;LOG_PATH&#125;</span><span class="hljs-keyword">fi</span>PGID=$$ <span class="hljs-comment"># 当前进程组ID</span>plog -t -l OK -c green -m <span class="hljs-string">"Current group process ID is \033[33m<span class="hljs-variable">$&#123;PGID&#125;</span>\033[0m"</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>nohup fswatch -o <span class="hljs-variable">$&#123;ARTICLE_PATH&#125;</span> -l 900 | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span><span class="hljs-keyword">do</span>    plog -t -m <span class="hljs-string">"Start deploying..."</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>    hexo g -d &gt;/dev/null  2&gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>    <span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span>        plog -t -l ERROR -c red -m <span class="hljs-string">"Hexo deploy failed."</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>        say <span class="hljs-string">"自动部署博客脚本出现异常"</span>        button_returned=$(showDialog -t <span class="hljs-string">"auto-blog-submit.sh"</span> -m <span class="hljs-string">"[ERROR] Hexo deploy failed"</span> -b <span class="hljs-string">"View Log,Kill Process,Cancel"</span> -d <span class="hljs-string">","</span>)        plog -t -l INFO -c yellow -m <span class="hljs-string">"You choose \033[33m<span class="hljs-variable">$&#123;button_returned&#125;</span>\033[0m"</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>        <span class="hljs-comment"># $&#123;button_returned&#125; 加引号防止变量中空格造成影响</span>        <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$&#123;button_returned&#125;</span>"</span> = <span class="hljs-string">"Cancel"</span> ]; <span class="hljs-keyword">then</span>            : <span class="hljs-comment"># Do nothing beyond expanding arguments and performing redirections. The return status is zero.</span>        <span class="hljs-keyword">elif</span> [ <span class="hljs-string">"<span class="hljs-variable">$&#123;button_returned&#125;</span>"</span> = <span class="hljs-string">"View Log"</span> ]; <span class="hljs-keyword">then</span>            <span class="hljs-comment"># 新建一个iTerm窗口 并执行命令</span>            osascript ~/Helper/AppleScript/newTerminalAndRunCMD.scpt <span class="hljs-string">"cd <span class="hljs-variable">$&#123;BLOG_PATH&#125;</span> &amp;&amp; tail <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>"</span>        <span class="hljs-keyword">elif</span> [ <span class="hljs-string">"<span class="hljs-variable">$&#123;button_returned&#125;</span>"</span> = <span class="hljs-string">"Kill Process"</span> ]; <span class="hljs-keyword">then</span>            pkill -g <span class="hljs-variable">$&#123;PGID&#125;</span>            <span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span>                plog -t -l ERROR -c red -m <span class="hljs-string">"pkill -g <span class="hljs-variable">$&#123;PGID&#125;</span> is failed."</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>                showDialog -t <span class="hljs-string">"pkill"</span> -m <span class="hljs-string">"[ERROR] kill process failed."</span> -b <span class="hljs-string">"OK"</span>            <span class="hljs-keyword">else</span>                plog -t -l OK -c green -m <span class="hljs-string">"pkill -g <span class="hljs-variable">$&#123;PGID&#125;</span> success."</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>                <span class="hljs-built_in">exit</span> 0            <span class="hljs-keyword">fi</span>        <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span> &amp;</code></pre><h4 id="plog-sh"><a href="#plog-sh" class="headerlink" title="plog.sh"></a>plog.sh</h4><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">plog</span></span>()&#123;    <span class="hljs-comment"># getopts: https://wiki.bash-hackers.org/howto/getopts_tutorial</span>    <span class="hljs-function"><span class="hljs-title">usage</span></span>()&#123;        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: plog [-t] [-l level] [-c level_color] [-n level_number] -m message"</span>    &#125;    <span class="hljs-comment"># something must to be init</span>    OPTIND=1 <span class="hljs-comment"># The index of params</span>    timestamp=<span class="hljs-string">""</span>    level=<span class="hljs-string">""</span>    level_color=<span class="hljs-string">""</span>    level_number=<span class="hljs-string">""</span> <span class="hljs-comment"># log will not echo if level_number &lt; PLOG_LEVEL</span>    message=<span class="hljs-string">""</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> <span class="hljs-string">"tn:l:c:m:"</span> OPT; <span class="hljs-keyword">do</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$OPT</span>"</span> <span class="hljs-keyword">in</span>            t)                timestamp=[$(date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S"</span>)];;            l)                level=[<span class="hljs-variable">$&#123;OPTARG&#125;</span>];;            c)                level_color=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            n)                level_number=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            m)                message=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            ?)                usage &amp;&amp; <span class="hljs-built_in">return</span> 1;;            :)                usage &amp;&amp; <span class="hljs-built_in">return</span> 1;;        <span class="hljs-keyword">esac</span>    <span class="hljs-keyword">done</span>    <span class="hljs-comment"># []是shell内部命令 [[]]是shell关键字</span>    <span class="hljs-comment"># []中一些逻辑符号会被shell解释（比如&gt;解释为重定向符号）但关键字不这样</span>    <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">"<span class="hljs-variable">$message</span>"</span> ]]; <span class="hljs-keyword">then</span>        usage &amp;&amp; <span class="hljs-built_in">return</span> 1    <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">"<span class="hljs-variable">$level</span>"</span> &amp;&amp; -n <span class="hljs-variable">$&#123;level_color&#125;</span> ]]; <span class="hljs-keyword">then</span>        <span class="hljs-keyword">case</span> <span class="hljs-variable">$&#123;level_color&#125;</span> <span class="hljs-keyword">in</span>            black|k|黑|30)                level=<span class="hljs-string">"\033[30m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            red|r|红|31)                level=<span class="hljs-string">"\033[31m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            green|g|绿|32)                level=<span class="hljs-string">"\033[32m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            yellow|y|黄|33)                level=<span class="hljs-string">"\033[33m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            blue|b|蓝|34)                level=<span class="hljs-string">"\033[34m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            purple|p|紫|35)                level=<span class="hljs-string">"\033[35m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            cyan|c|青|36)                level=<span class="hljs-string">"\033[36m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            white|w|白|37)                level=<span class="hljs-string">"\033[37m<span class="hljs-variable">$&#123;level&#125;</span>\033[0m"</span>;;            *)                plog -l ERROR -c red -m <span class="hljs-string">"Unknown param color <span class="hljs-variable">$&#123;level_color&#125;</span>"</span>                <span class="hljs-built_in">return</span> 1;;        <span class="hljs-keyword">esac</span>    <span class="hljs-keyword">fi</span>    str_list=(<span class="hljs-string">"<span class="hljs-variable">$&#123;level&#125;</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$&#123;timestamp&#125;</span>"</span>)    <span class="hljs-comment"># 字符串数组中若串中带空格 建议用下标取值</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;!str_list[@]&#125;</span>; <span class="hljs-keyword">do</span>        <span class="hljs-keyword">if</span> [[ -n <span class="hljs-string">"<span class="hljs-variable">$&#123;str_list[$i]&#125;</span>"</span> ]]; <span class="hljs-keyword">then</span>            message=<span class="hljs-string">"<span class="hljs-variable">$&#123;str_list[$i]&#125;</span> <span class="hljs-variable">$&#123;message&#125;</span>"</span>        <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">done</span>    <span class="hljs-keyword">if</span> [[ -z <span class="hljs-variable">$&#123;level_number&#125;</span> ]]; <span class="hljs-keyword">then</span>        level_number=<span class="hljs-variable">$&#123;PLOG_LEVEL&#125;</span>    <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$&#123;level_number&#125;</span> -lt <span class="hljs-variable">$&#123;PLOG_LEVEL&#125;</span> ]]; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">return</span> 0    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$message</span>"</span>    <span class="hljs-keyword">fi</span>&#125;</code></pre><h4 id="showDialog-sh"><a href="#showDialog-sh" class="headerlink" title="showDialog.sh"></a>showDialog.sh</h4><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">showDialog</span></span>()&#123;    <span class="hljs-function"><span class="hljs-title">usage</span></span>() &#123;        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: showDialog -m message -b button[, button]* [-d delimiters] [-t title]"</span>    &#125;    <span class="hljs-comment"># something must to be init</span>    OPTIND=1 <span class="hljs-comment"># The index of params</span>    message=<span class="hljs-string">""</span>    button=<span class="hljs-string">""</span>    delimiters=<span class="hljs-string">" "</span> <span class="hljs-comment"># the defalut delimiters is " "</span>    title=<span class="hljs-string">""</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> <span class="hljs-string">"m:b:d:t:"</span> OPT; <span class="hljs-keyword">do</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$OPT</span>"</span> <span class="hljs-keyword">in</span>            m)                message=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            b)                buttons=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            d)                delimiters=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            t)                title=<span class="hljs-variable">$&#123;OPTARG&#125;</span>;;            ?)                usage &amp;&amp; <span class="hljs-built_in">return</span> 1;;            :)                usage &amp;&amp; <span class="hljs-built_in">return</span> 1;;        <span class="hljs-keyword">esac</span>    <span class="hljs-keyword">done</span>    required_param_list=(<span class="hljs-string">"m"</span> <span class="hljs-string">"b"</span>)    required_value_list=(<span class="hljs-string">"<span class="hljs-variable">$message</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$buttons</span>"</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;!required_value_list[@]&#125;</span>; <span class="hljs-keyword">do</span>        <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">"<span class="hljs-variable">$&#123;required_value_list[$i]&#125;</span>"</span> ]; <span class="hljs-keyword">then</span>            <span class="hljs-built_in">echo</span> <span class="hljs-string">"[ERROR] Missing parameter <span class="hljs-variable">$&#123;required_param_list[$i]&#125;</span>"</span>            <span class="hljs-built_in">return</span> 1        <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">done</span>    osascript &lt;&lt;-EndOfScript        <span class="hljs-built_in">set</span> AppleScript<span class="hljs-string">'s text item delimiters to "$delimiters"</span><span class="hljs-string">        set btn_list to every text item of "$buttons"</span><span class="hljs-string">        display dialog "$message" buttons btn_list with title "$title"</span><span class="hljs-string">        get the button returned of the result</span><span class="hljs-string">EndOfScript</span><span class="hljs-string">&#125;</span></code></pre><h4 id="newTerminalAndRunCMD-scpt"><a href="#newTerminalAndRunCMD-scpt" class="headerlink" title="newTerminalAndRunCMD.scpt"></a>newTerminalAndRunCMD.scpt</h4><pre><code class="hljs bash"><span class="hljs-comment">#!/usr/bin/osascript</span>on run &#123;<span class="hljs-built_in">command</span>&#125;<span class="hljs-keyword">if</span> application <span class="hljs-string">"iTerm"</span> is running <span class="hljs-keyword">then</span>tell application <span class="hljs-string">"iTerm"</span>create window with default profiletell current session of current windowwrite text <span class="hljs-built_in">command</span>end tellend tell<span class="hljs-keyword">else</span>activate application <span class="hljs-string">"iTerm"</span>end <span class="hljs-keyword">if</span>end run</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Andries Brouwer.The Linux kernel: Process[EB/OL].<a href="https://www.win.tue.nl/~aeb/linux/lk/lk-10.html" target="_blank" rel="noopener">https://www.win.tue.nl/~aeb/linux/lk/lk-10.html</a>, 2003-02-01.</p><p>[2] 老邮局.Linux下Fork与Exec使用[EB/OL].<a href="https://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html" target="_blank" rel="noopener">https://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html</a>, 2011-01-20.</p><p>[3] invalid s.为什么Linux下要把创建进程分为fork()和exec()(一系列函数)两个函数来处理? - invalid s的回答 - 知乎[EB/OL].<a href="https://www.zhihu.com/question/66902460/answer/247277668" target="_blank" rel="noopener">https://www.zhihu.com/question/66902460/answer/247277668</a>, 2017-10-21.</p><p>[4] Michael Kerrisk.The Linux Programming Interface國際中文版[DB/OL].<a href="http://epaper.gotop.com.tw/PDFSample/AXP015900.pdf" target="_blank" rel="noopener">http://epaper.gotop.com.tw/PDFSample/AXP015900.pdf</a>, 2016-10.</p><h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><p>Unix与Linux还是有较大的区别，该考虑使用docker了。</p>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动部署博客脚本</title>
    <link href="/2019/08/19/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC/"/>
    <url>/2019/08/19/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>前几天刚把博客迁移了过来，顺便更了两篇文章。想着每次写完文章（或者对原来的文章作改动）就要手动部署下有点麻烦，尝试寻找自动更新博客方案。</p><a id="more"></a><h1 id="fswatch"><a href="#fswatch" class="headerlink" title="fswatch"></a>fswatch</h1><p>实现自动更新博客关键在于检测文件变动，根据这个思路我找到了<code>fswatch</code>。</p><p><code>fswatch</code>是一个跨平台的文件更改监视器，在指定的文件或目录的内容被改变或修改时会做出通知。<code>man fswatch</code>得到的描述如下：</p><pre><code class="hljs bash">fswatch -- Ask <span class="hljs-keyword">for</span> notification when the contents of the specified files or directory hierarchies are modified.</code></pre><p>用brew安装好后，简单使用一下，fswatch的用法是：</p><pre><code class="hljs bash">fswatch (option)* path+</code></pre><p>下面demo包含了<code>fswatch</code>监控文件创建，修改与删除操作：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g65ebry19hg30k80ba4qq.gif" srcset="/img/loading.gif" alt="fswatch监控文件创建，修改和删除"></p><h1 id="display-dialog"><a href="#display-dialog" class="headerlink" title="display dialog"></a>display dialog</h1><p>若终端脚本在后台运行时出现异常（自动部署失败），不能只是写入日志还需要主动提醒（例如弹窗），在macOS下我找到了AppleScript。</p><p>Applescript是适用于macOS的一种脚本语言，可以用于直接控制macOS上的应用程序，来实现macOS的自动化。这里我用AppleScript中的display dialog来实现弹窗功能：</p><pre><code class="hljs bash"><span class="hljs-comment">#!/usr/bin/env osascript</span>tell app <span class="hljs-string">"System Events"</span>    display dialog <span class="hljs-string">"required dialog text"</span> buttons &#123;<span class="hljs-string">"optional button text 1"</span>, <span class="hljs-string">"optional button text 2"</span>&#125; with title <span class="hljs-string">"optional dialog title text"</span>    get the button returned of the resultend tell</code></pre><p>运行上面这个脚本将弹出一个dialog，窗口内容为”required dialog text”，窗口内有两个按钮”optional button text 1”和”optional button text 2”，窗口名为”optional dialog title text”，点击按钮后脚本返回所选按钮的文本。</p><p>AppleScript需要用osascript命令来运行：</p><pre><code class="hljs bash"><span class="hljs-comment"># 方式一:</span>osascript applescript.scpt<span class="hljs-comment"># 方式二: </span>osascript -e <span class="hljs-string">'script command'</span><span class="hljs-comment"># 方式三: 使用heredoc: http://www.tldp.org/LDP/abs/html/here-docs.html, 这种方式可以很好地解决bash到AppleScript的参数传递问题</span>osascript &lt;&lt;-<span class="hljs-string">'END'</span>script <span class="hljs-built_in">command</span>END</code></pre><h1 id="自动部署博客脚本"><a href="#自动部署博客脚本" class="headerlink" title="自动部署博客脚本"></a>自动部署博客脚本</h1><p>利用<code>fswatch</code>和<code>display dialog</code>可以得到如下auto-blog-submit.sh脚本：</p><pre><code class="hljs bash">BLOG_PATH=/Users/barriery/Blog/ <span class="hljs-comment"># your blog root path</span>LOG_PATH=<span class="hljs-variable">$&#123;BLOG_PATH&#125;</span>/auto-blog-submit.logARTICLE_PATH=<span class="hljs-variable">$&#123;BLOG_PATH&#125;</span>/<span class="hljs-built_in">source</span>/_posts<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">showDialog</span></span>()&#123;osascript -e <span class="hljs-string">'tell app "System Events"</span><span class="hljs-string">display dialog "[ERROR] Hexo deploy failed." buttons &#123;"View Log", "Cancel"&#125; default button "View Log" with title "auto-blog-submit.sh"</span><span class="hljs-string">get the button returned of the result</span><span class="hljs-string">end tell'</span>&#125;<span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;BLOG_PATH&#125;</span> <span class="hljs-comment"># Otherwise the script will run in the home path</span><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-variable">$&#123;LOG_PATH&#125;</span> ]; <span class="hljs-keyword">then</span>    touch <span class="hljs-variable">$&#123;LOG_PATH&#125;</span><span class="hljs-keyword">fi</span>nohup fswatch -o <span class="hljs-variable">$&#123;ARTICLE_PATH&#125;</span> -l 900 | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span><span class="hljs-keyword">do</span>    date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S"</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>    hexo g -d &gt;/dev/null  2&gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>    <span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"\033[31m[ERROR]\033[0m Hexo deploy failed."</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>        say <span class="hljs-string">"自动部署博客脚本出现异常"</span>        botton_returned=$(showDialog)        <span class="hljs-built_in">echo</span> <span class="hljs-string">"\033[33m[INFO]\033[0m You choose \033[33m<span class="hljs-variable">$&#123;botton_returned&#125;</span>\033[0m"</span> &gt;&gt; <span class="hljs-variable">$&#123;LOG_PATH&#125;</span>        <span class="hljs-comment"># $&#123;botton_returned&#125; 加引号防止变量中空格造成影响</span>        <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$&#123;botton_returned&#125;</span>"</span> = <span class="hljs-string">"Cancel"</span> ]; <span class="hljs-keyword">then</span>            : <span class="hljs-comment"># Do nothing beyond expanding arguments and performing redirections. The return status is zero.</span>        <span class="hljs-keyword">elif</span> [ <span class="hljs-string">"<span class="hljs-variable">$&#123;botton_returned&#125;</span>"</span> = <span class="hljs-string">"View Log"</span> ]; <span class="hljs-keyword">then</span>            open -a Sublime\ Text <span class="hljs-variable">$&#123;LOG_PATH&#125;</span> <span class="hljs-comment"># Using Sublime to open log file.</span>        <span class="hljs-keyword">fi</span>    <span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span> &amp;</code></pre><p>其中，<code>fswatch</code>的<code>-o</code>参数是仅输出监控到的事件数；<code>-l</code>参数指定了潜伏时间，这里结束一次监控后潜伏900秒（默认为1秒）做下一次监控。</p><p>该脚本放监控<code>${BLOG_PATH}/source/_posts</code>中的文件（也就是自己写的文章放置的位置），当文件变动时会将log写入<code>${BLOG_PATH}/auto-blog-submit.log</code>中，并重新部署博客。当脚本出现异常的时候，语音播报”自动部署博客脚本出现异常”，并弹出窗口提示脚本出现异常。</p><h1 id="开机自动运行脚本"><a href="#开机自动运行脚本" class="headerlink" title="开机自动运行脚本"></a>开机自动运行脚本</h1><p>需要开机运行脚本才能使得博客能够一直更新。</p><p>Mac上设置开机自动运行如下：</p><pre><code class="hljs plain">系统偏好设置 -&gt; 用户与群组 -&gt; 当前用户 -&gt; 登录项 -&gt; 添加脚本</code></pre><p>同时设置脚本默认打开方式（iTerm或Terminal）并需要给予脚本root权限：</p><pre><code class="hljs bash">chmod 777 auto-blog-submit.sh</code></pre><h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><p>刚开始测试脚本的时候，发现开机自动运行会保留终端窗口，所以需要挂在后台运行，用到<code>nohup</code>。</p><p><code>nohup</code>可以让程序始终在后台执行，即使关闭当前的终端或退出账户也能继续执行（而用<code>&amp;</code>关闭终端则会停止运行）。用法：</p><pre><code class="hljs bash">nohup <span class="hljs-built_in">command</span> &amp;</code></pre><p>关闭终端后，在另一个终端用<code>jobs</code>已经无法看到后台跑的程序了，此时利用ps进程查看命令：</p><pre><code class="hljs bash">ps -Ao pid,user,start,<span class="hljs-built_in">command</span> | grep <span class="hljs-string">"auto-blog-submit.sh"</span> <span class="hljs-comment"># Linux: ps -aux | grep "auto-blog-submit.sh"</span></code></pre><p>找到进程号后，开源用<code>kill</code>杀进程：</p><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 进程号</code></pre>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tabnine-vim插件使用时遇到的一些问题</title>
    <link href="/2019/08/11/tabnine-vim%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2019/08/11/tabnine-vim%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>tabnine是一个在GPT-2的基础上构建的AI自动补全插件，它可以做到基于语义补全，详细见<a href="https://zhuanlan.zhihu.com/p/73811872" target="_blank" rel="noopener">杀手级AI补代码工具问世，支持23种语言及5种主流编辑器，程序员沸腾了</a>。我在安装使用遇到了诸多问题。</p><a id="more"></a><ol><li>Plug安装插件hang住</li><li>安装完插件，vim闪退</li><li>brew更新vim失败</li><li>Semantic Completion遇到问题</li><li>安装配置cquery</li></ol><h2 id="第一个问题-安装插件"><a href="#第一个问题-安装插件" class="headerlink" title="第一个问题 - 安装插件"></a>第一个问题 - 安装插件</h2><pre><code class="hljs bash">Plug <span class="hljs-string">'zxqfl/tabnine-vim'</span> <span class="hljs-string">" AI自动补全</span></code></pre><p><code>PlugInstall</code>后遇到了第一个问题，一直hang住：</p><pre><code class="hljs bash">+ tabnine-vim: remote: Compressing objects: 100% (4496/4496), <span class="hljs-keyword">done</span>.</code></pre><p>会不会是Plug的问题？于是我尝试<a href="https://github.com/dofy/learn-vim/blob/master/plugin.md" target="_blank" rel="noopener">手动安装插件</a>，发现是tabnine-vim比较大而且网络很差导致需要长时间clone仓库，而PlugInstall的过程中没有显示下载进度，所以看起来像是hang住了。为了便于管理，我还是用PlugInstall挂一晚上安装成功。</p><h2 id="第二个问题-尝试使用"><a href="#第二个问题-尝试使用" class="headerlink" title="第二个问题 - 尝试使用"></a>第二个问题 - 尝试使用</h2><p>安装完tabnine-vim后用vim打开一个文件，vim闪退并报类似下面的错误：</p><pre><code class="hljs plain">Vim: Caught deadly signal SEGVError detected while processing function 81_PollServerReady[7]..81_Pyeval:Vim: Finished.line 4:Exception MemoryError: MemoryError() in &lt;module &#39;threading&#39; from &#39;&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;2.7&#x2F;lib&#x2F;python2.7&#x2F;threading.pyc&#39;&gt; ignored</code></pre><p>有点懵逼，在tabnine-vim的issue页看到了这个issue：<a href="https://github.com/zxqfl/tabnine-vim/issues/12" target="_blank" rel="noopener">Vim: Caught deadly signal SEGV #12</a>，这个用户在更新macOS到Mojave 10.14后也遇到了这个问题，于是他选择将vim切换为neovim，并关闭了issue（颇有我的做事风格）。</p><p>emmmm虽然没有解决问题，但好歹知道了应该是Mojave 10.14与vim的问题。</p><h2 id="第三个问题-更新Vim"><a href="#第三个问题-更新Vim" class="headerlink" title="第三个问题 - 更新Vim"></a>第三个问题 - 更新Vim</h2><p>我找到了这个博客：<a href="https://wxnacy.com/2019/03/15/vim-error-caught-deadly-signal-segv/" target="_blank" rel="noopener">Vim 报错：Caught deadly signal SEGV</a>，可能是因为某些插件运行需要vim支持lua等，但当前vim版本不支持，需要更新vim：</p><pre><code class="hljs bash">» brew install vim</code></pre><p>更新失败，报了个Error：</p><pre><code class="hljs bash">Error: The `brew link` step did not complete successfullyThe formula built, but is not symlinked into /usr/<span class="hljs-built_in">local</span>Could not symlink share/man/de/man1/ex.1/usr/<span class="hljs-built_in">local</span>/share/man/de/man1 is not writable.</code></pre><p>再次懵逼，看起来好像是权限相关的问题，这个issue与我的情况很像：<a href="https://github.com/caskformula/homebrew-caskformula/issues/10" target="_blank" rel="noopener">Error: The <code>brew link</code> step did not complete successfully#10</a>。</p><p>可能是由于一些软件通过非Homebrew安装（比如.pkg安装程序，make install等），造成的<code>/usr/local</code>不是Homebrew期望的user-writable权限。可以用<code>brew doctor</code>列出目录中没有由Homebrew链接的<code>/usr/local/[a-z]*</code>文件。</p><p>修复Error log中的<code>/usr/local/share/man/de/man1</code>的用户权限：</p><pre><code class="hljs bash">» sudo chown <span class="hljs-variable">$USER</span>:admin /usr/<span class="hljs-built_in">local</span>/share/man/de/man1<span class="hljs-comment"># 这里 $USER 需要手动修改为用户名，因为sudo会将其替换为 root</span></code></pre><p>重新链接vim：</p><pre><code class="hljs bash">» brew link vimLinking /usr/<span class="hljs-built_in">local</span>/Cellar/vim/8.1.1800... 163 symlinks created</code></pre><p>然后第二个问题也消失了。</p><h2 id="第四个问题-开始使用TabNine"><a href="#第四个问题-开始使用TabNine" class="headerlink" title="第四个问题 - 开始使用TabNine"></a>第四个问题 - 开始使用TabNine</h2><p>装好后迫不及待上手试试，autocomplete显示如下：</p><pre><code class="hljs C++">  <span class="hljs-number">1</span> <span class="hljs-meta">#inc</span>~    include~    TabNine was unable to start the cpp semantic completion backend.~    The command tried was: `cquery --init=&#123;<span class="hljs-string">"cacheDirectory"</span>: <span class="hljs-string">"$&#123;project_root&#125;/.cquery_cache"</span>&#125;`~    This means you need to install the backend manually.~    For help, see tabnine.com/semantic.~    Or, type TabNine::no_sem to disable semantic completion <span class="hljs-keyword">for</span> C/C++.~    (TabNine works well even without semantic completion.)</code></pre><p>上面提示cpp的semantic completion并没有启用，需要手动安装cquery后端。</p><p>官网<a href="tabnine.com/semantic">tabnine.com/semantic</a>上说明TabNine与语言无关，它需要依赖其他语言服务器（提供语言服务通信Language Server Protocol，LSP）来提供semantic completion：</p><pre><code class="hljs plain">TabNine is language agnostic, so it relies on other software to provide semantic completions. Any server which implements the Language Server Protocol can be used as a source of semantic completions.</code></pre><p>于是为了能用上semantic completion，需要先安装配置C++的语言服务器，cquery。</p><h2 id="第五个问题-安装配置cquery"><a href="#第五个问题-安装配置cquery" class="headerlink" title="第五个问题 - 安装配置cquery"></a>第五个问题 - 安装配置cquery</h2><h4 id="LSP是什么"><a href="#LSP是什么" class="headerlink" title="LSP是什么"></a>LSP是什么</h4><p>这里有着较为详细的解释：<a href="https://zhuanlan.zhihu.com/p/36413094" target="_blank" rel="noopener">代码编辑器系列 #1 架构与解耦</a>。简单的说，代码编辑器（Vim类）把代码编辑与代码分析解耦，编辑器只负责编辑，而代码分析交给另一个程序，这种策略所采用的协议叫做Language Server Protocol（LSP）。LSP Server并不是http Server 那样的常驻后台服务，而是一个个命令行程序，由编辑器（也就是客户端）启动，通过管道发送 JSON RPC 命令同 LSP Server 交流，退出编辑器，LSP 服务端也就关闭了。</p><h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><p>我大致按照参考了这个：<a href="https://zhuanlan.zhihu.com/p/37290578" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：LSP 篇</a></p><p>首先安装LSP服务端cquery，这个很简单，brew一下就好了。</p><pre><code class="hljs bash">brew install cquery</code></pre><p>其次要安装LanguageClient-neovim，LanguageClient-neovim是Vim用于支持LSP的插件。</p><pre><code class="hljs bash">Plug <span class="hljs-string">'autozimu/LanguageClient-neovim'</span>, &#123;<span class="hljs-string">'branch'</span>: <span class="hljs-string">'next'</span>, <span class="hljs-string">'do'</span>: <span class="hljs-string">'bash install.sh'</span>&#125;</code></pre><p>按照上面那篇知乎专栏进行配置：</p><pre><code class="hljs bash"><span class="hljs-string">" LSP</span><span class="hljs-string">let g:LanguageClient_loadSettings = 1</span><span class="hljs-string">let g:LanguageClient_diagnosticsEnable = 0</span><span class="hljs-string">let g:LanguageClient_settingsPath = expand('/Users/barriery/.vim/languageclient.json')</span><span class="hljs-string">let g:LanguageClient_selectionUI = 'quickfix'</span><span class="hljs-string">let g:LanguageClient_diagnosticsList = v:null</span><span class="hljs-string">let g:LanguageClient_hoverPreview = 'Never'</span><span class="hljs-string">let g:LanguageClient_serverCommands = &#123;&#125;</span><span class="hljs-string">let g:LanguageClient_serverCommands.c = ['cquery']</span><span class="hljs-string">let g:LanguageClient_serverCommands.cpp = ['cquery']</span><span class="hljs-string">noremap &lt;leader&gt;rd :call LanguageClient#textDocument_definition()&lt;cr&gt;</span><span class="hljs-string">noremap &lt;leader&gt;rr :call LanguageClient#textDocument_references()&lt;cr&gt;</span><span class="hljs-string">noremap &lt;leader&gt;rv :call LanguageClient#textDocument_hover()&lt;cr&gt;</span></code></pre><p>配置中涉及到一个额外的 languageclient.json 文件，内容就是指定下 cache 目录：</p><pre><code class="hljs bash">&#123;    <span class="hljs-string">"initializationOptions"</span>: &#123;<span class="hljs-string">"cacheDirectory"</span>: <span class="hljs-string">"/tmp/.cquery_cache"</span>&#125;&#125;</code></pre><p>最后打开TabNine的配置文件（&lt;TabNine::config_dir&gt;/ExampleTabNine.toml，可以新建一个toml文件对默认配置进行覆盖），找到c++语言服务器配置进行修改：</p><pre><code class="hljs bash">[language.cpp]<span class="hljs-built_in">command</span> = <span class="hljs-string">"/usr/local/bin/cquery"</span>args = [<span class="hljs-string">"--init=&#123;\"cacheDirectory\": \"/tmp/.cquery_cache\"&#125;"</span>]</code></pre><p>现在就可以愉快的用TabNine辣（马耶炒鸡好用）：</p><p><img src="/img/post/Deep-Tabnine.gif" srcset="/img/loading.gif" alt="Deep TabNine演示"></p><p>还有一个问题是，本地版模型需要的算力比较大，可以看到写个最简单的程序左上角CPU就飙到80+%，风扇呼呼得响。心疼电脑的话还是用云端模型叭（哭唧唧）：</p><p><img src="/img/post/tabnine-cloud.jpg" srcset="/img/loading.gif" alt="TabNine Cloud"></p><h2 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h2><ol><li><p>我在TabNine官网上发现了这句话：</p><pre><code class="hljs plain">The Vim client for TabNine is based on YouCompleteMe.</code></pre><p>而问题二与问题三是YouCompleteMe引起的。</p></li><li><p>可以安装<code>Neofetch</code>，可以在终端输出系统信息，利于在网上寻求帮助：</p></li></ol><pre><code class="hljs bash">» neofetch                    <span class="hljs-string">'c.          barriery@barrierys-MBP</span><span class="hljs-string">                 ,xNMM.          ----------------------</span><span class="hljs-string">               .OMMMMo           OS: macOS Mojave 10.14.5 18F203 x86_64</span><span class="hljs-string">               OMMM0,            Host: MacBookPro15,1</span><span class="hljs-string">     .;loddo:'</span> loolloddol;.      Kernel: 18.6.0   cKMMMMMMMMMMNWMMMMMMMMMM0:    Uptime: 1 day, 9 hours, 34 mins .KMMMMMMMMMMMMMMMMMMMMMMMWd.    Packages: 48 (brew) XMMMMMMMMMMMMMMMMMMMMMMMX.      Shell: zsh 5.3;MMMMMMMMMMMMMMMMMMMMMMMM:       Resolution: 1680x1050:MMMMMMMMMMMMMMMMMMMMMMMM:       DE: Aqua.MMMMMMMMMMMMMMMMMMMMMMMMX.      WM: Quartz Compositor kMMMMMMMMMMMMMMMMMMMMMMMMWd.    WM Theme: Blue (Dark) .XMMMMMMMMMMMMMMMMMMMMMMMMMMk   Terminal: iTerm2  .XMMMMMMMMMMMMMMMMMMMMMMMMK.   Terminal Font: Monaco 13    kMMMMMMMMMMMMMMMMMMMMMMd     CPU: Intel i7-8750H (12) @ 2.20GHz     ;KMMMMMMMWXXWMMMMMMMk.      GPU: Intel UHD Graphics 630, Radeon Pro 555X       .cooc,.    .,coo:.        Memory: 9582MiB / 16384MiB</code></pre>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unix</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAC Installation Guide</title>
    <link href="/2019/08/09/Mac%20Installation%20Guide/"/>
    <url>/2019/08/09/Mac%20Installation%20Guide/</url>
    
    <content type="html"><![CDATA[<p>前些阵子爸妈去了趟香港顺便给我换了台电脑，怀着开心愉悦（并不）的心情开始了装机之旅。</p><a id="more"></a><h1 id="基础部件"><a href="#基础部件" class="headerlink" title="基础部件"></a>基础部件</h1><blockquote><p>免费</p></blockquote><ul><li>网络代理：<a href="https://github.com/shadowsocks/shadowsocks-iOS/releases" target="_blank" rel="noopener">Shadowsocks</a> 或 <a href="https://github.com/yichengchen/clashX" target="_blank" rel="noopener">ClashX</a></li><li>文本编辑器：<a href="http://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a></li><li>思维导图：<a href="https://www.xmind.cn" target="_blank" rel="noopener">xmind</a>（免费版导出带水印）</li><li>压缩软件：<a href="https://ezip.awehunt.com" target="_blank" rel="noopener">eZip</a></li><li>邮件管理：<a href="http://mail.163.com/dashi/" target="_blank" rel="noopener">网易邮件大师</a>（自带Mail.app叉掉后不能提醒，而网易邮件大师可以在不完全关闭情况下提醒。缺点是可能会有一些广告，暂时只发现在新添加邮箱时会发送一封广告）</li><li>最佳视频播放器：<a href="https://iina.io" target="_blank" rel="noopener">IINA</a></li><li>TODOList：滴答清单</li><li>检查英文文章的拼写、句式、结构：1Checker</li></ul><blockquote><p>一次性付费</p></blockquote><ul><li>虚拟机：<a href="https://bbs.feng.com/read-htm-tid-12404529.html" target="_blank" rel="noopener">Parallels Desktop</a>（相比于VM有融合模式，相当于在Mac上直接用Win程序；兼容性完爆VBox）</li><li><a href="https://www.cnblogs.com/xiaokang01/p/10042181.html" target="_blank" rel="noopener">Office组件</a></li></ul><blockquote><p>订阅式付费</p></blockquote><ul><li>地表最强密码管理软件：1Password</li></ul><br /><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><blockquote><p>免费</p></blockquote><ul><li>Wechat免密登陆&amp;防撤回：WeChatTweak-macOS</li><li>非敏感图片上传最佳图床：iPic（免费图床是匿名微博）</li><li>卸载工具：AppCleaner（不能保证完全，单比直接拖回收站好很多）</li><li>局域网内终端间通信：Dukto（Mac与Win传输文件等）</li><li>壁纸软件：pap.er</li><li>下载程序：Aria2GUI（<a href="https://www.baiduwp.com" target="_blank" rel="noopener">百度云链接解析网站</a>）</li><li>查看电池循环次数：Battery Health2</li><li>避免合盖睡眠：InsomniaX</li><li>gif录制工具：GIPHY CAPTURE</li><li>BT下载工具：Folx（app内搜索种子下载）</li><li>日历快速查看工具：PixelScheduler（在系统自带日历应用或其它第三方日历应用的基础上，展现在屏幕的边缘）</li><li>根据发生的事件自动执行命令/脚本：ControlPlane</li><li>正版 app 的序列号收集器：KCNScrew</li><li>屏幕录像的最佳 app：LICEcap</li><li>远程桌面：Microsoft Remote Desktop</li><li>远程控制：TeamViewer（个人免费）</li></ul><blockquote><p>一次性付费</p></blockquote><ul><li>增强版Spotlight：Alfred</li><li>自动填充：CodeExpander（强烈推荐）</li></ul><br /><h1 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h1><blockquote><p>免费</p></blockquote><ul><li>Vim插件（<a href="https://github.com/junegunn/vim-plug）" target="_blank" rel="noopener">https://github.com/junegunn/vim-plug）</a><ul><li>C++语法高亮: octol/vim-cpp-enhanced-highlight</li><li>markdown即时渲染: godlygeek/tabular, plasticboy/vim-markdown, suan/vim-instant-markdown</li><li>批量注释: scrooloose/nerdcommenter</li><li>AI自动补全: zxqfl/tabnine-vim（sublime上也可以来一个）</li><li>静态语法与代码风格检查: dense-analysis/ale（scrooloose/syntastic与YouCompleteMe默认冲突，需要设置let g:ycm_show_diagnostics_ui = 0，同时syntastic过于笨重；ale的语法检查是异步执行的，基本不会出现卡顿的情况，且默认会使用所有检查工具并发地进行检查）</li></ul></li><li>IDE：xcode</li><li>终端：<a href="https://zhuanlan.zhihu.com/p/26010783" target="_blank" rel="noopener">iTerm + oh my zsh</a>（iTerm可以用F12快速切换，oh my zsh可以智能扩展文件名以及配置好看的界面）</li><li>命令行工具<ul><li>Python版本管理：pyenv（舒服地切换py版本）</li><li>终端窗口复用：tmux</li><li>打印系统软硬件信息：Neofetch</li><li>终端路径跳转：autojump</li></ul></li><li>富媒体内容下载：<a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">You-Get</a></li><li>离线API文档：<a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a></li><li>Latex：<a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTex</a>（可以用自带的TexShop或者参照<a href="https://zhuanlan.zhihu.com/p/46942059" target="_blank" rel="noopener">如何用 macOS 优雅的敲 LaTeX</a>配合sublime使用）</li><li>Markdown：<a href="https://www.typora.io" target="_blank" rel="noopener">Typora</a></li><li>捕获流量：Wireshark</li><li>图片压缩工具：Guetzli</li></ul><br /><h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><pre><code class="hljs bash"><span class="hljs-comment"># ==================== 垃圾箱 ======================</span>TERMINAL_TRASH=<span class="hljs-string">"/Users/barriery/.Trash.terminal"</span><span class="hljs-built_in">alias</span> rm=rmtrash<span class="hljs-built_in">alias</span> rls=<span class="hljs-string">'ls $&#123;TERMINAL_TRASH&#125;'</span><span class="hljs-built_in">alias</span> rll=<span class="hljs-string">'ll $&#123;TERMINAL_TRASH&#125;'</span><span class="hljs-built_in">alias</span> rrm=<span class="hljs-string">'/bin/rm -rf'</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">rmtrash</span></span>()&#123;  mv -i <span class="hljs-variable">$@</span> <span class="hljs-variable">$&#123;TERMINAL_TRASH&#125;</span>/&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">recover</span></span>()&#123;  mv -i <span class="hljs-variable">$&#123;TERMINAL_TRASH&#125;</span>/<span class="hljs-variable">$@</span> ./&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">cleartrash</span></span>()&#123;  /bin/rm -rf <span class="hljs-variable">$&#123;TERMINAL_TRASH&#125;</span>/*&#125;<span class="hljs-comment"># ===================== util =======================</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">setcolor</span></span>() &#123;    <span class="hljs-built_in">export</span> BLACK=<span class="hljs-string">'\033[30m'</span>    <span class="hljs-built_in">export</span> RED=<span class="hljs-string">'\033[0;31m'</span>    <span class="hljs-built_in">export</span> GREEN=<span class="hljs-string">'\033[32m'</span>    <span class="hljs-built_in">export</span> YELLOW=<span class="hljs-string">'\033[33m'</span>    <span class="hljs-built_in">export</span> BLUE=<span class="hljs-string">'\033[0;34m'</span>    <span class="hljs-built_in">export</span> PURPLE=<span class="hljs-string">'\033[35m'</span>    <span class="hljs-built_in">export</span> CYAN=<span class="hljs-string">'\033[36m'</span>    <span class="hljs-built_in">export</span> WHITE=<span class="hljs-string">'\033[37m'</span>    <span class="hljs-built_in">export</span> BOLD=<span class="hljs-string">'\033[1m'</span>    <span class="hljs-built_in">export</span> NONE=<span class="hljs-string">'\033[0m'</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">unsetcolor</span></span>() &#123;    <span class="hljs-built_in">unset</span> BLACK    <span class="hljs-built_in">unset</span> RED    <span class="hljs-built_in">unset</span> GREEN    <span class="hljs-built_in">unset</span> YELLOW    <span class="hljs-built_in">unset</span> BLUE    <span class="hljs-built_in">unset</span> PURPLE    <span class="hljs-built_in">unset</span> CYAN    <span class="hljs-built_in">unset</span> WHITE    <span class="hljs-built_in">unset</span> BOLD    <span class="hljs-built_in">unset</span> NONE&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">plog</span></span>()&#123;    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 3 ]; <span class="hljs-keyword">then</span>        plog ERROR red <span class="hljs-string">"Usage: plog LEVEL COLOR MESSAGE"</span>        <span class="hljs-built_in">return</span> 1    <span class="hljs-keyword">fi</span>    level=[<span class="hljs-variable">$1</span>]    color=<span class="hljs-variable">$2</span>    message=<span class="hljs-variable">$3</span>    timestamp=[$(date <span class="hljs-string">"+%Y-%m-%d %H:%M:%S"</span>)]    setcolor    <span class="hljs-keyword">case</span> <span class="hljs-variable">$&#123;color&#125;</span> <span class="hljs-keyword">in</span>        black|k|黑|30)            level=<span class="hljs-variable">$&#123;BLACK&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        red|r|红|31)            level=<span class="hljs-variable">$&#123;RED&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        green|g|绿|32)            level=<span class="hljs-variable">$&#123;GREEN&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        yellow|y|黄|33)            level=<span class="hljs-variable">$&#123;YELLOW&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        blue|b|蓝|34)            level=<span class="hljs-variable">$&#123;BLUE&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        purple|p|紫|35)            level=<span class="hljs-variable">$&#123;PURPLE&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        cyan|c|青|36)            level=<span class="hljs-variable">$&#123;CYAN&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        white|w|白|37)            level=<span class="hljs-variable">$&#123;WHITE&#125;</span><span class="hljs-variable">$&#123;level&#125;</span><span class="hljs-variable">$&#123;NONE&#125;</span>;;        *)            plog ERROR red <span class="hljs-string">"Unknown param color <span class="hljs-variable">$&#123;color&#125;</span>"</span>            unsetcolor            <span class="hljs-built_in">return</span> 1;;    <span class="hljs-keyword">esac</span>    unsetcolor    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;timestamp&#125;</span> <span class="hljs-variable">$&#123;level&#125;</span> <span class="hljs-variable">$&#123;message&#125;</span>&#125;<span class="hljs-comment"># mac 下的命令完成通知</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">notify</span></span>()&#123;  start_time=`date +%s`;  cmd=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$@</span>`;  <span class="hljs-built_in">eval</span> <span class="hljs-variable">$@</span>;  end_time=`date +%s`  timer_time=$((end_time-start_time))  unit=<span class="hljs-string">"s"</span>  <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$timer_time</span> -gt 60 ]]; <span class="hljs-keyword">then</span>      unit=<span class="hljs-string">"m"</span>      timer_time=`<span class="hljs-built_in">echo</span> $((<span class="hljs-variable">$timer_time</span>/60.0))|awk <span class="hljs-string">'&#123;printf("%.2f", $1)&#125;'</span>`  <span class="hljs-keyword">fi</span>  terminal-notifier -title <span class="hljs-string">'Notifier'</span> -message <span class="hljs-string">'command was finished in '</span><span class="hljs-variable">$&#123;timer_time&#125;</span><span class="hljs-variable">$&#123;unit&#125;</span><span class="hljs-string">'</span><span class="hljs-string">'</span><span class="hljs-variable">$&#123;cmd&#125;</span> -sound default -execute <span class="hljs-string">"open /Applications/iTerm.app"</span>;&#125;<span class="hljs-comment"># ===================== 代理 =======================</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">setproxy</span></span>()&#123;  <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">"socks5://0.0.0.0:1086"</span>;  <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">"socks5://0.0.0.0:1086"</span>;  <span class="hljs-comment"># export ALL_PROXY="socks5://127.0.0.1:1086";</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">unsetproxy</span></span>()&#123;  <span class="hljs-built_in">unset</span> http_proxy  <span class="hljs-built_in">unset</span> https_proxy  <span class="hljs-built_in">unset</span> ALL_PROXY&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">proxy</span></span>()&#123;  setproxy  <span class="hljs-variable">$@</span>;  unsetproxy&#125;setproxy <span class="hljs-comment"># 默认开启</span><span class="hljs-comment"># =================== ssh/frp =====================</span><span class="hljs-comment"># frp</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">frp</span></span>()&#123;    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 4 ]; <span class="hljs-keyword">then</span>        plog ERROR red <span class="hljs-string">"Usage: frp SERVER_IP CLIENT_IP PORT USR"</span>        <span class="hljs-built_in">return</span> 1    <span class="hljs-keyword">fi</span>    server_ip=<span class="hljs-variable">$1</span>    client_ip=<span class="hljs-variable">$2</span>    port=<span class="hljs-variable">$3</span>    usr=<span class="hljs-variable">$4</span>    gtimeout 1 nc -z -n <span class="hljs-variable">$&#123;client_ip&#125;</span> 22 &amp;&gt;/dev/null    <span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span>        plog INFO green <span class="hljs-string">"SSH by FRP"</span>        ssh -p <span class="hljs-variable">$&#123;port&#125;</span> <span class="hljs-variable">$&#123;usr&#125;</span>@<span class="hljs-variable">$&#123;server_ip&#125;</span>    <span class="hljs-keyword">else</span>        ssh <span class="hljs-variable">$&#123;usr&#125;</span>@<span class="hljs-variable">$&#123;client_ip&#125;</span>    <span class="hljs-keyword">fi</span>&#125;<span class="hljs-comment"># ================== c/c++ env =====================</span><span class="hljs-built_in">alias</span> g++=<span class="hljs-string">'echo "\033[32musing Homebrew GCC 9.1.0 \033[0m"; /usr/local/Cellar/gcc/9.2.0_3/bin/g++-9'</span><span class="hljs-comment"># alias gcc='echo "\033[32musing Homebrew GCC 9.1.0 \033[0m";/usr/local/Cellar/gcc/9.2.0_3/bin/gcc-9'</span><span class="hljs-comment"># boost</span><span class="hljs-built_in">export</span> BOOST_ROOT=/Users/barriery/Helper/third_party/boost/<span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-string">"<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/Users/barriery/Helper/third_party/boost/lib"</span><span class="hljs-comment"># ================== python env ====================</span><span class="hljs-comment"># pyenv</span><span class="hljs-built_in">alias</span> brew=<span class="hljs-string">'env PATH=$&#123;PATH//$(pyenv root)\/shims:/&#125; brew'</span><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(pyenv init -)</span>"</span><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(pyenv virtualenv-init -)</span>"</span><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(pipenv --completion)</span>"</span><span class="hljs-comment"># =================== ruby env =====================</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">"/usr/local/opt/ruby/bin:<span class="hljs-variable">$PATH</span>"</span><span class="hljs-comment"># for compile</span><span class="hljs-comment"># export LDFLAGS="-L/usr/local/opt/ruby/lib"</span><span class="hljs-comment"># export CPPFLAGS="-I/usr/local/opt/ruby/include"</span><span class="hljs-comment"># ================== other env =====================</span><span class="hljs-comment"># autojump</span>[ -f /usr/<span class="hljs-built_in">local</span>/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/<span class="hljs-built_in">local</span>/etc/profile.d/autojump.sh<span class="hljs-comment"># brew mirror</span><span class="hljs-built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles<span class="hljs-built_in">export</span> PATH=<span class="hljs-string">"/usr/local/opt/gnu-getopt/bin:<span class="hljs-variable">$PATH</span>"</span></code></pre><br /><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><pre><code class="hljs bash"><span class="hljs-built_in">let</span> mapleader=<span class="hljs-string">";"</span> <span class="hljs-string">" 定义快捷键的前缀，即&lt;Leader&gt;</span><span class="hljs-string"></span><span class="hljs-string">"</span> 用~/clipsongzboard作为剪切板实现复制粘贴到系统剪切板map &lt;C-c&gt; y:e ~/clipsongzboard&lt;CR&gt;P:w&lt;cr&gt;:w !pbcopy&lt;CR&gt;&lt;cr&gt;:1,<span class="hljs-variable">$d</span>&lt;cr&gt;:w&lt;cr&gt;&lt;C-o&gt;&lt;C-o&gt;<span class="hljs-string">" 让光标停留在上一次打开的行</span><span class="hljs-string">if has("</span>autocmd<span class="hljs-string">")</span><span class="hljs-string">  au BufReadPost * if line("</span><span class="hljs-string">'\"") &gt; 1 &amp;&amp; line("'</span>\"<span class="hljs-string">") &lt;= line("</span>$<span class="hljs-string">") | exe "</span>normal! g<span class="hljs-string">'\"" | endif</span><span class="hljs-string">endif</span><span class="hljs-string"></span><span class="hljs-string">" 移除 Windows 文件结尾的 `^M`</span><span class="hljs-string">noremap &lt;leader&gt;m :%s/&lt;C-V&gt;&lt;C-M&gt;//ge&lt;CR&gt;</span><span class="hljs-string"></span><span class="hljs-string">" 在断行、合并(join)行时，针对多字节字符（比如中文）的优化处理</span><span class="hljs-string">set formatoptions+=mM</span><span class="hljs-string"></span><span class="hljs-string">" 高亮不想要的空格（行尾）</span><span class="hljs-string">" See [http://vim.wikia.com/wiki/Highlight_unwanted_spaces]</span><span class="hljs-string">" - highlight trailing whitespace in red</span><span class="hljs-string">" - have this highlighting not appear whilst you are typing in insert mode</span><span class="hljs-string">" - have the highlighting of whitespace apply when you open new buffers</span><span class="hljs-string">highlight ExtraWhitespace ctermbg=red guibg=red</span><span class="hljs-string">match ExtraWhitespace /\s\+$/</span><span class="hljs-string">autocmd BufWinEnter * match ExtraWhitespace /\s\+$/</span><span class="hljs-string">autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@&lt;!$/</span><span class="hljs-string">autocmd InsertLeave * match ExtraWhitespace /\s\+$/</span><span class="hljs-string">autocmd BufWinLeave * call clearmatches() " for performance</span><span class="hljs-string"></span><span class="hljs-string">colorscheme default " 设置颜色主题</span><span class="hljs-string">filetype on " 检测文件类型</span><span class="hljs-string">filetype plugin on " 根据侦测到的不同类型加载对应的插件</span><span class="hljs-string">filetype indent on " 自适应不同语言的智能缩进</span><span class="hljs-string">set backspace=2</span><span class="hljs-string">set tabstop=4 " TAB宽4个空格</span><span class="hljs-string">set expandtab " 将TAB转化成space</span><span class="hljs-string">set number</span><span class="hljs-string">set encoding=utf-8 " 文件默认编码</span><span class="hljs-string">set softtabstop=4 " 让 vim 把连续数量的空格视为一个制表符</span><span class="hljs-string">syntax on " 语法高亮</span><span class="hljs-string">set hlsearch " 高亮显示搜索结果</span><span class="hljs-string"></span><span class="hljs-string">" 设置vim-plug管理的插件安装位置</span><span class="hljs-string">call plug#begin('</span>~/.vim/bundle<span class="hljs-string">')</span><span class="hljs-string">" 下面就是一些插件的例.</span><span class="hljs-string">" 插件必须装在  plug#begin/end这两行命令之间.</span><span class="hljs-string">" 对于在github上面的插件, 我们可以用以下方法添加, 只需要添加`用户名/插件名称`就行</span><span class="hljs-string">"Plug '</span>tpope/vim-fugitive<span class="hljs-string">'</span><span class="hljs-string">Plug '</span>octol/vim-cpp-enhanced-highlight<span class="hljs-string">'</span><span class="hljs-string">Plug '</span>scrooloose/nerdtree<span class="hljs-string">' " 文件树</span><span class="hljs-string">Plug '</span>godlygeek/tabular<span class="hljs-string">' " before vim-markdown</span><span class="hljs-string">Plug '</span>plasticboy/vim-markdown<span class="hljs-string">'</span><span class="hljs-string">Plug '</span>suan/vim-instant-markdown<span class="hljs-string">'</span><span class="hljs-string">Plug '</span>scrooloose/nerdcommenter<span class="hljs-string">' " 批量注释</span><span class="hljs-string">Plug '</span>zxqfl/tabnine-vim<span class="hljs-string">' " AI自动补全</span><span class="hljs-string">Plug '</span>luochen1990/rainbow<span class="hljs-string">' " 嵌套括号不同染色</span><span class="hljs-string">Plug '</span>autozimu/LanguageClient-neovim<span class="hljs-string">', &#123;'</span>branch<span class="hljs-string">': '</span>next<span class="hljs-string">', '</span><span class="hljs-keyword">do</span><span class="hljs-string">': '</span>bash install.sh<span class="hljs-string">'&#125; " LSP</span><span class="hljs-string">Plug '</span>dense-analysis/ale<span class="hljs-string">' " 语法检查</span><span class="hljs-string">" 对于在http://vim-scripts.org/vim/scripts.html下的插件, 我们直接添加插件名称就行</span><span class="hljs-string">" Plug '</span>L9<span class="hljs-string">'</span><span class="hljs-string">" 对于不是github也不是vim-scripts的插件, 则需要用完整路径</span><span class="hljs-string">"Plug '</span>git://git.wincent.com/<span class="hljs-built_in">command</span>-t.git<span class="hljs-string">'</span><span class="hljs-string">" 本地或者你自己的插件</span><span class="hljs-string">"Plug '</span>file:///home/gmarik/path/to/plugin<span class="hljs-string">'</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">" 所有的插件都需要安装在这条命令之前</span><span class="hljs-string">call plug#end()</span><span class="hljs-string"></span><span class="hljs-string">"ale</span><span class="hljs-string">"始终开启标志列</span><span class="hljs-string">let g:ale_sign_column_always = 1</span><span class="hljs-string">let g:ale_set_highlights = 0</span><span class="hljs-string">"自定义error和warning图标</span><span class="hljs-string">let g:ale_sign_error = '</span>✗<span class="hljs-string">'</span><span class="hljs-string">let g:ale_sign_warning = '</span>⚡<span class="hljs-string">'</span><span class="hljs-string">"在vim自带的状态栏中整合ale</span><span class="hljs-string">let g:ale_statusline_format = ['</span>✗ %d<span class="hljs-string">', '</span>⚡ %d<span class="hljs-string">', '</span>✔ OK<span class="hljs-string">']</span><span class="hljs-string">"显示Linter名称,出错或警告等相关信息</span><span class="hljs-string">let g:ale_echo_msg_error_str = '</span>E<span class="hljs-string">'</span><span class="hljs-string">let g:ale_echo_msg_warning_str = '</span>W<span class="hljs-string">'</span><span class="hljs-string">let g:ale_echo_msg_format = '</span>[%linter%] %s [%severity%]<span class="hljs-string">'</span><span class="hljs-string">"普通模式下，sp前往上一个错误或警告，sn前往下一个错误或警告</span><span class="hljs-string">nmap sp &lt;Plug&gt;(ale_previous_wrap)</span><span class="hljs-string">nmap sn &lt;Plug&gt;(ale_next_wrap)</span><span class="hljs-string">"&lt;Leader&gt;s触发/关闭语法检查</span><span class="hljs-string">nmap &lt;Leader&gt;s :ALEToggle&lt;CR&gt;</span><span class="hljs-string">"&lt;Leader&gt;d查看错误或警告的详细信息</span><span class="hljs-string">nmap &lt;Leader&gt;d :ALEDetail&lt;CR&gt;</span><span class="hljs-string"></span><span class="hljs-string">" LSP</span><span class="hljs-string">let g:LanguageClient_loadSettings = 1</span><span class="hljs-string">let g:LanguageClient_diagnosticsEnable = 0</span><span class="hljs-string">let g:LanguageClient_settingsPath = expand('</span>/Users/barriery/.vim/languageclient.json<span class="hljs-string">')</span><span class="hljs-string">let g:LanguageClient_selectionUI = '</span>quickfix<span class="hljs-string">'</span><span class="hljs-string">let g:LanguageClient_diagnosticsList = v:null</span><span class="hljs-string">let g:LanguageClient_hoverPreview = '</span>Never<span class="hljs-string">'</span><span class="hljs-string">let g:LanguageClient_serverCommands = &#123;&#125;</span><span class="hljs-string">let g:LanguageClient_serverCommands.c = ['</span>cquery<span class="hljs-string">']</span><span class="hljs-string">let g:LanguageClient_serverCommands.cpp = ['</span>cquery<span class="hljs-string">']</span><span class="hljs-string">noremap &lt;leader&gt;rd :call LanguageClient#textDocument_definition()&lt;cr&gt;</span><span class="hljs-string">noremap &lt;leader&gt;rr :call LanguageClient#textDocument_references()&lt;cr&gt;</span><span class="hljs-string">noremap &lt;leader&gt;rv :call LanguageClient#textDocument_hover()&lt;cr&gt;</span><span class="hljs-string"></span><span class="hljs-string">" rainbow</span><span class="hljs-string">let g:rainbow_active = 1</span><span class="hljs-string"></span><span class="hljs-string">" NERD commenter</span><span class="hljs-string">let g:NERDSpaceDelims=1 " 注释的时候自动加个空格,</span><span class="hljs-string"></span><span class="hljs-string">" vim</span><span class="hljs-string">autocmd BufNewFile,BufRead *.md set nofoldenable " 取消自动折叠</span><span class="hljs-string"></span><span class="hljs-string">" NERD tree</span><span class="hljs-string">let NERDChristmasTree=0</span><span class="hljs-string">let NERDTreeWinSize=35</span><span class="hljs-string">let NERDTreeChDirMode=2</span><span class="hljs-string">let NERDTreeIgnore=['</span>\~$<span class="hljs-string">', '</span>\.pyc$<span class="hljs-string">', '</span>\.swp$<span class="hljs-string">']</span><span class="hljs-string">let NERDTreeShowBookmarks=1</span><span class="hljs-string">let NERDTreeWinPos="left"</span><span class="hljs-string">let NERDTreeShowHidden=1</span><span class="hljs-string">" Automatically open a NERDTree if no files where specified</span><span class="hljs-string">autocmd vimenter * if !argc() | NERDTree | endif</span><span class="hljs-string">" Close vim if the only window left open is a NERDTree</span><span class="hljs-string">autocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTreeType") &amp;&amp; b:NERDTreeType == "primary") | q | endif</span><span class="hljs-string">" Open a NERDTree</span><span class="hljs-string">nmap &lt;F5&gt; :NERDTreeToggle&lt;cr&gt;</span><span class="hljs-string"></span><span class="hljs-string">function HeaderPython()</span><span class="hljs-string">        call setline(1, "#-*- coding:utf8 -*-")</span><span class="hljs-string">        call append(1, "# Powered by barriery")</span><span class="hljs-string">        call append(2, "# at ".strftime('</span>%Y-%m-%d %T<span class="hljs-string">', localtime()))</span><span class="hljs-string">        call append(3, "# ----------------------")</span><span class="hljs-string">endf</span><span class="hljs-string">function HeaderCPP()</span><span class="hljs-string">        call setline(1, "// Powered by barriery")</span><span class="hljs-string">        call append(1, "// at ".strftime('</span>%Y-%m-%d %T<span class="hljs-string">', localtime()))</span><span class="hljs-string">        call append(2, "// ----------------------")</span><span class="hljs-string">endf</span><span class="hljs-string">autocmd bufnewfile *.py call HeaderPython()</span><span class="hljs-string">autocmd bufnewfile *.c call HeaderCPP()</span><span class="hljs-string">autocmd bufnewfile *.cc call HeaderCPP()</span><span class="hljs-string">autocmd bufnewfile *.cpp call HeaderCPP()</span><span class="hljs-string"></span><span class="hljs-string">autocmd BufWritePost $MYVIMRC source $MYVIMR " 让配置变更立即生效</span></code></pre><br /><h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><p>上述仅个人使用Mac时所用软件。</p><p>mac各类开发的安装向导：<a href="https://github.com/sb2nov/mac-setup" target="_blank" rel="noopener">https://github.com/sb2nov/mac-setup</a></p><p>参考<a href="https://www.tr0y.wang/2018/10/04/initenv/#Mac?nsukey=%2BoNqBhccCqXueKYbsZLNgnW%2F%2B9FhHMCo%2FBi3plEolHk16YMgLnb9vGPy1g%2FUkVDdHpjRzEKWHqQF6K5XFSy3HxalZQDJAXdl2jDZa97D3zeUjOYLgw2o8jhhN%2BE%2BUX%2FTdLYD8423CX%2FtK1tdZvqz9QuLM8aeIQWam1EtE02c3sF6RvldfqsjS0T5NaKMOd1uAVOo7ZTZHe%2B%2FEvzjGxqUow%3D%3D" target="_blank" rel="noopener">电脑配置环境记录</a>。</p>]]></content>
    
    
    <categories>
      
      <category>macOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>barriery的佛系保研</title>
    <link href="/2018/10/01/barriery%E7%9A%84%E4%BD%9B%E7%B3%BB%E4%BF%9D%E7%A0%94/"/>
    <url>/2018/10/01/barriery%E7%9A%84%E4%BD%9B%E7%B3%BB%E4%BF%9D%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<p>看到ckj写了个<a href="https://linux.xidian.edu.cn/yan/d/5-ckj" target="_blank" rel="noopener">ckj的随缘保研</a>，我也记录一哈</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>年级：2015级</li><li>专业：信息安全</li><li>班级：实验班</li><li>均分：87.5</li><li>裸分排名：24/199</li><li>综合排名：3/199</li><li>竞赛经历：ACM/ICPC 亚洲区域赛 金奖，全国密码学技术竞赛 三等奖</li><li>科研经历：无</li><li>项目经历：无</li><li>实习经历：百度NLP语义计算组 2018.04 - 至今（2018.10）</li></ul><h2 id="最终录取结果"><a href="#最终录取结果" class="headerlink" title="最终录取结果"></a>最终录取结果</h2><blockquote><p>队友A 中山大学、队友B 北京大学</p></blockquote><p>北京航空航天大学（计算机学院 软件工程） 学硕</p><h2 id="六月份-夏令营与联系老师"><a href="#六月份-夏令营与联系老师" class="headerlink" title="六月份 - 夏令营与联系老师"></a>六月份 - 夏令营与联系老师</h2><p>由于当时在百度实习不方便回校准备材料，就报了不需要材料的南京大学，但没有拿到入营资格。后来期末考试周与很多学校夏令营冲突（因为基本一学期溜出去实习，怕挂科），最后没有参加夏令营。现在想想如果当初干满三个月就离职可能结果会有些不同吧（笑）</p><p>我开始联系老师已经是比较迟的了（大概在六月末，很多夏令营都已经结束了），在同事的建议下给一个北大做NLP的老师发了邮件但没收到回信。其实在这个时期我不是很清楚自己想要读什么方向，因为本科是信息安全专业而实习是算法岗，所以想找一个安全与算法相结合的方向，之前暑假参加过武汉大学的一个安全方面的暑期学校，得知信息内容安全比较match，就邮件找了武汉大学的任老师。任老师人很好，针对我的情况给我推荐了清华的黄老师（也是做信息内容安全方向的，主要是NLP的情感分析），我与黄老师取得了联系，黄老师表示欢迎，说到时候联系。之后想着再找其他老师不太好，就没继续找了（之后和学长同事们聊起，觉得这是比较大的失误，在不确定的情况下还是要多找几个老师比较好）。</p><h2 id="九月份-预推免"><a href="#九月份-预推免" class="headerlink" title="九月份 - 预推免"></a>九月份 - 预推免</h2><p>我们院综合成绩出的很迟，我去找各种学校用的都是前五学期裸分成绩，比较低。</p><h4 id="清华大学-8-26-9-12"><a href="#清华大学-8-26-9-12" class="headerlink" title="清华大学 - 8.26~9.12"></a>清华大学 - 8.26~9.12</h4><p>大概九月初需要提交材料，我在八月末的时候再次联系了黄老师（中间近三个月没有说过一句话，后来实习时的mentor分析：”你不找老师，他以为你找其他老师了“），最终没让我进复试。</p><h4 id="中科院-9-6"><a href="#中科院-9-6" class="headerlink" title="中科院 - 9.6"></a>中科院 - 9.6</h4><p>九月初开学，向公司里请了一周假回去搞报名材料。弄完清华的材料已经是九月六号了（比较拖拉），这个时候中科院已经截止报名了。</p><h4 id="浙江大学-9-6-9-15"><a href="#浙江大学-9-6-9-15" class="headerlink" title="浙江大学 - 9.6~9.15"></a>浙江大学 - 9.6~9.15</h4><p>错过中科院后，我查了下浙大（虽然家在浙江，但由于各种原因想在北京读书，所以之前没怎么考虑浙大），报了计算机学院。得知清华凉了后，问了下张宁老师武汉大学的任老师怎么样，张宁老师推荐了浙大程鹏老师。程鹏老师第二天早上打来电话聊了半个多小时，我纠结到下午，觉得方向（工控系统安全）没有接触过而且还要直博所以拒了老师。然后傍晚的时候收到浙大计院的通知，没进复试。</p><h4 id="武汉大学-9-13-9-26"><a href="#武汉大学-9-13-9-26" class="headerlink" title="武汉大学 - 9.13~9.26"></a>武汉大学 - 9.13~9.26</h4><p>清华凉了后我有点慌，因为之前没有找其他老师（其实这个时间还不算特别晚，可以多找一些老师），问武汉大学的任老师有没有名额，任老师很热情表示会给我留下名额。老师对我很上心，面试前和我说了下面试流程，怕我发挥不好让我写稿子给她过目修改一下，但我与老师实验室一个学长聊了下，感觉实验室情况和我想象中不太一样，这个时候有打算去找其他学校了。</p><p>下面是复试（武大复试比较人性化，外省可以远程面），大概十分钟：</p><pre><code class="hljs txt">1. 为什么报武大（English）2. 你本科印象最深的课3. 本科有那些竞赛和项目经历4. 你写过文档吗5. 简述下对称加密和非对称加密的区别，非对称加密在哪些情况下用6. 研究生有什么规划7. 平时有什么兴趣爱好</code></pre><h4 id="百度-9-15"><a href="#百度-9-15" class="headerlink" title="百度 - 9.15"></a>百度 - 9.15</h4><p>实习时的mentor找我问了下保研情况，得知情况不太理想，说不行的话留下来谈offer（这个组很强，游学长说我读完研究生都不一定能进这个组），到这里至少我已经有了退路。</p><h4 id="北京航空航天大学-9-16-9-28"><a href="#北京航空航天大学-9-16-9-28" class="headerlink" title="北京航空航天大学 - 9.16~9.28"></a>北京航空航天大学 - 9.16~9.28</h4><p>北航同时报了网络与信息安全学院和计算机学院。网安院只有面试，老师比较喜欢问数学题，之前没有准备，再加上材料带错，凉的比较彻底：</p><pre><code class="hljs txt">1. 政治题：结合自身经历简述下“青春-未来”2. 老师：哎，这张奖状上没你的名字啊？（woc我带成别人的了）3. 英文自我介绍4. 读一段英文并翻译（一段网络拓扑的英文描述）5. 域的定义是什么，它由那几部分组成6. 有理数域和实数域哪个大7. 什么是等价关系7. 针对简历问一些项目相关问题</code></pre><p>计算机学院有机试，相对比较友好些（机试可以用ccf证书抵，按排名算分数），面试稍微简单一些，我没有被问课内的东西（ckj被问了数学题）：</p><pre><code class="hljs txt">1. 政治题：结合自身经历简述如何建立“网络安全强国”2. 读一段英文并翻译（一段关于云计算描述）3. 针对成绩单问一些问题4. 自我介绍（可以选择中文，可能是之前英语表现很差）5. 竞赛经历、实习经历6. 简述下什么是最大流最小割7. 简述下一种二分图算法8. 简述下线段树9. 针对简历问一些问题</code></pre><p>计院面完出来后觉得很虚，但下午接到几个老师电话问我有没有找好导师，最后综合排名是12，有点意外。</p><h4 id="华为-9-27-9-28"><a href="#华为-9-27-9-28" class="headerlink" title="华为 - 9.27~9.28"></a>华为 - 9.27~9.28</h4><p>游学长问了下我对华为感不感兴趣，去的话大概有30+w。说实话虽然不是很想工作但还是有点心动的，想着如果北航过不了就去工作好了。然后28号晚上北航公布名单，嗯还是去读书吧哈哈</p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>导师是做分布式的，和我目前在百度的部门也有所合作，貌似可以做大规模并行训练相关的方向，虽然研究生阶段不怎么让出去实习，总体还是挺满意的（佛</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用Arch Live修复Arch</title>
    <link href="/2018/03/10/%E7%94%A8Arch%20Live%E4%BF%AE%E5%A4%8DArch/"/>
    <url>/2018/03/10/%E7%94%A8Arch%20Live%E4%BF%AE%E5%A4%8DArch/</url>
    
    <content type="html"><![CDATA[<p>假期更新的时候断电自动关机，随后无法启动，需要进入chroot修复系统。</p><a id="more"></a><p>开机显示如下，但键盘无法键入任何值：</p><pre><code class="hljs plain">:: running early hook [udev]Warning: &#x2F;lib&#x2F;modules&#x2F;4.15.3-Z-AEVH,modules.devname not found - ignoringstarting version 237:: running hook [udev]:: Triggering uevents...Waiting 10 seconds for device &#x2F;dev&#x2F;disk&#x2F;by-partuuid&#x2F;5322e576-3c60-4605-b394-542a3fcb5ed1 ...ERROR: device &#39;PARTUUID&#x3D;5322e576-3c60-4605-b394-542a3fcb5ed1&#39; not found. Skipping fsck.:: mounting &#39;PARTUUID&#x3D;5322e576-3c60-4605-b394-542a3fcb5ed1&#39; on real rootmount: &#x2F;new_root: can&#39;t find PARTUUID&#x3D;5322e576-3c60-4605-b394-542a3fcb5ed1.You are now being dropped into an emergency shell.sh: can&#39;t access tty; jog control turned off[rootfs ]#</code></pre><p>一脸懵逼……</p><p>Google一下，<a href="https://forum.antergos.com/topic/8884/dropped-into-emergency-shell" target="_blank" rel="noopener">要进入chroot修复系统</a>；</p><p>查看wiki <a href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener">pacman更新时崩溃</a>，似乎是内核出现问题。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>使用USBWriter做好启动盘，进入系统。</p><h2 id="检查网络"><a href="#检查网络" class="headerlink" title="检查网络"></a>检查网络</h2><p>ping一下检查是否已经自动获取网络。</p><p>发现没网，用<code>ip link</code> 命令检查网卡。</p><p>发现仅识别出有线网卡，而无线网卡没有被识别出。</p><p>插上网线，利用pppoe进行ADSL拨号上网（使用<code>pppoe-strat</code> 命令，并根据提示连接网络）。</p><h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><pre><code class="hljs plain">mount &#x2F;dev&#x2F;sda3 &#x2F;mntmkdir &#x2F;mnt&#x2F;bootmount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;boot</code></pre><h2 id="进入chroot"><a href="#进入chroot" class="headerlink" title="进入chroot"></a>进入chroot</h2><p>挂载好分区后，使用<code>arch-chroot</code>命令进入chroot：</p><pre><code class="hljs plain">arch-chroot &#x2F;mnt</code></pre><h2 id="修复内核"><a href="#修复内核" class="headerlink" title="修复内核"></a>修复内核</h2><pre><code class="hljs plain">pacman -Syu mkinitcpio systemd-tools linux</code></pre><p>重新安装内核(linux 软件包)将会自动运行<code>mkinitcpio -p linux</code> 重新生成 initramfs 镜像，不需要单独生成。</p><h2 id="卸载分区"><a href="#卸载分区" class="headerlink" title="卸载分区"></a>卸载分区</h2><p>使用<code>exit</code>, <code>umount /mnt/{boot,}</code>卸载分区，然后<code>reboot</code> ，可以正常开机。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Padding Oracle Attack</title>
    <link href="/2017/10/06/Padding%20Oracle%20Attack/"/>
    <url>/2017/10/06/Padding%20Oracle%20Attack/</url>
    
    <content type="html"><![CDATA[<p>padding-oracle attack in C language.</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>In this assignment, you must decrypt a challenge ciphertext generated using AES in CBC-mode with PKCS #5 padding. (Note: technically this is PKCS #7 padding,since the block size of AES is 16 bytes. But the padding is done in exactly the same way as PKCS #5 padding.) To do so, you will be given access to a server that will decrypt any ciphertexts you send it (using the same key that was used to generate the challenge ciphertext)…but that will only tell you whether or not decryption results in an error! </p><p>要求解密一个CBC工作模式，PKCS #7方式填充，AES加密的挑战密文。为此，你需要访问一个服务器（该服务器能用挑战密钥解密任何你发送的密文），它将返回你发送的密文是否填充正确。</p><p>All the files needed for this assignment are available here, including a README file that should explain everything. </p><p>此作业所需的所有文件都已<a href="http://oqx4hhfj3.bkt.clouddn.com/PA2-AES.rar" target="_blank" rel="noopener">在这里</a>给出，包括一个解释一切的README文件。</p><p>Note that this assignment requires the ability to perform basic networking. Because we do not assume students necessarily know this, we have provided stub code for doing basic networking in C, Java, Ruby, and Python, but you are welcome to use any language of your choice as long as you are able to write code for basic networking functionality in that language. (Students may feel free to post stub code in other languages for the networking component on the discussion boards.)</p><p>注意到此作业需要执行基本网络的功能。因为我们不要求学生必须知道这一点，所以我们提供了在C，Java，Ruby和Python中进行基本网络连接的存根代码，但是欢迎使用任何您选择的语言，只要您能够编写代码该语言的基本网络功能。（学生可以自由地在讨论板上为其他语言的网络组件发布存根代码。）</p><p>The first step in this project is to send the challenge ciphertext to the server, and verify that you receive back a “no error” message. Once you can do that, the rest is “just” crypto… </p><p>该项目的第一步是将挑战密文发送到服务器，并验证您是否收到“无错误”消息。一旦你可以做到这一点，其余的是“只是”加密…</p><p>The plaintext,when converted to ASCII, is readable English text, and so you should be able to tell once you have been successful. Once you have successfully recovered the plaintext (in ASCII).</p><p>明文转换为ASCII时，是可读的英文文本，所以一旦成功恢复明文，便可得知。</p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><h3 id="CBC工作模式"><a href="#CBC工作模式" class="headerlink" title="CBC工作模式"></a>CBC工作模式</h3><p>CBC模式即密码分组链接模式（Cipher-block chaining）。在该模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</p><p>加密过程：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g632zeiqchj30go06r74e.jpg" srcset="/img/loading.gif" alt="Cbc_encryption"></p><p>解密过程：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g632zyrnavj30go06674d.jpg" srcset="/img/loading.gif" alt="Cbc_decryption"></p><p>以上内容参考自<a href="https://zh.wikipedia.org/wiki/分组密码工作模式" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/分组密码工作模式</a></p><h3 id="PKCS-7填充"><a href="#PKCS-7填充" class="headerlink" title="PKCS #7填充"></a>PKCS #7填充</h3><p>以整字节填充。每个填充字节的值是用于填充的字节数，即是说，添加N个字节，每个的值都是N。 填充的字节数取决于信息末尾到块边缘的距离。</p><p>下例中，块大小为 8 字节，需要填充 4 字节：</p><pre><code class="hljs plain">... | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 |</code></pre><p>以上内容参考自<a href="https://zh.wikipedia.org/wiki/%E5%A1%AB%E5%85%85_(%E5%AF%86%E7%A0%81%E5%AD%A6)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/填充_(密码学) </a></p><h2 id="padding-oracle-attack攻击原理"><a href="#padding-oracle-attack攻击原理" class="headerlink" title="padding-oracle attack攻击原理"></a>padding-oracle attack攻击原理</h2><p>padding-oracle attack针对CBC工作模式攻击，与具体加密算法无关。</p><p>服务器判断Padding是否出错一般从后开始检验明文末尾字节的值，若末尾为<code>0x01</code> 则仅填充了一位，填充末尾为<code>0x03</code> 则末尾三字节均为<code>0x03</code> 。利用服务器的返回值，可以在不知道密钥的情况下得到明文。</p><p>例如现在有一个CBC工作模式，PKCS #7方式填充的密文IV||C（分组大小为8字节）：</p><pre><code class="hljs plain">... | 21 A2 DD 04 35 0A BA 58 | CD DD AA DD 34 23 A1 64 |</code></pre><p>为了方便描述，用$C[i]$ 表示第$i$ 个分组，$C[i][j]$ 表示第$i$ 个分组第$j$ 个字节，$D(*)$ 表示解密算法。</p><p>我们想要解密最后一个分组$C[n]$ ，即求$P[n]$ 。</p><p>先求明文最后一个分组的最后一位，即$P[n][6]$ 。</p><p>假设此时仅填充一个字节，构造初始向量$IV$ 值为：</p><pre><code class="hljs plain">| 00 00 00 00 00 00 00 00 |</code></pre><p>向服务器发送这两个分组构成的密文$IV||C[n]$ ：</p><pre><code class="hljs plain">| 00 00 00 00 00 00 00 00 | CD DD AA DD 34 23 A1 64 |</code></pre><p>要使服务器的返回值为$1$ （即显示Padding正确），那么明文最后一位应该为$0X01$ 。</p><p>明文末尾一位即$D(C[n][6]) \otimes IV[6]$ ，服务器返回值为$D(C[n][6]) \otimes IV[6] == 0X01$。</p><p>此时，需要遍历$[0,256)$ 修改$IV[6]$ 的值，直到服务器的返回值为$1$ 。</p><p>假设此时初始向量$IV$ 为：</p><pre><code class="hljs plain">| 00 00 00 00 00 00 00 A0 |</code></pre><p>那么$D(C[n][6]) \otimes IV[6] = 0X01$ ，于是可以得到$D(C[n][6]) = 0X01 \otimes IV[6]$ ，</p><p>即$P[n][6] = D(C[n][6]) \otimes C[n-1][6] = 0X01 \otimes IV[6] \otimes C[n-1][6]$ 。</p><p>至此，明文最后一个分组的最后一位已经得到，接下来求明文最后一个分组的倒数第二位。</p><p>此时假设填充了两个字节，即明文末尾两位均为$0X02$ 。</p><p>由于$D(C[n][6]) \otimes IV[6] = 0X01$ ，所以当$D(C[n][6]) \otimes IV^{‘}[6] = 0X02$ 时，</p><p>$IV^{‘}[6] = D(C[n][6]) \otimes 0X02 = 0X01 \otimes IV[6] \otimes 0X02$ .</p><p>此时的初始向量$IV^{‘}$ 为：</p><pre><code class="hljs plain">| 00 00 00 00 00 00 00 A3 |</code></pre><p>遍历$[0,256)$ 修改$IV^{‘}[5]$ 的值，直到服务器的返回值为$1$ 。</p><p>于是$D(C[n][5]) \otimes IV^{‘}[5] = 0X02$ ，即$D(C[n][5]) = 0X02 \otimes IV^{‘}[5]$ ，</p><p>那么$P[n][5] = D(C[n][5]) \otimes C[n-1][5] = 0X02 \otimes IV^{‘}[5] \otimes C[n-1][5]$ 。</p><p>明文最后一个分组的倒数第二位也已经得到。</p><p>依次类推，由此即可以仅根据密文还原出明文。</p><p>以上内容参考自<a href="http://www.freebuf.com/articles/web/15504.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/15504.html</a></p><h2 id="连接服务器并测试"><a href="#连接服务器并测试" class="headerlink" title="连接服务器并测试"></a>连接服务器并测试</h2><blockquote><p>The first step in this project is to send the challenge ciphertext to the server, and verify that you receive back a “no error” message. Once you can do that, the rest is “just” crypto… </p></blockquote><p>题目给出了很多文件，我们需要的只有<code>sample.c</code> ，<code>oracle.h</code>和<code>oracle.c</code> 。</p><h3 id="修改服务器地址和端口"><a href="#修改服务器地址和端口" class="headerlink" title="修改服务器地址和端口"></a>修改服务器地址和端口</h3><p>本课程的服务器地址和端口已修改为<code>128.8.130.16</code> ，<code>49101</code> 。</p><p>在<code>oracle.c</code>中修改<code>servaddr.sin_addr.s_addr</code>和<code>servaddr.sin_port</code> 。</p><h3 id="创建makefile文件"><a href="#创建makefile文件" class="headerlink" title="创建makefile文件"></a>创建makefile文件</h3><p>在文件夹目录下创建<code>makefile</code> ：</p><pre><code class="hljs shell">sample: sample.o oracle.ogcc -o sample oracle.o sample.o; rm sample.osample.o: sample.cgcc -c sample.coracle.o: oracle.c oracle.hgcc -c oracle.cclean:rm -rf *.o sample</code></pre><h3 id="编译文件并尝试连接服务器"><a href="#编译文件并尝试连接服务器" class="headerlink" title="编译文件并尝试连接服务器"></a>编译文件并尝试连接服务器</h3><p>在命令行窗口输入：</p><pre><code class="hljs shell">make</code></pre><p>得到可运行文件<code>sample</code> 。</p><p>尝试连接服务器并发送挑战密文进行测试：</p><pre><code class="hljs shel">.&#x2F;sample challenge-ciphertext.txt</code></pre><p>若返回值<code>ret</code> 等于1，则表示连接成功且发送的密文正确填充（挑战密文保证正确填充）。接下来只需要修改<code>sample.c</code> 文件进行padding-oracle attack攻击。</p><h2 id="改写sample文件"><a href="#改写sample文件" class="headerlink" title="改写sample文件"></a>改写sample文件</h2><p>模拟一下原理中的逻辑：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"oracle.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ciphertext[<span class="hljs-number">3</span>][<span class="hljs-number">16</span>]=&#123;  &#123;<span class="hljs-number">159</span>,<span class="hljs-number">11</span>,<span class="hljs-number">19</span>,<span class="hljs-number">148</span>,<span class="hljs-number">72</span>,<span class="hljs-number">65</span>,<span class="hljs-number">168</span>,<span class="hljs-number">50</span>,<span class="hljs-number">178</span>,<span class="hljs-number">66</span>,<span class="hljs-number">27</span>,<span class="hljs-number">158</span>,<span class="hljs-number">175</span>,<span class="hljs-number">109</span>,<span class="hljs-number">152</span>,<span class="hljs-number">54</span>&#125;,  &#123;<span class="hljs-number">129</span>,<span class="hljs-number">62</span>,<span class="hljs-number">201</span>,<span class="hljs-number">217</span>,<span class="hljs-number">68</span>,<span class="hljs-number">165</span>,<span class="hljs-number">200</span>,<span class="hljs-number">52</span>,<span class="hljs-number">122</span>,<span class="hljs-number">124</span>,<span class="hljs-number">166</span>,<span class="hljs-number">154</span>,<span class="hljs-number">163</span>,<span class="hljs-number">77</span>,<span class="hljs-number">141</span>,<span class="hljs-number">192</span>&#125;,  &#123;<span class="hljs-number">223</span>,<span class="hljs-number">112</span>,<span class="hljs-number">227</span>,<span class="hljs-number">67</span>,<span class="hljs-number">196</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">42</span>,<span class="hljs-number">227</span>,<span class="hljs-number">88</span>,<span class="hljs-number">116</span>,<span class="hljs-number">206</span>,<span class="hljs-number">117</span>,<span class="hljs-number">230</span>,<span class="hljs-number">76</span>,<span class="hljs-number">49</span>&#125;&#125;;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ctext[<span class="hljs-number">32</span>], plaintext[<span class="hljs-number">48</span>], xor_iv[<span class="hljs-number">16</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;  <span class="hljs-keyword">int</span> i, j, k, ret;  <span class="hljs-built_in">memset</span>(ctext, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ctext) );  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">16</span>; ++i) ctext[<span class="hljs-number">16</span>+i] = ciphertext[p][i];  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">16</span>; ++i) &#123;    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;i; ++j) ctext[<span class="hljs-number">15</span>-j] = xor_iv[<span class="hljs-number">15</span>-j] ^ (i+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">256</span>; ++j) &#123;      ctext[<span class="hljs-number">15</span>-i] = j;      ret = Oracle_Send(ctext, <span class="hljs-number">2</span>);      <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">1</span>) &#123;        xor_iv[<span class="hljs-number">15</span>-i] = j ^ (i+<span class="hljs-number">1</span>);        plaintext[<span class="hljs-number">16</span>*p+<span class="hljs-number">15</span>-i] = xor_iv[<span class="hljs-number">15</span>-i] ^ ciphertext[p<span class="hljs-number">-1</span>][<span class="hljs-number">15</span>-i];        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;  <span class="hljs-keyword">int</span> i, ret;  Oracle_Connect();  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">3</span>; ++i) solve(i);  freopen(<span class="hljs-string">"plaintext.txt"</span>, <span class="hljs-string">"w"</span>, <span class="hljs-built_in">stdout</span>);  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">16</span>; i&lt;<span class="hljs-number">48</span>; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, plaintext[i]);  fclose(<span class="hljs-built_in">stdout</span>);  Oracle_Disconnect();&#125;</code></pre><p>编译后运行：</p><pre><code class="hljs shell">./sample</code></pre><p>得到明文<code>plaintext.txt</code> ：</p><pre><code class="hljs plain">Yay! You get an A. &#x3D;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2017 ACMICPC Asia Regional Shenyang Online F.gems gems gems</title>
    <link href="/2017/09/12/2017%20ACMICPC%20Asia%20Regional%20Shenyang%20Online%20F.gems%20gems%20gems/"/>
    <url>/2017/09/12/2017%20ACMICPC%20Asia%20Regional%20Shenyang%20Online%20F.gems%20gems%20gems/</url>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6199" target="_blank" rel="noopener">HDU 6199 : gems gems gems</a> </p><a id="more"></a><blockquote><p>题目大意：两个人轮流取物品，若第$i$ 次拿了$k$ 个，则第$i+1$ 次可以拿$k$ 或$k+1$ 个。两人都想拿到值更大的物品。第一次能拿$1$ 或$2$ 个物品，问第一个人拿了多少。</p></blockquote><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>在不考虑$32M$ 空间限制的情况下，显然我们可以定义两个数组：</p><ul><li>$dp1[i][j]$ 表示第二个人前一次拿了$j$ ，第一个人当前从$i$ 个物品开始拿的最大价值</li><li>$dp2[i][j]$ 表示第一个人前一次拿了$j$ ，第二个人当前从$i$ 个物品开始拿的最大价值</li></ul><p>然后写两个dfs函数记忆化搜索一下即可。</p><p>然而这题不仅卡空间，还卡时间（递归常数较大，扣完空间还会超时），于是只能用递推搞。</p><p>原先的状态不适合递推，故重新思考状态。</p><p>由于对两个人来说，每个人都想取得最大价值，原先的两种状态可以合并为一种状态：</p><ul><li>$dp[i][j]$ 表示前一个人前一次拿了$j$ ，当前从$i$ 个物品开始拿的最大价值</li></ul><p>复杂度$O(n^{\frac{3}{2}})$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Max(a,b) (a&gt;b?a:b)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">20000</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">1e9</span>;<span class="hljs-keyword">int</span> T,n,a[N],dp[N][<span class="hljs-number">205</span>],pre[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">return</span> pre[r]-pre[l<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[<span class="hljs-number">1</span>]);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)pre[i]=pre[i<span class="hljs-number">-1</span>]+a[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;--i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=(<span class="hljs-keyword">int</span>)((<span class="hljs-number">-1</span>+<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>+<span class="hljs-number">8</span>*i))/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)&#123;                <span class="hljs-keyword">if</span>(i+j&gt;n)dp[i][j]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+j==n)dp[i][j]=query(i,i+j);                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+j+<span class="hljs-number">1</span>==n)dp[i][j]=Max(-dp[i+j+<span class="hljs-number">1</span>][j]+query(i,i+j),query(i,i+j+<span class="hljs-number">1</span>));                <span class="hljs-keyword">else</span> dp[i][j]=Max(-dp[i+j+<span class="hljs-number">1</span>][j]+query(i,i+j),-dp[i+j+<span class="hljs-number">2</span>][j+<span class="hljs-number">1</span>]+query(i,i+j+<span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017 ACM-ICPC 亚洲区（乌鲁木齐赛区）网络赛 D.Hack Portals</title>
    <link href="/2017/09/09/2017%20ACM-ICPC%20%E4%BA%9A%E6%B4%B2%E5%8C%BA%EF%BC%88%E4%B9%8C%E9%B2%81%E6%9C%A8%E9%BD%90%E8%B5%9B%E5%8C%BA%EF%BC%89%E7%BD%91%E7%BB%9C%E8%B5%9B%20D.Hack%20Portals/"/>
    <url>/2017/09/09/2017%20ACM-ICPC%20%E4%BA%9A%E6%B4%B2%E5%8C%BA%EF%BC%88%E4%B9%8C%E9%B2%81%E6%9C%A8%E9%BD%90%E8%B5%9B%E5%8C%BA%EF%BC%89%E7%BD%91%E7%BB%9C%E8%B5%9B%20D.Hack%20Portals/</url>
    
    <content type="html"><![CDATA[<p>计蒜客上的题没地方补，但是发现这题是POJ原题（连样例都没改）</p><p>题目链接：<a href="http://poj.org/problem?id=1991" target="_blank" rel="noopener">POJ 1991 : Turning in Homework</a></p><a id="more"></a><blockquote><p>题目大意：从原点到$H$ 有$C$ 个教室，每个教室的作业有最早提交时间，问从原点出发将所有作业都提交完后到达$B$ 点所需要的最少时间。</p></blockquote><h3 id="DP-贪心"><a href="#DP-贪心" class="headerlink" title="DP+贪心"></a>DP+贪心</h3><p>注意到若有连续的若干个教室$[l,r]$ 均没交作业，那么下一步最优的做法仅可能先到两端（$l$ 或$r$ ）（若先到中间，则必然会折返回来，而这部分时间花费实际是不必要的）。 </p><p>故可以定义状态$dp[i][j][0]$ 表示当前在位置$i$ ，$(i,j]$ 间的教室作业都没交的最小花费；$dp[i][j][1]$ 表示当前在位置$i$ ，$[i,j)$ 间的教室作业都没交的最小花费。</p><p>复杂度$O(n^2)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> ll inf=<span class="hljs-number">1e15</span>;ll c,h,b,dp[N][N][<span class="hljs-number">2</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    ll p,t;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b)&#123;        <span class="hljs-keyword">return</span> a.p&lt;b.p;    &#125;&#125;a[N];<span class="hljs-function">ll <span class="hljs-title">Abs</span><span class="hljs-params">(ll x)</span></span>&#123;<span class="hljs-keyword">return</span> x&gt;<span class="hljs-number">0</span>?x:-x;&#125;<span class="hljs-function">ll <span class="hljs-title">Max</span><span class="hljs-params">(ll x,ll y)</span></span>&#123;<span class="hljs-keyword">return</span> x&gt;y?x:y;&#125;<span class="hljs-function">ll <span class="hljs-title">Min</span><span class="hljs-params">(ll x,ll y)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;y?x:y;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll l,ll r,ll op)</span></span>&#123;    <span class="hljs-keyword">if</span>(l&lt;<span class="hljs-number">0</span>||r&gt;=c)<span class="hljs-keyword">return</span> inf;    <span class="hljs-keyword">if</span>(dp[l][r][op]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[l][r][op];    <span class="hljs-keyword">if</span>(op==<span class="hljs-number">0</span>)&#123;        dp[l][r][op]=Min(Max(solve(l<span class="hljs-number">-1</span>,r,<span class="hljs-number">0</span>)+Abs(a[l<span class="hljs-number">-1</span>].p-a[l].p),a[l].t),Max(solve(l,r+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)+Abs(a[r+<span class="hljs-number">1</span>].p-a[l].p),a[l].t));    &#125;<span class="hljs-keyword">else</span>&#123;        dp[l][r][op]=Min(Max(solve(l<span class="hljs-number">-1</span>,r,<span class="hljs-number">0</span>)+Abs(a[l<span class="hljs-number">-1</span>].p-a[r].p),a[r].t),Max(solve(l,r+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)+Abs(a[r+<span class="hljs-number">1</span>].p-a[r].p),a[r].t));    &#125;    <span class="hljs-keyword">return</span> dp[l][r][op];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>,&amp;c,&amp;h,&amp;b);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;c;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i].p,&amp;a[i].t);    sort(a,a+c);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    dp[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]=Max(a[<span class="hljs-number">0</span>].p,a[<span class="hljs-number">0</span>].t);    dp[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=Max(a[c<span class="hljs-number">-1</span>].p,a[c<span class="hljs-number">-1</span>].t);    ll ans=inf;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;c;++i)        ans=Min(ans,solve(i,i,<span class="hljs-number">0</span>)+Abs(a[i].p-b));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 432 (Div. 2, based on IndiaHacks Final Round 2017)</title>
    <link href="/2017/09/06/Codeforces%20Round%20432%20(Div.%202,%20based%20on%20IndiaHacks%20Final%20Round%202017)%20/"/>
    <url>/2017/09/06/Codeforces%20Round%20432%20(Div.%202,%20based%20on%20IndiaHacks%20Final%20Round%202017)%20/</url>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/851/problem/A" target="_blank" rel="noopener">A. Arpa and a research in Mexican wave</a></p><p><a href="http://codeforces.com/contest/851/problem/B" target="_blank" rel="noopener">B. Arpa and an exam about geometry</a></p><p><a href="http://codeforces.com/contest/851/problem/C" target="_blank" rel="noopener">C. Five Dimensional Points</a></p><p><a href="http://codeforces.com/contest/851/problem/D" target="_blank" rel="noopener">D. Arpa and a list of numbers</a></p><p><a href="http://codeforces.com/contest/851/problem/E" target="_blank" rel="noopener">E. Arpa and a game with Mojtaba</a></p><a id="more"></a><h2 id="A-Arpa-and-a-research-in-Mexican-wave"><a href="#A-Arpa-and-a-research-in-Mexican-wave" class="headerlink" title="A. Arpa and a research in Mexican wave"></a>A. Arpa and a research in Mexican wave</h2><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> n,k,t;    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;t;    <span class="hljs-keyword">int</span> d=t-k;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">min</span>(t,n)-<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,d);&#125;</code></pre><h2 id="B-Arpa-and-an-exam-about-geometry"><a href="#B-Arpa-and-an-exam-about-geometry" class="headerlink" title="B. Arpa and an exam about geometry"></a>B. Arpa and an exam about geometry</h2><blockquote><p>题目大意：给出a,b,c三个点，问是否存在一个点和一个角度，使得这三个点绕该点旋转这个角度后，满足a在b原先的位置，b在c原先的位置。</p></blockquote><h3 id="几何题"><a href="#几何题" class="headerlink" title="几何题"></a>几何题</h3><p>显然，若点存在则必然是由a,b,c这三个点确定的圆的圆心。因为$\widehat{aob}$ 和$\widehat{boc}$ 两个圆心角相等，故$|ab|$ 和$|bc|$ 这两条弦相等。最后只需要判断一下这三个点是否能确定圆（是否在同一条直线）即可。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll ax,ay,bx,by,cx,cy;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;ax&gt;&gt;ay&gt;&gt;bx&gt;&gt;by&gt;&gt;cx&gt;&gt;cy;    <span class="hljs-keyword">if</span>((ax-bx)*(ax-bx)+(ay-by)*(ay-by)==(cx-bx)*(cx-bx)+(cy-by)*(cy-by))&#123;        <span class="hljs-keyword">if</span>((ay-by)*(bx-cx)==(by-cy)*(ax-bx))<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Yes"</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"No"</span>;&#125;</code></pre><h2 id="C-Five-Dimensional-Points"><a href="#C-Five-Dimensional-Points" class="headerlink" title="C. Five Dimensional Points"></a>C. Five Dimensional Points</h2><blockquote><p>题目大意：给出五维空间的$n$ 个点，问对于每个点$O$ 是否存在两个不同的点$A,B$ ，使得$\angle AOB &lt;90^\circ$ 。</p></blockquote><h3 id="思维题"><a href="#思维题" class="headerlink" title="思维题"></a>思维题</h3><p>对于一个$k$ 维空间，最多有$2k$ 个点满足$\angle AOB \geqslant 90^\circ$ ，所以只需要暴力一下就好。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1005</span>;<span class="hljs-keyword">int</span> a[N],b[N],c[N],d[N],e[N];<span class="hljs-keyword">int</span> ans[N],tot,n;<span class="hljs-keyword">namespace</span> IO &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MX = <span class="hljs-number">1e7</span>;    <span class="hljs-keyword">char</span> buf[MX]; <span class="hljs-keyword">int</span> c, sz;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;        c = <span class="hljs-number">0</span>;        sz = fread(buf, <span class="hljs-number">1</span>, MX, <span class="hljs-built_in">stdin</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;t)</span> </span>&#123;        <span class="hljs-keyword">while</span>(c &lt; sz &amp;&amp; buf[c] != <span class="hljs-string">'-'</span> &amp;&amp; (buf[c] &lt; <span class="hljs-string">'0'</span> || buf[c] &gt; <span class="hljs-string">'9'</span>)) c++;        <span class="hljs-keyword">if</span>(c &gt;= sz) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span>(buf[c] == <span class="hljs-string">'-'</span>) flag = <span class="hljs-number">1</span>, c++;        <span class="hljs-keyword">for</span>(t = <span class="hljs-number">0</span>; c &lt; sz &amp;&amp; <span class="hljs-string">'0'</span> &lt;= buf[c] &amp;&amp; buf[c] &lt;= <span class="hljs-string">'9'</span>; c++) t = t * <span class="hljs-number">10</span> + buf[c] - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span>(flag) t = -t;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    IO::<span class="hljs-built_in">begin</span>();    IO::<span class="hljs-built_in">read</span>(n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)        IO::<span class="hljs-built_in">read</span>(a[i]),IO::<span class="hljs-built_in">read</span>(b[i]),IO::<span class="hljs-built_in">read</span>(c[i]),IO::<span class="hljs-built_in">read</span>(d[i]),IO::<span class="hljs-built_in">read</span>(e[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> temp=a[i]*a[i]+b[i]*b[i]+c[i]*c[i]+d[i]*d[i]+e[i]*e[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<span class="hljs-keyword">if</span>(i-j)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j+<span class="hljs-number">1</span>;k&lt;n;++k)<span class="hljs-keyword">if</span>(i-k&amp;&amp;j-k)&#123;                <span class="hljs-keyword">if</span>(a[j]*a[k]+b[j]*b[k]+c[j]*c[k]+d[j]*d[k]+e[j]*e[k]+temp                   -a[i]*(a[j]+a[k])-b[i]*(b[j]+b[k])-c[i]*(c[j]+c[k])                   -d[i]*(d[j]+d[k])-e[i]*(e[j]+e[k])&gt;<span class="hljs-number">0</span>)&#123;                    flag=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span>(flag)ans[tot++]=i+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,tot);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;++i)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ans[i]);&#125;</code></pre><h2 id="D-Arpa-and-a-list-of-numbers"><a href="#D-Arpa-and-a-list-of-numbers" class="headerlink" title="D. Arpa and a list of numbers"></a>D. Arpa and a list of numbers</h2><blockquote><p>题目大意：给定$n$ 个数，问进行下面两种操作后，最少花费多少能使这$n$ 个数的最大公约数不为$1$ 。</p><ul><li>选择一个数删除，花费$x$ </li><li>选择一个数加$1$ ，花费$y$ </li></ul></blockquote><h3 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h3><p>枚举操作完后的最大公约数$d$ ，显然$[kd+1,(k+1)d-1]$ 的数$a$ 只有两种操作情况：</p><ul><li>删除，花费$x$ </li><li>加至$(k+1)d$ ，花费$[(k+1)d-a]y$ </li></ul><p>因此，我们可以枚举$k$ ，一段一段地考虑。</p><p>而当$a \geqslant (k+1)d- \lfloor \frac{x}{y} \rfloor $ 时，将$a$ 加至$(k+1)d$ 比删除$a$ 花费的代价小。</p><p>于是我们维护每个区间数的个数，以及每个区间数的和，就可以以$O(1)$ 的复杂度处理每一段的代价。</p><p>复杂度$O(nlogn)$ 。</p><p>这里其实可以继续优化，显然对于最大公约数我们只需要枚举所有质数，预处理质数后，复杂度为$O(nloglogn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">500000</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=<span class="hljs-number">2000000</span>+<span class="hljs-number">5</span>;ll n,x,y,t,cnt[M],sum[M];<span class="hljs-function">ll <span class="hljs-title">Max</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d%I64d%I64d"</span>,&amp;n,&amp;x,&amp;y);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;t);        cnt[t]++;        sum[t]+=t;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;M;++i)&#123;        cnt[i]+=cnt[i<span class="hljs-number">-1</span>];        sum[i]+=sum[i<span class="hljs-number">-1</span>];    &#125;    ll ans=<span class="hljs-number">1e17</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1000000</span>;++i)&#123;        ll temp=<span class="hljs-number">0</span>,k=x/y;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1000000</span>;j+=i)&#123;            temp+=((cnt[j+i<span class="hljs-number">-1</span>]-cnt[Max(j,j+i-k<span class="hljs-number">-1</span>)])*(j+i)-(sum[j+i<span class="hljs-number">-1</span>]-sum[Max(j,j+i-k<span class="hljs-number">-1</span>)]))*y+(cnt[Max(j,j+i-k<span class="hljs-number">-1</span>)]-cnt[j])*x;        &#125;        <span class="hljs-keyword">if</span>(ans&gt;temp)ans=temp;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,ans);&#125;</code></pre><h2 id="E-Arpa-and-a-game-with-Mojtaba"><a href="#E-Arpa-and-a-game-with-Mojtaba" class="headerlink" title="E. Arpa and a game with Mojtaba"></a>E. Arpa and a game with Mojtaba</h2><blockquote><p>题目大意：给定$n$ 个数，两人轮流从中改数。每轮选定一个素数$p$ 和正整数$k$ ，将所有能被$p^k$ 整除的数除$p^k$ 。当无法操作时为输。</p></blockquote><h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h3><p>显然不同的素数间是互相独立的，故只需要暴力求出对于单个素数的SG函数值，异或下即可。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100</span>+<span class="hljs-number">5</span>;ll p[<span class="hljs-number">100005</span>],vis[<span class="hljs-number">100005</span>],k;ll n,a[N],maxn,ans;<span class="hljs-built_in">map</span>&lt;ll,ll&gt;mp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])p[k++]=i;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;p[j]*i&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">Max</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll s)</span></span>&#123;    <span class="hljs-keyword">if</span>(s==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(mp.count(s))<span class="hljs-keyword">return</span> mp[s];    ll tmp=<span class="hljs-number">0</span>,sg=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;++i)&#123;        tmp|=((s&gt;&gt;i)&amp;<span class="hljs-number">1</span>)&lt;&lt;i;        <span class="hljs-keyword">if</span>((s&gt;&gt;(i+<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        sg|=(<span class="hljs-number">1L</span>L&lt;&lt;solve(tmp|(s&gt;&gt;(i+<span class="hljs-number">1</span>))));    &#125;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(;ans&lt;<span class="hljs-number">30</span>;++ans)        <span class="hljs-keyword">if</span>(((sg&gt;&gt;ans)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)            <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">return</span> mp[s]=ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(<span class="hljs-number">100005</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;a[i]);        maxn=Max(maxn,a[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k&amp;&amp;p[i]*p[i]&lt;=maxn;++i)&#123;        ll s=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;            ll cnt=<span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(a[j]%p[i]==<span class="hljs-number">0</span>)&#123;                a[j]/=p[i];                cnt++;            &#125;            s|=(<span class="hljs-number">1L</span>L&lt;&lt;cnt);        &#125;        ans^=solve(s);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;++j)<span class="hljs-keyword">if</span>(a[j]==a[i])a[j]=<span class="hljs-number">1</span>;        a[i]=<span class="hljs-number">1</span>;        ans^=solve(<span class="hljs-number">2</span>);    &#125;    <span class="hljs-keyword">if</span>(ans)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Mojtaba\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Arpa\n"</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>博弈</tag>
      
      <tag>思维</tag>
      
      <tag>调和级数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BZOJ 3994 [SDOI2015]约数个数和</title>
    <link href="/2017/09/01/BZOJ%203994%20%5BSDOI2015%5D%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
    <url>/2017/09/01/BZOJ%203994%20%5BSDOI2015%5D%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3994" target="_blank" rel="noopener">BZOJ 3994 [SDOI2015]约数个数和</a></p><a id="more"></a><blockquote><p>题目大意：求$\sum_{i=1}^n\sum_{j=1}^md(ij)$ ，其中$d(n)$ 指$n$ 的因子个数。</p></blockquote><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$i\times j$ 的每个因数可以被唯一表示为$\frac{pj}{q}$ ，其中$p|i,q|j,(p,q)=1$ ，故$d(ij)=\sum_{p|i}\sum_{q|j}[(p,q)=1]$ 。<br>$$<br>\therefore \sum_{i=1}^n\sum_{j=1}^md(ij)=\sum_{i=1}^n\sum_{j=1}^m\sum_{p|i}\sum_{q|j}[(p,q)=1]\\<br>=\sum_{i=1}^n\sum_{j=1}^m[(i,j)=1]\lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{j} \rfloor\\<br>=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|(i,j)}u(d)\lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{j} \rfloor\\<br>=\sum_{d=1}^{min(n,m)}u(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}\lfloor \frac{n}{id} \rfloor \lfloor \frac{m}{jd} \rfloor\\<br>=\sum_{d=1}^{min(n,m)}u(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\lfloor \frac{n}{id} \rfloor\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \lfloor \frac{m}{jd} \rfloor\\<br>=\sum_{d=1}^{min(n,m)}u(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}d(i)\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} d(j)\\<br>$$<br>复杂度$O(nlogn+\sqrt{n})$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">50000</span>+<span class="hljs-number">5</span>;ll p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k,u[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,pu[N],d[N],pd[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            p[k++]=i;            u[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;p[j]*i&lt;n;++j)&#123;            vis[p[j]*i]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                u[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> u[i*p[j]]=-u[i];        &#125;    &#125;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;n;++i)        pu[i]=pu[i<span class="hljs-number">-1</span>]+u[i];    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;n;++i)        <span class="hljs-keyword">for</span>(ll j=i;j&lt;n;j+=i)            d[j]++;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;n;++i)        pd[i]=pd[i<span class="hljs-number">-1</span>]+d[i];&#125;<span class="hljs-function">ll <span class="hljs-title">Min</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll n,ll m)</span></span>&#123;    ll ans=<span class="hljs-number">0</span>,len=Min(n,m),d,td;    <span class="hljs-keyword">for</span>(d=<span class="hljs-number">1</span>;d&lt;=len;d=td+<span class="hljs-number">1</span>)&#123;        td=Min(n/(n/d),m/(m/d));        ans+=(pu[td]-pu[d<span class="hljs-number">-1</span>])*pd[n/d]*pd[m/d];    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    ll T,n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(n,m));    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 6134 Battlestation Operational(2017 Multi-University Training Contest - Team 8)</title>
    <link href="/2017/08/26/HDU%206134%20Battlestation%20Operational(2017%20Multi-University%20Training%20Contest%20-%20Team%208)/"/>
    <url>/2017/08/26/HDU%206134%20Battlestation%20Operational(2017%20Multi-University%20Training%20Contest%20-%20Team%208)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6134" target="_blank" rel="noopener">HDU 6134 Battlestation Operational</a></p><a id="more"></a><blockquote><p>题目大意：求$f(n)=\sum_{i=1}^n\sum_{j=1}^i \lceil \frac{i}{j} \rceil [(i,j)=1]$ 。</p></blockquote><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>首先，有一个据说很著名的等式：<br>$$<br>\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor =\sum_{i=1}^n \sigma(i)<br>$$<br>其中$\sigma(n)$ 为$n$ 的因数个数。这个等式可以由筛法证明（见代码）。</p><p>然后我们来化简下题目中所要求的函数$f(n)$ 。<br>$$<br>f(n)=\sum_{i=1}^n \sum_{j=1}^i \lceil \frac{i}{j} \rceil [(i,j)=1]\\<br>=\sum_{i=1}^n(\sum_{j=1}^i \lfloor \frac{i}{j} \rfloor[(i,j)=1] +\varphi(i)-1)\\<br>=\sum_{i=1}^n\sum_{j=1}^i \lfloor \frac{i}{j} \rfloor[(i,j)=1] +\sum_{i=1}^n\varphi(i)-n\\<br>$$<br>设$g(n)=\sum_{i=1}^n\sum_{j=1}^i \lfloor \frac{i}{j} \rfloor[(i,j)=1],i=k_1d,j=k_2d$ ，则有<br>$$<br>g(n)=\sum_{i=1}^n\sum_{j=1}^i \lfloor \frac{i}{j} \rfloor[(i,j)=1]\\<br>=\sum_{i=1}^n\sum_{j=1}^i \lfloor \frac{i}{j} \rfloor \sum_{d|(i,j)}u(d)\\<br>=\sum_{d=1}^nu(d)\sum_{k_1=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{k_2=1}^{k_1}\lfloor \frac{k_1}{k_2} \rfloor\\<br>=\sum_{d=1}^nu(d)\sum_{k_1=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{k_2=1}^{k_1}\sigma(k_2)<br>$$<br>$h(n)=\sum_{i=1}^n\sum_{j=1}^{i}\sigma(j)$ 预处理的复杂度为$O(nlogn)$ 。</p><p>于是$f(n)=\sum_{d=1}^nu(d)h(\lfloor \frac{n}{d} \rfloor)+\sum_{i=1}^n\varphi(i)-n$ 可以在$O(\sqrt{n})$ 的复杂度求出。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000001</span>;<span class="hljs-keyword">const</span> ll p=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;ll d[N],h[N],sumd,n;ll prime[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k,phi[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,pphi[N],mu[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,pmu[N];<span class="hljs-function">ll <span class="hljs-title">Max</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;N;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            prime[k++]=i;            phi[i]=i<span class="hljs-number">-1</span>;            mu[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;prime[j]*i&lt;N;++j)&#123;            vis[i*prime[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;                mu[i*prime[j]]=<span class="hljs-number">0</span>;                phi[i*prime[j]]=phi[i]*prime[j];                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                mu[i*prime[j]]=-mu[i];                phi[i*prime[j]]=phi[i]*(prime[j]<span class="hljs-number">-1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;N;j+=i)            d[j]++;<span class="hljs-comment">//预处理\sigma(n)</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i)&#123;        sumd=(sumd+d[i])%p;        h[i]=(h[i<span class="hljs-number">-1</span>]+sumd)%p;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i)&#123;        pphi[i]=(pphi[i<span class="hljs-number">-1</span>]+phi[i])%p;        pmu[i]=pmu[i<span class="hljs-number">-1</span>]+mu[i];    &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll n)</span></span>&#123;    ll ans=((pphi[n]-n)%p+p)%p;    <span class="hljs-keyword">for</span>(ll d=<span class="hljs-number">1</span>;d&lt;=n;)&#123;        ll pd=Max(d,n/(n/d));        ans+=(pmu[pd]-pmu[d<span class="hljs-number">-1</span>])*h[n/d]%p;        ans=(ans+p)%p;        d=pd+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init();    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;n))        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,solve(n));&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>莫比乌斯反演</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 6138 Fleet of the Eternal Throne(2017 Multi-University Training Contest - Team 8)</title>
    <link href="/2017/08/26/HDU%206138%20Fleet%20of%20the%20Eternal%20Throne(2017%20Multi-University%20Training%20Contest%20-%20Team%208)/"/>
    <url>/2017/08/26/HDU%206138%20Fleet%20of%20the%20Eternal%20Throne(2017%20Multi-University%20Training%20Contest%20-%20Team%208)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6138" target="_blank" rel="noopener">HDU 6138 Fleet of the Eternal Throne</a></p><a id="more"></a><blockquote><p>题目大意：给出$n$ 个字符串，询问$m$ 次，每次询问$x$ 串和$y$ 串满足下面条件的最大子串长为多少。</p><ul><li>该子串是串$x$ 和串$y$ 的连续公共子串</li><li>该字串是$n$ 个字符串的公共前缀</li></ul></blockquote><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><p>考虑到要求子串是$n$ 个字符串的公共前缀，可以建立AC自动机，并记录每个结点的深度（前缀长）。</p><p>然后跑一遍串$x$ ，标记经过的结点，表示既是$x$ 的子串又是$n$ 个字符串的公共前缀。</p><p>再跑一遍串$y$ ，如果当前结点已被标记，更新答案。</p><p>复杂度$O(n)$ 。</p><p> 代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span>&#123;</span>    <span class="hljs-keyword">int</span> Root,L;    <span class="hljs-keyword">int</span> Next[N][<span class="hljs-number">26</span>],Fail[N],End[N],Dep[N],vis[N];    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Newnode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i)            Next[L][i]=<span class="hljs-number">-1</span>;        End[L++]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> L<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        L=<span class="hljs-number">0</span>,Root=Newnode();    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> Buff)</span></span>&#123;        <span class="hljs-keyword">int</span> len=Buff.length();        <span class="hljs-keyword">int</span> now=Root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;            <span class="hljs-keyword">int</span> c=Buff[i]-<span class="hljs-string">'a'</span>;            <span class="hljs-keyword">if</span>(Next[now][c]==<span class="hljs-number">-1</span>)                Next[now][c]=Newnode();            now=Next[now][c];            Dep[now]=i+<span class="hljs-number">1</span>;        &#125;        End[now]++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Build</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;        Fail[Root]=Root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i)&#123;            <span class="hljs-keyword">if</span>(Next[Root][i]==<span class="hljs-number">-1</span>)&#123;                Next[Root][i]=Root;            &#125;<span class="hljs-keyword">else</span>&#123;                Fail[Next[Root][i]]=Root;                q.push(Next[Root][i]);            &#125;        &#125;        <span class="hljs-keyword">while</span>(!q.empty())&#123;            <span class="hljs-keyword">int</span> now=q.front();            q.pop();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i)&#123;                <span class="hljs-keyword">if</span>(Next[now][i]==<span class="hljs-number">-1</span>)&#123;                    Next[now][i]=Next[Fail[now]][i];                &#125;<span class="hljs-keyword">else</span>&#123;                    Fail[Next[now][i]]=Next[Fail[now]][i];                    q.push(Next[now][i]);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x,<span class="hljs-built_in">string</span> y)</span></span>&#123;        <span class="hljs-keyword">int</span> len=x.length();        <span class="hljs-keyword">int</span> now=Root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;            <span class="hljs-keyword">int</span> c=x[i]-<span class="hljs-string">'a'</span>;            now=Next[now][c];            <span class="hljs-keyword">int</span> temp=now;            <span class="hljs-keyword">while</span>(temp!=Root)&#123;                vis[temp]=<span class="hljs-number">1</span>;                temp=Fail[temp];            &#125;        &#125;        len=y.length();        now=Root;        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;            <span class="hljs-keyword">int</span> c=y[i]-<span class="hljs-string">'a'</span>;            now=Next[now][c];            <span class="hljs-keyword">int</span> temp=now;            <span class="hljs-keyword">while</span>(temp!=Root)&#123;                <span class="hljs-keyword">if</span>(vis[temp])ans=<span class="hljs-built_in">max</span>(ans,Dep[temp]);                temp=Fail[temp];            &#125;        &#125;        len=x.length();        now=Root;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;            <span class="hljs-keyword">int</span> c=x[i]-<span class="hljs-string">'a'</span>;            now=Next[now][c];            <span class="hljs-keyword">int</span> temp=now;            <span class="hljs-keyword">while</span>(temp!=Root)&#123;                vis[temp]=<span class="hljs-number">0</span>;                temp=Fail[temp];            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;gao;<span class="hljs-keyword">int</span> T,n,m,x,y;<span class="hljs-built_in">string</span> s[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span>&gt;&gt;T;    <span class="hljs-keyword">while</span>(T--)&#123;        gao.init();        <span class="hljs-built_in">cin</span>&gt;&gt;n;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;s[i];            gao.Insert(s[i]);        &#125;        gao.Build();        <span class="hljs-built_in">cin</span>&gt;&gt;m;        <span class="hljs-keyword">while</span>(m--)&#123;            <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;            <span class="hljs-built_in">cout</span>&lt;&lt;gao.Query(s[x],s[y])&lt;&lt;<span class="hljs-string">"\n"</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>AC自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 6161 Big binary tree(2017 Multi-University Training Contest - Team 8)</title>
    <link href="/2017/08/25/HDU%206161%20Big%20binary%20tree(2017%20Multi-University%20Training%20Contest%20-%20Team%208)/"/>
    <url>/2017/08/25/HDU%206161%20Big%20binary%20tree(2017%20Multi-University%20Training%20Contest%20-%20Team%208)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6161" target="_blank" rel="noopener">HDU 6161 Big binary tree</a></p><a id="more"></a><blockquote><p>题目大意：给定一棵完全二叉树$(n \leqslant 10^8)$ ，每个点点权默认为层序遍历顺序标号。有$m$ 次操作：</p><ul><li>把$u$ 点的点权改为$x$ 。</li><li>查询所有经过$u$ 的路径中，点权和最大的路径。</li></ul></blockquote><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>设$a[p]$ 为结点$p$ 的点权。</p><p>可以维护一个数组$dp[p]$ 表示从结点$p$ 向下的所有路径中最大的点权和。</p><p>转移方程：$dp[p]=max(dp[p&lt;&lt;1],dp[p&lt;&lt;1|1])+a[p]$ 。</p><p>因为每个点的点权均为正数，故经过点$p$ 的点权和最大的路径只能为从该点左子树走到右子树的路径或者从该点出发向上走到某个祖先转向另一个孩子。</p><p>前者的值为$dp[p&lt;&lt;1]+dp[p&lt;&lt;1|1]+a[p]$ ，$O(1)$ 复杂度。</p><p>后者可以暴力求解，因为是完全二叉树，故复杂度为$O(logn)$ 。</p><p>修改的时候仅当前结点及其祖先受到影响，暴力修改，同理复杂度为$O(logn)$ 。</p><p>因为$n$ 是$10^8$ 级别的，故没有修改过的结点直接$O(logn)$ 求出，用<code>unordered_map</code>修改过的值。</p><p>总复杂度$O(mlogn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000005</span>;<span class="hljs-built_in">unordered_map</span>&lt;ll,ll&gt;dp(N),a(N);ll n,m,p,x;<span class="hljs-keyword">char</span> op[<span class="hljs-number">7</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    dp.<span class="hljs-built_in">clear</span>();    a.<span class="hljs-built_in">clear</span>();&#125;<span class="hljs-function">ll <span class="hljs-title">get_value</span><span class="hljs-params">(ll p)</span></span>&#123;    ll u=<span class="hljs-number">0</span>,v=<span class="hljs-number">0</span>,tmp=p;    <span class="hljs-keyword">while</span>(tmp&lt;=n)&#123;        u+=tmp;        tmp=tmp&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>;    &#125;    tmp=n;    <span class="hljs-keyword">while</span>(tmp&gt;p)&#123;        v+=tmp;        tmp&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(tmp==p)<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(u,v+p);    <span class="hljs-keyword">return</span> u;&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll p)</span></span>&#123;    ll l=dp[p&lt;&lt;<span class="hljs-number">1</span>],r=dp[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>],v=a[p];    <span class="hljs-keyword">if</span>(!l&amp;&amp;(p&lt;&lt;<span class="hljs-number">1</span>)&lt;=n)l=get_value(p&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(!r&amp;&amp;(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)&lt;=n)r=get_value(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(!v)v=p;    ll ans=l+r+v,tmp=dp[p];    <span class="hljs-keyword">if</span>(!tmp)tmp=get_value(p);    <span class="hljs-keyword">while</span>(p!=<span class="hljs-number">1</span>)&#123;        ll rt=a[p&gt;&gt;<span class="hljs-number">1</span>],son=dp[p/<span class="hljs-number">2</span>*<span class="hljs-number">4</span>+<span class="hljs-number">1</span>-p];        <span class="hljs-keyword">if</span>(!rt)rt=p&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!son&amp;&amp;(p/<span class="hljs-number">2</span>*<span class="hljs-number">4</span>+<span class="hljs-number">1</span>-p)&lt;=n)son=get_value(p/<span class="hljs-number">2</span>*<span class="hljs-number">4</span>+<span class="hljs-number">1</span>-p);        tmp+=rt;        ans=<span class="hljs-built_in">max</span>(ans,tmp+son);        p&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span></span>&#123;    ll l=dp[p&lt;&lt;<span class="hljs-number">1</span>],r=dp[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>],v=a[p];    <span class="hljs-keyword">if</span>(!l&amp;&amp;(p&lt;&lt;<span class="hljs-number">1</span>)&lt;=n)l=get_value(p&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(!r&amp;&amp;(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)&lt;=n)r=get_value(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(!v)v=p;    dp[p]=<span class="hljs-built_in">max</span>(l,r)+v;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(ll p,ll x)</span></span>&#123;    ll l=dp[p&lt;&lt;<span class="hljs-number">1</span>],r=dp[p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(!l&amp;&amp;(p&lt;&lt;<span class="hljs-number">1</span>)&lt;=n)l=get_value(p&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(!r&amp;&amp;(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>)&lt;=n)r=get_value(p&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    dp[p]=<span class="hljs-built_in">max</span>(l,r)+x;    a[p]=x;    <span class="hljs-keyword">while</span>(p!=<span class="hljs-number">1</span>)&#123;        push_up(p&gt;&gt;<span class="hljs-number">1</span>);        p&gt;&gt;=<span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d%I64d"</span>,&amp;n,&amp;m))&#123;        init();        <span class="hljs-keyword">while</span>(m--)&#123;            getchar();            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,op);            <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'q'</span>)&#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;p);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,query(p));            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">'c'</span>)&#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d%I64d"</span>,&amp;p,&amp;x);                updata(p,x);            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 6171 Admiral(2017 Multi-University Training Contest - Team 10)</title>
    <link href="/2017/08/24/HDU%206171%20Admiral(2017%20Multi-University%20Training%20Contest%20-%20Team%2010)/"/>
    <url>/2017/08/24/HDU%206171%20Admiral(2017%20Multi-University%20Training%20Contest%20-%20Team%2010)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6171" target="_blank" rel="noopener">HDU 6171 Admiral</a></p><a id="more"></a><blockquote><p>题目大意：给定一个高度为$6$ 的数塔，问最少多少步能走成原始状态。大于$20$ 步直接输出“too difficult”! </p><p>每次只能将值为$0$ 的点与其左上，上方，下方，右下四个方向的一个点进行交换。 </p></blockquote><h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><p>利用中间相遇法，从给定状态和原始状态出发进行BFS。</p><p>复杂度$O(4^{\frac{n}{2}})$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> T,t,ans,p;<span class="hljs-keyword">int</span> fl[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">int</span> e[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>&#125;;ll <span class="hljs-built_in">pow</span>[<span class="hljs-number">22</span>];ll sd=<span class="hljs-number">751637788911935</span>;<span class="hljs-built_in">unordered_map</span>&lt;ll,<span class="hljs-keyword">int</span>&gt;vis1,vis2;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    ll s;    <span class="hljs-keyword">int</span> p,d;    node(ll S,<span class="hljs-keyword">int</span> P,<span class="hljs-keyword">int</span> D)&#123;        s=S;p=P;d=D;    &#125;&#125;;<span class="hljs-built_in">queue</span>&lt;node&gt;q1,q2;<span class="hljs-function">ll <span class="hljs-title">swp</span><span class="hljs-params">(ll s,<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span></span>&#123;    <span class="hljs-keyword">if</span>(p&lt;q)swap(q,p);    ll tp=s%<span class="hljs-built_in">pow</span>[p+<span class="hljs-number">1</span>]/<span class="hljs-built_in">pow</span>[p];    ll tq=s%<span class="hljs-built_in">pow</span>[q+<span class="hljs-number">1</span>]/<span class="hljs-built_in">pow</span>[q];    ll t=s/<span class="hljs-built_in">pow</span>[p+<span class="hljs-number">1</span>]*<span class="hljs-built_in">pow</span>[p+<span class="hljs-number">1</span>]+tq*<span class="hljs-built_in">pow</span>[p]        +s%<span class="hljs-built_in">pow</span>[p]/<span class="hljs-built_in">pow</span>[q+<span class="hljs-number">1</span>]*<span class="hljs-built_in">pow</span>[q+<span class="hljs-number">1</span>]+tp*<span class="hljs-built_in">pow</span>[q]+s%<span class="hljs-built_in">pow</span>[q];    <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(ll s,<span class="hljs-keyword">int</span> p)</span></span>&#123;    vis1.<span class="hljs-built_in">clear</span>();vis2.<span class="hljs-built_in">clear</span>();    vis1[sd]=<span class="hljs-number">0</span>;vis2[s]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q1.empty())q1.pop();    <span class="hljs-keyword">while</span>(!q2.empty())q2.pop();    q1.push(node(sd,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    q2.push(node(s,p,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span>(!q1.empty()||!q2.empty())&#123;        <span class="hljs-keyword">if</span>(!q1.empty())&#123;            node t=q1.front();q1.pop();            ll s=t.s;            <span class="hljs-keyword">int</span> p=t.p,d=t.d;            <span class="hljs-keyword">if</span>(vis2.count(s))                <span class="hljs-keyword">return</span> d+vis2[s];            <span class="hljs-keyword">int</span> pf=fl[p];            <span class="hljs-keyword">int</span> f=fl[p]+<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(p-f&gt;=e[pf<span class="hljs-number">-1</span>])&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p-f));                <span class="hljs-keyword">if</span>(vis1.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis1[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q1.push(node(ts,p-f,d+<span class="hljs-number">1</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">15</span>)&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p+f));                <span class="hljs-keyword">if</span>(vis1.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis1[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q1.push(node(ts,p+f,d+<span class="hljs-number">1</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span>(p-f+<span class="hljs-number">1</span>&lt;e[f<span class="hljs-number">-1</span>])&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p-f+<span class="hljs-number">1</span>));                <span class="hljs-keyword">if</span>(vis1.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis1[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q1.push(node(ts,p-f+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">15</span>)&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p+f+<span class="hljs-number">1</span>));                <span class="hljs-keyword">if</span>(vis1.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis1[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q1.push(node(ts,p+f+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>));                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(!q2.empty())&#123;            node t=q2.front();q2.pop();            ll s=t.s;            <span class="hljs-keyword">int</span> p=t.p,d=t.d;            <span class="hljs-keyword">if</span>(vis1.count(s))                <span class="hljs-keyword">return</span> d+vis1[s];            <span class="hljs-keyword">int</span> pf=fl[p];            <span class="hljs-keyword">int</span> f=fl[p]+<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(p-f&gt;=e[pf<span class="hljs-number">-1</span>])&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p-f));                <span class="hljs-keyword">if</span>(vis2.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis2[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q2.push(node(ts,p-f,d+<span class="hljs-number">1</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">15</span>)&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p+f));                <span class="hljs-keyword">if</span>(vis2.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis2[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q2.push(node(ts,p+f,d+<span class="hljs-number">1</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span>(p-f+<span class="hljs-number">1</span>&lt;e[f<span class="hljs-number">-1</span>])&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p-f+<span class="hljs-number">1</span>));                <span class="hljs-keyword">if</span>(vis2.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis2[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q2.push(node(ts,p-f+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">15</span>)&#123;                ll ts=swp(s,<span class="hljs-number">20</span>-p,<span class="hljs-number">20</span>-(p+f+<span class="hljs-number">1</span>));                <span class="hljs-keyword">if</span>(vis2.count(ts)==<span class="hljs-number">0</span>)&#123;                    vis2[ts]=d+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">10</span>)q2.push(node(ts,p+f+<span class="hljs-number">1</span>,d+<span class="hljs-number">1</span>));                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">pow</span>[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">21</span>;++i)        <span class="hljs-built_in">pow</span>[i]=<span class="hljs-built_in">pow</span>[i<span class="hljs-number">-1</span>]*<span class="hljs-number">6</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        ll s=<span class="hljs-number">0</span>,tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">6</span>;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)&#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);                s=s*<span class="hljs-number">6</span>+t;                <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)p=tot;                tot++;            &#125;        &#125;        ans=bfs(s,p);        <span class="hljs-keyword">if</span>(ans!=<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"too difficult\n"</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双向BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 6166 Senior Pan(2017 Multi-University Training Contest - Team 9)</title>
    <link href="/2017/08/23/HDU%206166%20Senior%20Pan(2017%20Multi-University%20Training%20Contest%20-%20Team%209)/"/>
    <url>/2017/08/23/HDU%206166%20Senior%20Pan(2017%20Multi-University%20Training%20Contest%20-%20Team%209)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6166" target="_blank" rel="noopener">HDU 6166 Senior Pan</a></p><a id="more"></a><blockquote><p>题目大意：$n$ 个点$m$ 条边的有向图中，给定$k$ 个点，问这$k$ 个点两两间的最短路的最小值。</p></blockquote><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>因为题目要求的是两两不同点间的最短路，故可以将这k个点划分成两个集合，一个连接虚起点，另一个连接虚终点，求起点到终点的最短路即可。</p><p>如何划分？看到群里有人是用随机化划分过的，除了随机化还有一种靠谱的放法。</p><p>枚举二进制的每一位，将这$k$ 个数分成两个集合，这种做法保证了每两个点至少被分到两个集合一次。</p><p>复杂度$O(nlog^2n)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span>    <span class="hljs-keyword">int</span> t,w;    edge(<span class="hljs-keyword">int</span> T,<span class="hljs-keyword">int</span> W)&#123;t=T;w=W;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> v,d;    node(<span class="hljs-keyword">int</span> V,<span class="hljs-keyword">int</span> D)&#123;v=V;d=D;&#125;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b)&#123;        <span class="hljs-keyword">return</span> a.d&gt;b.d;    &#125;&#125;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">1e9</span>;<span class="hljs-built_in">vector</span>&lt;edge&gt;e[N];<span class="hljs-keyword">int</span> vis[N],dis[N],adj[N][<span class="hljs-number">3</span>];priority_queue&lt;node&gt;q;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t)</span></span>&#123;    <span class="hljs-keyword">while</span>(!q.empty())q.pop();    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=t;++i)dis[i]=inf;    dis[s]=<span class="hljs-number">0</span>;    q.push(node(s,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span>(!q.empty())&#123;        node t=q.top();q.pop();        <span class="hljs-keyword">int</span> u=t.v;        <span class="hljs-keyword">if</span>(vis[u])<span class="hljs-keyword">continue</span>;        vis[u]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)e[u].<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-keyword">int</span> v=e[u][i].t,w=e[u][i].w;            dis[v]=<span class="hljs-built_in">min</span>(dis[u]+w,dis[v]);            <span class="hljs-keyword">if</span>(!vis[v])q.push(node(v,dis[v]));        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[t];&#125;<span class="hljs-keyword">int</span> T,n,m,k,a[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=T;++t)&#123;        <span class="hljs-keyword">int</span> ans=inf;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;++j)                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;adj[i][j]);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> op=<span class="hljs-number">0</span>;op&lt;<span class="hljs-number">2</span>;++op)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n+<span class="hljs-number">1</span>;++j)e[j].<span class="hljs-built_in">clear</span>();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)e[adj[j][<span class="hljs-number">0</span>]].push_back(edge(adj[j][<span class="hljs-number">1</span>],adj[j][<span class="hljs-number">2</span>]));                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k;++j)&#123;                    <span class="hljs-keyword">if</span>(((a[j]&gt;&gt;i)&amp;<span class="hljs-number">1</span>)==op)e[<span class="hljs-number">0</span>].push_back(edge(a[j],<span class="hljs-number">0</span>));                    <span class="hljs-keyword">else</span> e[a[j]].push_back(edge(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));                &#125;                ans=<span class="hljs-built_in">min</span>(ans,dijkstra(<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>));            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %d\n"</span>,t,ans);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫比乌斯反演练习</title>
    <link href="/2017/08/19/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E7%BB%83%E4%B9%A0/"/>
    <url>/2017/08/19/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1695" target="_blank" rel="noopener">HDU - 1695 : GCD</a></p><p><a href="http://codeforces.com/problemset/problem/235/E" target="_blank" rel="noopener">CodeForces - 235E : Number Challenge</a></p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2154" target="_blank" rel="noopener">BZOJ 2154: Crash的数字表格</a></p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3529" target="_blank" rel="noopener">BZOJ 3529: [Sdoi2014]数表</a></p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2440" target="_blank" rel="noopener">BZOJ 2440: [中山市选2011]完全平方数</a></p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2301" target="_blank" rel="noopener">BZOJ 2301: [HAOI2011]Problem b</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4746" target="_blank" rel="noopener">HDU - 4746 : Mophues</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5212" target="_blank" rel="noopener">HDU - 5212 : Code</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5321" target="_blank" rel="noopener">HDU - 5321 : Beautiful Set</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4947" target="_blank" rel="noopener">HDU - 4947 : GCD Array</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5663" target="_blank" rel="noopener">HDU - 5663 : Hillan and the girl</a></p><p><a href="http://acm.uestc.edu.cn/#/problem/show/811" target="_blank" rel="noopener">UESTC - 811 : GCD</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5656" target="_blank" rel="noopener">HDU - 5656 : CA Loves GCD</a></p><p><a href="http://acdream.info/problem?pid=1114" target="_blank" rel="noopener">ACdream - 1114 : Number theory</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5468" target="_blank" rel="noopener">HDU - 5468 : Puzzled Elena</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2841" target="_blank" rel="noopener">HDU - 2841 :  Visible Trees</a></p><p><a href="http://poj.org/problem?id=3904" target="_blank" rel="noopener">POJ - 3904 : Sky Code</a></p><a id="more"></a><p>莫比乌斯反演式：</p><p>$\sum_{d|n} u(d) = [n=1]$  ，其中$d = \prod_{i=1}^{k} p_i^{e_i}$ ，$u(d)$ 为莫比乌斯函数，见下式<br>$$<br>u(d)=<br>\begin{cases}<br>1      &amp;{d=1}\\<br>0      &amp;{\exists e_i &gt; 1}\\<br>(-1)^k     &amp;{\forall e_i=1}\\<br>\end{cases}<br>$$</p><h2 id="HDU-1695-GCD"><a href="#HDU-1695-GCD" class="headerlink" title="HDU - 1695 : GCD"></a>HDU - 1695 : GCD</h2><blockquote><p>题目大意：$T$ 次询问，求$1 \leqslant x \leqslant b,1 \leqslant y \leqslant d$ 的所有$gcd(x,y)=k$ 的个数，$(x_0,y_0)$ 与$(y_0,x_0)$ 被视作一样。</p></blockquote><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>设$g(k)=\sum_{i=1}^b\sum_{j=1}^d[gcd(i,j)=k],f(n)=\sum_{n|k}g(k)$ </p><p>$f(n)$ 的意义为$gcd(i,j)$ 能被$n$ 整除的且符合条件的点对个数</p><p>设$n\leqslant m$ ，则$f(n)= \frac{ \lfloor \frac{b}{n} \rfloor (\lfloor \frac{b}{n} \rfloor+1)}{2}+ \lfloor \frac{b}{n} \rfloor(\lfloor \frac{d}{n} \rfloor-\lfloor \frac{b}{n} \rfloor)$ 。</p><p>故$g(n)=\sum_{n|k}u(\frac{k}{n})f(k)$ 代入即可求得。</p><p>复杂度$O(Tn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;<span class="hljs-keyword">int</span> p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,tot,u[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            p[tot++]=i;            u[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;tot&amp;&amp;i*p[j]&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                u[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> u[i*p[j]]=-u[i];        &#125;    &#125;&#125;ll T,a,b,c,d,k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    <span class="hljs-built_in">cin</span>&gt;&gt;T;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">1</span>;t&lt;=T;++t)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k;        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(!k)&#123;            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Case "</span>&lt;&lt;t&lt;&lt;<span class="hljs-string">": "</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">"\n"</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(b&gt;d)swap(b,d);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k;i&lt;=b;i+=k)&#123;            ll x=b/i,y=d/i;            ans+=u[i/k]*(x*(x+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+x*(y-x));        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Case "</span>&lt;&lt;t&lt;&lt;<span class="hljs-string">": "</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">"\n"</span>;    &#125;&#125;</code></pre><h2 id="CodeForces-235E-Number-Challenge"><a href="#CodeForces-235E-Number-Challenge" class="headerlink" title="CodeForces - 235E : Number Challenge"></a>CodeForces - 235E : Number Challenge</h2><blockquote><p>待更</p></blockquote><h2 id="BZOJ-2154-Crash的数字表格"><a href="#BZOJ-2154-Crash的数字表格" class="headerlink" title="BZOJ 2154: Crash的数字表格"></a>BZOJ 2154: Crash的数字表格</h2><blockquote><p>题目大意：求$\sum_{i=1}^n\sum_{j=1}^mlcm(i,j)$ 。</p></blockquote><h3 id="莫比乌斯反演-1"><a href="#莫比乌斯反演-1" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$$<br>f(n,m)=\sum_{i=1}^n\sum_{j=1}^m[i,j]<br>=\sum_{i=1}^n\sum_{j=1}^m\frac{i\times j}{(i,j)}\\<br>=\sum_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^m\frac{i\times j}{(i,j)}[(i,j)=d]\\<br>=\sum_{d=1}^{min(n,m)}\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i\times j\times d[(i,j)=1]\\<br>=\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i\times j[(i,j)=1]\\<br>$$</p><p>设$g(n,m)=\sum_{i=1}^n\sum_{j=1}^mi\times j[(i,j)=1]$ ，则有<br>$$<br>g(n,m)=\sum_{d=1}^{min(n,m)}u(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}i\times j\times d^2\\<br>=\sum_{d=1}^{min(n,m)}u(d)d^2\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}i\times j\\<br>=\sum_{d=1}^{min(n,m)}u(d)d^2\times \frac{(\lfloor \frac{n}{d} \rfloor+1)\lfloor \frac{n}{d} \rfloor}{2}\times \frac{(\lfloor \frac{m}{d} \rfloor+1)\lfloor \frac{m}{d} \rfloor}{2}\\<br>$$</p><p>$$<br>\therefore f(n,m)=\sum_{d=1}^{min(n,m)}d\times g(\lfloor \frac{n}{d}\rfloor,\lfloor \frac{m}{d}\rfloor)<br>$$</p><p>求$f(n,m)$ 和$g(n,m)$ 的复杂度均为$O(\sqrt{n})$ ，总复杂度为$O(n)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e7</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> P=<span class="hljs-number">20101009</span>;<span class="hljs-keyword">int</span> p[N],k,pre[N];<span class="hljs-keyword">char</span> mu[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">bool</span> vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            mu[i]=<span class="hljs-number">-1</span>;            p[k++]=i;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;p[j]*i&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                mu[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> mu[i*p[j]]=-mu[i];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)        pre[i]=((pre[i<span class="hljs-number">-1</span>]+(ll)mu[i]*i*i%P)%P+P)%P;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,d,td,len=Min(n,m);    <span class="hljs-keyword">for</span>(d=<span class="hljs-number">1</span>;d&lt;=len;d=td+<span class="hljs-number">1</span>)&#123;        td=Min(n/(n/d),m/(m/d));        ll temp=(((pre[td]-pre[d<span class="hljs-number">-1</span>])%P*((<span class="hljs-number">1L</span>L*(n/d+<span class="hljs-number">1</span>)*(n/d)/<span class="hljs-number">2</span>)%P))%P*((<span class="hljs-number">1L</span>L*(m/d+<span class="hljs-number">1</span>)*(m/d)/<span class="hljs-number">2</span>)%P))%P;        ans=((ans+temp)%P+P)%P;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,d,td,len=Min(n,m);    <span class="hljs-keyword">for</span>(d=<span class="hljs-number">1</span>;d&lt;=len;d=td+<span class="hljs-number">1</span>)&#123;        td=Min(n/(n/d),m/(m/d));        ll temp=<span class="hljs-number">1L</span>L*(td+d)*(td-d+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>%P*g(n/d,m/d)%P;        ans=((ans+temp)%P+P)%P;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,f(n,m));&#125;</code></pre><h2 id="BZOJ-3529-Sdoi2014-数表"><a href="#BZOJ-3529-Sdoi2014-数表" class="headerlink" title="BZOJ 3529: [Sdoi2014]数表"></a>BZOJ 3529: [Sdoi2014]数表</h2><blockquote><p>待更</p></blockquote><h2 id="BZOJ-2440-中山市选2011-完全平方数"><a href="#BZOJ-2440-中山市选2011-完全平方数" class="headerlink" title="BZOJ 2440: [中山市选2011]完全平方数"></a>BZOJ 2440: [中山市选2011]完全平方数</h2><blockquote><p>题目大意：求第$K$ 个非平方数的倍数的数。</p></blockquote><h3 id="二分-容斥-莫比乌斯函数"><a href="#二分-容斥-莫比乌斯函数" class="headerlink" title="二分+容斥+莫比乌斯函数"></a>二分+容斥+莫比乌斯函数</h3><p>做这题前学习了下容斥原理：</p><p>$|\bar{A_1} \cap \bar{A_2}\cap … \cap \bar{A_n}|=|S|-\sum|A_i|+\sum|A_i\cap A_j|+…+(-1)^n\sum|A_1\cap A_2 \cap … \cap A_n|$</p><p>设$f(n)$ 是$n$ 个素数平方的倍数的数的个数，那么$f(0)=|S|-f(1)+f(2)+…+(-1)^nf(n)$ </p><p>不难看出$f(x)$ 前的系数即为莫比乌斯函数$u(x)$ 。</p><p>于是二分第$K$ 个数$x$ ，检验$f(x)$ 是否等于$K$ 即可。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;ll p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k,mu[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            p[k++]=i;            mu[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;i*p[j]&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                mu[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;mu[i*p[j]]=-mu[i];        &#125;    &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(ll n)</span></span>&#123;    ll ans=n;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i*i&lt;=n;++i)        ans+=mu[i]*(n/(i*i));    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    ll T,n,l,r,mid;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);        l=<span class="hljs-number">1</span>,r=<span class="hljs-number">10000000000</span>;        <span class="hljs-keyword">while</span>(l&lt;r)&#123;            mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(check(mid)&lt;n)l=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> r=mid;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,l);    &#125;&#125;</code></pre><h2 id="BZOJ-2301-HAOI2011-Problem-b"><a href="#BZOJ-2301-HAOI2011-Problem-b" class="headerlink" title="BZOJ 2301: [HAOI2011]Problem b"></a>BZOJ 2301: [HAOI2011]Problem b</h2><blockquote><p>题目大意：$T$ 次询问，每次询问有多少数对$(x,y)$ 满足$a\leqslant x \leqslant b,c\leqslant y \leqslant d$ 且$gcd(x,y)=k$ </p></blockquote><h3 id="莫比乌斯反演-2"><a href="#莫比乌斯反演-2" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>和上面HDU 1695类似，可求$1 \leqslant x \leqslant n,1 \leqslant y \leqslant m$ 且$gcd(x,y)=k$ 的点对有$F(n,m,k)$ 个。</p><p>那么简单地容斥下，$a\leqslant x \leqslant b,c\leqslant y \leqslant d$ 且$gcd(x,y)=k$ 的点对就有$F(b,d,k)-F(a-1,d,k)-F(b,c-1,k)+F(a-1,c-1,k)$ 个。</p><p>然而这道题的数据范围更大，用之前的方法直接暴力求不可行，采用分块优化。</p><p>$\lfloor \frac{N}{d} \rfloor$ 的取值并不是连续的，其最多只有$2\lfloor \sqrt{N} \rfloor$ 种，同理$\lfloor \frac{M}{d} \rfloor$ 的取值最多$2\lfloor \sqrt{M} \rfloor$ 种。故$\lfloor \frac{N}{d} \rfloor$ 和$\lfloor \frac{M}{d} \rfloor$ 均相同的区间只有$2\lfloor \sqrt{N} \rfloor+2\lfloor \sqrt{M} \rfloor$ 个，所以$d$ 的枚举量其实是$O(\sqrt{N}+\sqrt{M})$ 的。</p><p>复杂度$O(T\sqrt{n})$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">50005</span>;ll p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,tot,u[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,pre[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            p[tot++]=i;            u[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;tot&amp;&amp;i*p[j]&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                u[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> u[i*p[j]]=-u[i];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)        pre[i]=pre[i<span class="hljs-number">-1</span>]+u[i];&#125;<span class="hljs-function">ll <span class="hljs-title">Min</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll a,ll b,ll k)</span></span>&#123;    <span class="hljs-keyword">if</span>(!k)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    ll ans=<span class="hljs-number">0</span>,l;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=Min(a,b);i=l+<span class="hljs-number">1</span>)&#123;        l=Min(a/(a/i),b/(b/i));        ans+=(pre[l]-pre[i<span class="hljs-number">-1</span>])*(a/i)*(b/i);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;ll T,a,b,c,d,k;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);        ll ans=solve(b/k,d/k,k)-solve((a<span class="hljs-number">-1</span>)/k,d/k,k)-solve(b/k,(c<span class="hljs-number">-1</span>)/k,k)+solve((a<span class="hljs-number">-1</span>)/k,(c<span class="hljs-number">-1</span>)/k,k);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;&#125;</code></pre><h2 id="HDU-4746-Mophues"><a href="#HDU-4746-Mophues" class="headerlink" title="HDU - 4746 : Mophues"></a>HDU - 4746 : Mophues</h2><blockquote><p>待更</p></blockquote><h2 id="HDU-5212-Code"><a href="#HDU-5212-Code" class="headerlink" title="HDU - 5212 : Code"></a>HDU - 5212 : Code</h2><blockquote><p>题目大意：求$f(n)=\sum_{i=1}^n\sum_{j=1}^n(a_i,a_j)[(a_i,a_j)-1]$ </p></blockquote><h3 id="莫比乌斯反演-3"><a href="#莫比乌斯反演-3" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$$<br>f(n)=\sum_{i=1}^n\sum_{j=1}^n(a_i,a_j)[(a_i,a_j)-1]\\<br>=\sum_{d=1}^nd(d-1)\sum_{i=1}^n\sum_{j=1}^n[(a_i,a_j)=d]\\<br>设g(n,m)=\sum_{i=1}^n\sum_{j=1}^n[(a_i,a_j)=m]\\<br>=\sum_{i=1}^n\sum_{j=1}^n[\frac{(a_i,a_j)}{m}=1]\\<br>=\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\frac{(a_i,a_j)}{m}}u(d)<br>$$</p><p>设$h(d)$ 表示能被$d$ 整除的数的个数，则<br>$$<br>g(n,m)=\sum_{d=1}^{\frac{max(a_i)}{m}}u(d)h^2(md)\\<br>f(n)=\sum_{d=1}^nd(d-1)\times g(n,d)<br>$$<br>复杂度$O(nlogn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">10005</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> P=<span class="hljs-number">10007</span>;ll p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k,mu[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;ll n,a[N],h[N],t;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            mu[i]=<span class="hljs-number">-1</span>;            p[k++]=i;        &#125;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;p[j]*i&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                mu[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> mu[i*p[j]]=-mu[i];        &#125;    &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">g</span><span class="hljs-params">(ll n,ll m)</span></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll d=<span class="hljs-number">1</span>;d&lt;=<span class="hljs-number">10000</span>/m;++d)        ans=(ans+mu[d]*h[m*d]*h[m*d])%P;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll n)</span></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll d=<span class="hljs-number">1</span>;d&lt;=<span class="hljs-number">10000</span>;++d)        ans=(ans+d*(d<span class="hljs-number">-1</span>)*g(n,d))%P;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;n))&#123;        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));        <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(h));        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;t);            a[t]++;        &#125;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;++i)            <span class="hljs-keyword">for</span>(ll j=i;j&lt;=<span class="hljs-number">10000</span>;j+=i)                h[i]=(h[i]+a[j])%P;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,(f(n)+P)%P);    &#125;&#125;</code></pre><h2 id="HDU-5321-Beautiful-Set"><a href="#HDU-5321-Beautiful-Set" class="headerlink" title="HDU - 5321 : Beautiful Set"></a>HDU - 5321 : Beautiful Set</h2><blockquote><p>待更</p></blockquote><h2 id="HDU-4947-GCD-Array"><a href="#HDU-4947-GCD-Array" class="headerlink" title="HDU - 4947 : GCD Array"></a>HDU - 4947 : GCD Array</h2><blockquote><p>待更</p></blockquote><h2 id="HDU-5663-Hillan-and-the-girl"><a href="#HDU-5663-Hillan-and-the-girl" class="headerlink" title="HDU - 5663 : Hillan and the girl"></a>HDU - 5663 : Hillan and the girl</h2><blockquote><p>待更</p></blockquote><h2 id="UESTC-811-GCD"><a href="#UESTC-811-GCD" class="headerlink" title="UESTC - 811 : GCD"></a>UESTC - 811 : GCD</h2><blockquote><p>待更</p></blockquote><h2 id="HDU-5656-CA-Loves-GCD"><a href="#HDU-5656-CA-Loves-GCD" class="headerlink" title="HDU - 5656 : CA Loves GCD"></a>HDU - 5656 : CA Loves GCD</h2><blockquote><p>待更</p></blockquote><h2 id="ACdream-1114-Number-theory"><a href="#ACdream-1114-Number-theory" class="headerlink" title="ACdream - 1114 : Number theory"></a>ACdream - 1114 : Number theory</h2><blockquote><p>题目大意：给出$n$ 个数，问满足$gcd(a_i,a_j)=1$ 且$i&lt;j$ 的点对有多少个。</p></blockquote><h3 id="莫比乌斯反演-4"><a href="#莫比乌斯反演-4" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$$<br>f(n)=\sum_{i=1}^n\sum_{j=1}^n[(a_i,a_j)=1]\\<br>f(n)=\sum_{i=1}^n\sum_{j=1}^n\sum_{d|(a_i,a_j)}u(d)<br>$$</p><p>设$g(d)$ 表示能被$d$ 整除的数的个数，则有<br>$$<br>f(n)=\sum_{d=1}^{max(a_i)}u(d)g^2(d)<br>$$<br>复杂度$O(nlogn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">222222</span>+<span class="hljs-number">5</span>;ll p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k,mu[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            p[k++]=i;            mu[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;p[j]*i&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                mu[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> mu[i*p[j]]=-mu[i];        &#125;    &#125;&#125;ll n,a[N],d[N],t;<span class="hljs-function">ll <span class="hljs-title">Max</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll n)</span></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;++i)        ans+=mu[i]*d[i];    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n))&#123;        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));        ll mx=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;t);            mx=Max(mx,t);            a[t]++;        &#125;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=mx;++i)            <span class="hljs-keyword">for</span>(ll j=i;j&lt;=mx;j+=i)                d[i]+=a[j];        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=mx;++i)            d[i]=d[i]*(d[i]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(mx));    &#125;&#125;</code></pre><h2 id="HDU-5468-Puzzled-Elena"><a href="#HDU-5468-Puzzled-Elena" class="headerlink" title="HDU - 5468 : Puzzled Elena"></a>HDU - 5468 : Puzzled Elena</h2><blockquote><p>待更</p></blockquote><h2 id="HDU-2841-Visible-Trees"><a href="#HDU-2841-Visible-Trees" class="headerlink" title="HDU - 2841 :  Visible Trees"></a>HDU - 2841 :  Visible Trees</h2><blockquote><p>题目大意：问从$(0,0)$ 点看第一象限$n \times m$ 范围，最多能看到几个点。</p></blockquote><h3 id="莫比乌斯反演-5"><a href="#莫比乌斯反演-5" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$$<br>f(n,m)=\sum_{i=1}^n\sum_{j=1}^m[(i,j=1)]\\<br>f(n,m)=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|(i,j)}u(d)\\<br>f(n,m)=\sum_{d=1}^{min(n,m)}u(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}1\\<br>$$</p><p>分块优化后复杂度为$O(\sqrt{n})$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;ll T,n,m,p[N],vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k,mu[N]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,pu[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            p[k++]=i;            mu[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;i*p[j]&lt;n;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;                mu[i*p[j]]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span> mu[i*p[j]]=-mu[i];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)        pu[i]=pu[i<span class="hljs-number">-1</span>]+mu[i];&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll n,ll m)</span></span>&#123;    ll ans=<span class="hljs-number">0</span>,len=<span class="hljs-built_in">min</span>(n,m);    <span class="hljs-keyword">for</span>(ll d=<span class="hljs-number">1</span>;d&lt;=len;)&#123;        ll td=<span class="hljs-built_in">min</span>(n/(n/d),m/(m/d));        ans+=(pu[td]-pu[d<span class="hljs-number">-1</span>])*(n/d)*(m/d);        d=td+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(N);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d%I64d"</span>,&amp;n,&amp;m);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,solve(n,m));    &#125;&#125;</code></pre><h2 id="POJ-3904-Sky-Code"><a href="#POJ-3904-Sky-Code" class="headerlink" title="POJ - 3904 : Sky Code"></a>POJ - 3904 : Sky Code</h2><blockquote><p>待更</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>莫比乌斯反演</tag>
      
      <tag>数论</tag>
      
      <tag>容斥</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6128 Inverse of sum(2017 Multi-University Training Contest - Team 7)</title>
    <link href="/2017/08/16/HDU%206128%20Inverse%20of%20sum(2017%20Multi-University%20Training%20Contest%20-%20Team%207)/"/>
    <url>/2017/08/16/HDU%206128%20Inverse%20of%20sum(2017%20Multi-University%20Training%20Contest%20-%20Team%207)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6128" target="_blank" rel="noopener">HDU 6128 : Inverse of sum</a></p><a id="more"></a><blockquote><p>题目大意：有$n$ 个小于质数$p$ 的非负整数$a_i$ ，你想知道有多少对$i,j(1 \leqslant i&lt;j\leqslant n)$ ，使得模$p$ 意义下$\frac{1}{a_i+a_j} \equiv \frac{1}{a_i}+\frac{1}{a_j}$ ，即这两数的和的逆元等于它们逆元的和，注意零元没有逆元。</p></blockquote><h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><p>$$<br>(a+b)^{-1} \equiv a^{-1}+b^{-1}(mod , p)\\<br>1 \equiv (a+b)(a^{-1}+b^{-1})(mod , p)\\<br>a^{-1}b+ab^{-1}+1 \equiv 0(mod , p)\\<br>a^2+b^2+ab\equiv 0 (mod , p)\\<br>(ab^{-1})^2+(ab^{-1})+1\equiv 0 (mod , p)\\<br>ab^{-1}\equiv \frac{-1\pm\sqrt{-3}}{2}(mod , p)<br>$$</p><p>故原式等价于模$p$ 意义下，两数之比为$\frac{-1\pm\sqrt{-3}}{2}$ ，根号可以用二次剩余解决。</p><p>下面分类考虑几种情况：</p><ul><li>$p=2$ ，此时可以直接求得$-3$ 的二次剩余是$1$ </li><li>$(\frac{-3}{p})=1$ ，套用上述公式遍历一遍数组可求得</li><li>$(\frac{-3}{p})=-1$ ，即$-3$ 在模$p$ 下不存在二次剩余，故不存在满足条件的对</li><li>$(\frac{-3}{p})=0$ ，即$p|-3$ ，此时$\sqrt{-3} \equiv 0 (mod , p)$ </li></ul><p>需要注意的是，此题会出现long long相乘溢出的情况，可以用快速乘处理。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">100005</span>;ll T,n,p,w,a[N];<span class="hljs-built_in">map</span>&lt;ll,ll&gt;mp;<span class="hljs-function">ll <span class="hljs-title">Min</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<span class="hljs-function">ll <span class="hljs-title">Mul</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    ll r=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(b)&#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)r=(r+a)%p;        a=(a+a)%p;        b&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Complex</span>&#123;</span>    ll x,y;    Complex <span class="hljs-keyword">friend</span> <span class="hljs-keyword">operator</span>*(Complex x,Complex y)&#123;        Complex z;        z.x=(Mul(x.x,y.x)+Mul(Mul(x.y,y.y),w))%p;        z.y=(Mul(x.y,y.x)+Mul(x.x,y.y))%p;        <span class="hljs-keyword">return</span> z;    &#125;&#125;;<span class="hljs-function">ll <span class="hljs-title">powmod</span><span class="hljs-params">(ll a,ll n)</span></span>&#123;    ll r=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(n)&#123;        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)r=Mul(r,a);        a=Mul(a,a);        n&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function">ll <span class="hljs-title">ComPow</span><span class="hljs-params">(Complex a,ll n)</span></span>&#123;    Complex r;    r.x=<span class="hljs-number">1</span>;r.y=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n)&#123;        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)r=r*a;        a=a*a;        n&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> Min(r.x%p,(p-r.x%p)%p);&#125;<span class="hljs-function">ll <span class="hljs-title">Cipolla</span><span class="hljs-params">(ll a,ll p)</span></span>&#123;    ll x=rand()%p;    <span class="hljs-keyword">while</span>(powmod((Mul(x,x)-a+p)%p,(p<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)!=p<span class="hljs-number">-1</span>)        x=rand()%p;    w=(Mul(x,x)-a+p)%p;    Complex t;    t.x=x;t.y=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> ComPow(t,(p+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll rd,ll p)</span></span>&#123;    mp.<span class="hljs-built_in">clear</span>();    ll ans=<span class="hljs-number">0</span>;    ll x=Mul(((<span class="hljs-number">-1</span>+rd)%p+p)%p,powmod(<span class="hljs-number">2</span>,p<span class="hljs-number">-2</span>));    ll y=Mul(((<span class="hljs-number">-1</span>-rd)%p+p)%p,powmod(<span class="hljs-number">2</span>,p<span class="hljs-number">-2</span>));    <span class="hljs-keyword">if</span>(x==y)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<span class="hljs-keyword">if</span>(a[i]%p)&#123;            ll b=Mul(a[i],x);            <span class="hljs-keyword">if</span>(mp.count(b))ans+=mp[b];            mp[a[i]%p]++;        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<span class="hljs-keyword">if</span>(a[i]%p)&#123;            ll bx=Mul(a[i],x),by=Mul(a[i],y);            <span class="hljs-keyword">if</span>(mp.count(bx))ans+=mp[bx];            <span class="hljs-keyword">if</span>(mp.count(by))ans+=mp[by];            mp[a[i]%p]++;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;T;    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;p;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)            <span class="hljs-built_in">cin</span>&gt;&gt;a[i];        ll ans;        <span class="hljs-keyword">if</span>(p==<span class="hljs-number">2</span>)&#123;            ans=solve(<span class="hljs-number">1</span>,p);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(powmod(p<span class="hljs-number">-3</span>,(p<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)==<span class="hljs-number">1</span>)&#123;            ll rd=Cipolla(p<span class="hljs-number">-3</span>,p);            ans=solve(rd,p);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(powmod(p<span class="hljs-number">-3</span>,(p<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)==<span class="hljs-number">0</span>)&#123;            ans=solve(<span class="hljs-number">0</span>,p);        &#125;<span class="hljs-keyword">else</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">"\n"</span>;    &#125;&#125;</code></pre><h3 id="立方公式"><a href="#立方公式" class="headerlink" title="立方公式"></a>立方公式</h3><p>除了用二次剩余还有另一种更优雅的解法。<br>$$<br>(a+b)^{-1} \equiv a^{-1}+b^{-1}(mod , p)\\<br>1 \equiv (a+b)(a^{-1}+b^{-1})(mod , p)\\<br>a^{-1}b+ab^{-1}+1 \equiv 0(mod , p)\\<br>a^2+b^2+ab\equiv 0 (mod , p)\\<br>$$<br>当$a-b \not \equiv 0 (mod , p)$ 时，可以在上述等式两边同乘上$a-b$ ，得到<br>$$<br>(a-b)(a^2+ab+b^2)\equiv 0 (mod ,p)\\<br>a^3-b^3\equiv0(mod , p)<br>$$<br>如此只需记录当$a \not\equiv b(mod ,p)$ 时，所有满足$a^3-b^3\equiv 0 (mod ,p)$ 的对数即可。</p><p><a href="http://www.cnblogs.com/bin-gege/p/7367337.html" target="_blank" rel="noopener">查看代码</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>二次剩余</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProjectEuler</title>
    <link href="/2017/07/20/ProjectEuler/"/>
    <url>/2017/07/20/ProjectEuler/</url>
    
    <content type="html"><![CDATA[<p>记录下Project Euler上的一些题。</p><a id="more"></a><h2 id="Problem-59-XOR-decryption"><a href="#Problem-59-XOR-decryption" class="headerlink" title="Problem 59 : XOR decryption"></a>Problem 59 : XOR decryption</h2><blockquote><p><a href="https://projecteuler.net/problem=59" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>枚举key的三个字母对密文进行解密。</p><p>猜测原文中空格字符应占最多，故可筛选出若干个文本，人工识别即可。</p><p>find_the_key：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10000</span>],k,maxspace;<span class="hljs-keyword">char</span> ch;<span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> q)</span></span>&#123;    <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;t&lt;=k;)&#123;        <span class="hljs-keyword">if</span>(++t&lt;=k&amp;&amp;(a[t<span class="hljs-number">-1</span>]^i)==<span class="hljs-string">' '</span>)temp++;        <span class="hljs-keyword">if</span>(++t&lt;=k&amp;&amp;(a[t<span class="hljs-number">-1</span>]^j)==<span class="hljs-string">' '</span>)temp++;        <span class="hljs-keyword">if</span>(++t&lt;=k&amp;&amp;(a[t<span class="hljs-number">-1</span>]^q)==<span class="hljs-string">' '</span>)temp++;    &#125;    <span class="hljs-keyword">if</span>(temp&gt;=maxspace)&#123;        maxspace=temp;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"========================================\n"</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;t&lt;=k;)&#123;        <span class="hljs-keyword">if</span>(++t&lt;=k)<span class="hljs-built_in">putchar</span>(a[t<span class="hljs-number">-1</span>]^i);        <span class="hljs-keyword">if</span>(++t&lt;=k)<span class="hljs-built_in">putchar</span>(a[t<span class="hljs-number">-1</span>]^j);        <span class="hljs-keyword">if</span>(++t&lt;=k)<span class="hljs-built_in">putchar</span>(a[t<span class="hljs-number">-1</span>]^q);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    freopen(<span class="hljs-string">"p059_cipher.txt"</span>,<span class="hljs-string">"r"</span>,<span class="hljs-built_in">stdin</span>);    freopen(<span class="hljs-string">"output.txt"</span>,<span class="hljs-string">"w"</span>,<span class="hljs-built_in">stdout</span>);    <span class="hljs-keyword">for</span>(;~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%c"</span>,&amp;a[k],&amp;ch);++k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-string">'a'</span>;i&lt;=<span class="hljs-string">'z'</span>;++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-string">'a'</span>;j&lt;=<span class="hljs-string">'z'</span>;++j)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-string">'a'</span>;q&lt;=<span class="hljs-string">'z'</span>;++q)                decrypt(i,j,q);&#125;</code></pre><p>get_answer:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> a[]=<span class="hljs-string">"(The Gospel of John, chapter 1) 1 In the beginning the Word already existed. He was with God, and he was God. 2 He was in the beginning with God. 3 He created everything there is. Nothing exists that he didn't make. 4 Life itself was in him, and this life gives light to everyone. 5 The light shines through the darkness, and the darkness can never extinguish it. 6 God sent John the Baptist 7 to tell everyone about the light so that everyone might believe because of his testimony. 8 John himself was not the light; he was only a witness to the light. 9 The one who is the true light, who gives light to everyone, was going to come into the world. 10 But although the world was made through him, the world didn't recognize him when he came. 11 Even in his own land and among his own people, he was not accepted. 12 But to all who believed him and accepted him, he gave the right to become children of God. 13 They are reborn! This is not a physical birth resulting from human passion or plan, this rebirth comes from God.14 So the Word became human and lived here on earth among us. He was full of unfailing love and faithfulness. And we have seen his glory, the glory of the only Son of the Father."</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,len=<span class="hljs-built_in">strlen</span>(a);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)sum+=a[i];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,sum);&#125;</code></pre><h2 id="Problem-69-Totient-maximum"><a href="#Problem-69-Totient-maximum" class="headerlink" title="Problem 69 : Totient maximum"></a>Problem 69 : Totient maximum</h2><blockquote><p><a href="https://projecteuler.net/problem=69" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>若$n=\prod_{i=0}^s p_i^{e_i}$是$n$的标准分解式，那么$\varphi (n)=n\prod_{i=0}^s (1-\frac{1}{p_i})$.于是$\frac{n}{\varphi (n)}=\frac{1}{\prod_{i=0}^s (1-\frac{1}{p_i})}$.</p><p>而$p_i$是递增的，故每次贪心取最小的$p_i$可以得到最优解，故$n$为满足$n=\prod_{i=0}^t p_i \leqslant 1000,000$的最大的$n$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">bool</span> vis[N];<span class="hljs-keyword">int</span> p[N],k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prime</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100000</span>;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])p[k++]=i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;i*p[j]&lt;=<span class="hljs-number">100000</span>;++j)&#123;            vis[i*p[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    prime();    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k&amp;&amp;ans*p[i]&lt;=<span class="hljs-number">1000000</span>;++i)ans*=p[i];    <span class="hljs-built_in">cout</span>&lt;&lt;ans;&#125;</code></pre><h2 id="Problem-71-Ordered-fractions"><a href="#Problem-71-Ordered-fractions" class="headerlink" title="Problem 71 : Ordered fractions"></a>Problem 71 : Ordered fractions</h2><blockquote><p><a href="https://projecteuler.net/problem=71" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="法里数列"><a href="#法里数列" class="headerlink" title="法里数列"></a><a href="https://zh.wikipedia.org/zh-hans/**法里數列**" target="_blank" rel="noopener">法里数列</a></h3><p>$n$阶法里数列是$0$和$1$之间最简分数的数列，由小至大排列，每个分数的分母不大于$n$。</p><p>设$F_n$为$n$阶法里数列，则有如下性质：</p><ul><li>$|F_n|=|F_{n-1}|+\varphi (n)$.</li></ul><p>因为$F_n$仅比$F_{n-1}$多了$E={\frac{p}{n}:(p,n)=1}$，其中$|E|=\varphi (n)$。由$|F_1|=2，$可推出$|F_n|=1+\sum_{i=1}^n \varphi(n)$.</p><ul><li>若$\frac{a}{b}$和$\frac{c}{d}$是某$k$阶法里数列的相邻项，且$\frac{a}{b} &lt; \frac{c}{d}$，则它们之差为$\frac{1}{bd}$，也就是说$bc-ad=1$。反之同样成立：若$\frac{a}{b}$，$\frac{c}{d}$均为真分数，且$\frac{a}{b} &lt; \frac{c}{d}$，$bc-ad=1$，则有$\frac{a}{b}$和$\frac{c}{d}$在$k$阶法里数列中是邻项，$k=max{b,d}$.</li><li>若$\frac{a}{b}$和$\frac{c}{d}$是某$k$阶法里数列的相邻项，随着$k$增大，$\frac{a}{b}$和$\frac{c}{d}$间出现的第一项为$\frac{a+c}{b+d}$.</li></ul><p>这里用到了法里数列的第三条性质。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> a=<span class="hljs-number">2</span>,b=<span class="hljs-number">5</span>;    <span class="hljs-keyword">while</span>(b+<span class="hljs-number">7</span>&lt;=<span class="hljs-number">1000000</span>)&#123;        a+=<span class="hljs-number">3</span>;        b+=<span class="hljs-number">7</span>;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;a;&#125;</code></pre><h2 id="Problem-77-Prime-summations"><a href="#Problem-77-Prime-summations" class="headerlink" title="Problem 77 : Prime summations"></a>Problem 77 : Prime summations</h2><blockquote><p><a href="https://projecteuler.net/problem=77" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="二分-完全背包计数"><a href="#二分-完全背包计数" class="headerlink" title="二分+完全背包计数"></a>二分+完全背包计数</h3><p>设$n$的分解式的个数为$f(n)$，不难证明$f(n)$为单调函数，故若能较快求出$f(n)$则可用二分解.</p><p>直接分解求分解式的个数并不是很容易，考虑小于等于$n$的素数组合成$n$有多少种方案，于是问题就成了完全背包计数问题，求$f(n)$的复杂度为$O(\frac{n^2}{logn})$.</p><p>总复杂度为$O(n^2)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">bool</span> vis[N];<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll p[N],k,dp[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prime</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;N;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])p[k++]=i;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;p[j]*i&lt;N;++j)&#123;            vis[p[j]*i]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;k&amp;&amp;p[i]&lt;=n;++i)        <span class="hljs-keyword">for</span>(ll j=p[i];j&lt;=n;++j)            dp[j]+=dp[j-p[i]];    <span class="hljs-keyword">return</span> dp[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    prime();    ll l=<span class="hljs-number">1</span>,r=<span class="hljs-number">500</span>;    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;        ll mid=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(check(mid)&gt;<span class="hljs-number">5000</span>)r=mid<span class="hljs-number">-1</span>;        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;l;&#125;</code></pre><h2 id="Problem-79-Passcode-derivation"><a href="#Problem-79-Passcode-derivation" class="headerlink" title="Problem 79 : Passcode derivation"></a>Problem 79 : Passcode derivation</h2><blockquote><p><a href="https://projecteuler.net/problem=79" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>将所有keylog（abc）按a-&gt;b-&gt;c建图（由文本文件可知不存在自环），进行拓扑排序。</p><p>注意到可能成环，故先枚举第一个数，测试得第一个数是7时，符合条件的字符串最短。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> x,y,z,deg[<span class="hljs-number">10</span>],k,idx,vis[<span class="hljs-number">10</span>];<span class="hljs-keyword">char</span> ans[<span class="hljs-number">20</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;e[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    freopen(<span class="hljs-string">"p079_keylog.txt"</span>,<span class="hljs-string">"r"</span>,<span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%1d%1d%1d"</span>,&amp;x,&amp;y,&amp;z))&#123;        vis[x]=vis[y]=vis[z]=<span class="hljs-number">1</span>;        deg[y]++;deg[z]++;        e[x].push_back(y);        e[y].push_back(z);    &#125;    freopen(<span class="hljs-string">"CON"</span>,<span class="hljs-string">"r"</span>,<span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">for</span>(idx=<span class="hljs-number">0</span>;idx&lt;<span class="hljs-number">10</span>;++idx)            <span class="hljs-keyword">if</span>(deg[idx]==<span class="hljs-number">0</span>&amp;&amp;vis[idx])                <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(idx&gt;=<span class="hljs-number">10</span>)<span class="hljs-keyword">break</span>;        ans[k++]=idx+<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)e[idx].<span class="hljs-built_in">size</span>();++i)            deg[e[idx][i]]--;        vis[idx]=<span class="hljs-number">0</span>;    &#125;    ans[k]=<span class="hljs-string">'\0'</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,ans);&#125;</code></pre><h2 id="Problem-122-Efficient-exponentiation"><a href="#Problem-122-Efficient-exponentiation" class="headerlink" title="Problem 122 : Efficient exponentiation"></a>Problem 122 : Efficient exponentiation</h2><blockquote><p><a href="https://projecteuler.net/problem=122" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>由快速幂的做法先确定$m(x)$的上界，直接DFS。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">201</span>],path[<span class="hljs-number">15</span>]=&#123;<span class="hljs-number">1</span>&#125;,ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i)&#123;        <span class="hljs-keyword">int</span> temp=i;        <span class="hljs-keyword">while</span>(temp!=<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(temp&amp;<span class="hljs-number">1</span>)a[i]++;            temp&gt;&gt;=<span class="hljs-number">1</span>;            a[i]++;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-keyword">if</span>(path[k]&gt;<span class="hljs-number">200</span>||a[path[k]]&lt;k)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(a[path[k]]&gt;k)a[path[k]]=k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;++i)&#123;        path[k+<span class="hljs-number">1</span>]=path[k]+path[i];        dfs(k+<span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init();    dfs(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">200</span>;++i)ans+=a[i];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;</code></pre><h2 id="Problem-123-Prime-square-remainders"><a href="#Problem-123-Prime-square-remainders" class="headerlink" title="Problem 123 : Prime square remainders"></a>Problem 123 : Prime square remainders</h2><blockquote><p><a href="https://projecteuler.net/problem=123" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>$$<br>\begin{eqnarray}<br> (p_n-1)^n+(p_n+1)^n \equiv (-1)^n+(-1)^{n-1}np+1+np(mod , p_n^2)\<br>\end{eqnarray}<br>$$</p><p>故$n$ 为奇数，化简得：<br>$$<br>\begin{eqnarray}<br> (p_n-1)^n+(p_n+1)^n \equiv 2np(mod , p_n^2)\<br>\end{eqnarray}<br>$$<br>接下来枚举一下就好了，复杂度$O(n)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll n=<span class="hljs-number">3</span>,prime[<span class="hljs-number">1000000</span>],isprime[<span class="hljs-number">1000000</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(!isprime[i])prime[k++]=i;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;prime[j]*i&lt;n;++j)&#123;            isprime[i*prime[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init(<span class="hljs-number">1000000</span>);    <span class="hljs-keyword">while</span>(n&lt;<span class="hljs-number">1000000</span>&amp;&amp;(<span class="hljs-number">2</span>*n*prime[n<span class="hljs-number">-1</span>]%(prime[n<span class="hljs-number">-1</span>]*prime[n<span class="hljs-number">-1</span>]))&lt;=<span class="hljs-number">1e10</span>)n+=<span class="hljs-number">2</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;n;&#125;</code></pre><h2 id="Problem-131-Prime-cube-partnership"><a href="#Problem-131-Prime-cube-partnership" class="headerlink" title="Problem 131 : Prime cube partnership"></a>Problem 131 : Prime cube partnership</h2><blockquote><p><a href="https://projecteuler.net/problem=131" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><p>$\because n^3+n^2p=n^2(n+p)=m^3$</p><p>$\therefore n^2$ 和$n+p$ 均为立方数时，上式成立</p><p>设$x^3=n+p,y^3=n$ ，</p><p>$\therefore p=x^3-y^3=(x-y)(x^2+xy+y^2)$</p><p>$\because p$ 是素数</p><p>$\therefore x-y=1$</p><p>接下来枚举$n$ 即可。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll n=<span class="hljs-number">2</span>,ans;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(ll p)</span></span>&#123;    <span class="hljs-keyword">if</span>(p&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i*i&lt;=p;++i)<span class="hljs-keyword">if</span>(p%i==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">cube</span><span class="hljs-params">(ll n)</span></span>&#123;    <span class="hljs-keyword">return</span> n*n*n;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">while</span>(cube(n)-cube(n<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">1e6</span>)&#123;        <span class="hljs-keyword">if</span>(isprime(cube(n)-cube(n<span class="hljs-number">-1</span>)))            ans++;        n++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;ans;&#125;</code></pre><h2 id="Problem-182-RSA-encryption"><a href="#Problem-182-RSA-encryption" class="headerlink" title="Problem 182 : RSA encryption"></a>Problem 182 : RSA encryption</h2><blockquote><p><a href="https://projecteuler.net/problem=182" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="数论-1"><a href="#数论-1" class="headerlink" title="数论"></a>数论</h3><p>首先考虑对于一个确定的$e$ ，有多少个$x$ 满足$x^e \equiv x(mod , p)$ ，其中$p$ 为一个素数。</p><p>显然有两种情况：</p><ul><li>当$x \equiv 0 (mod , p)$ 时，上述式子成立</li><li>当$x \not\equiv 0(mod , p)$ 时，上述式子等价于$x^{e-1} \equiv 1(mod , p)$ </li></ul><p>我们看第二种情况，因为$p$ 为素数，故一定存在原根$r$ ，令$x=r^t$ 。</p><p>上述式子可以表示为$r^{t(e-1)} \equiv 1(mod , p)$ 。</p><p>由原根的性质，可以得到$ord(r^{(e-1)})=\frac{\varphi(p)}{gcd(\varphi(p),e-1)}$ 。</p><p>故$t$ 在$N_p^*$ 中，有$\frac{\varphi(p)}{ord(r^{(e-1)})}=gcd(p-1,e-1)$ 种不同的取值。</p><p>综上所述，对于一个$e$ ，有$gcd(p-1,e-1)+1$ 个$x$ 满足$x^e\equiv x(mod , p)$ 。</p><p>接下来设$m \equiv x (mod , p) ,m \equiv y (mod , q), n=p \times q$ ，</p><p>则$m^eq \equiv mq (mod , n)$ ，$m^ep \equiv mp (mod , n)$ ，</p><p>所以$m^e(q-p) \equiv m(q-p) (mod , n)$ ，即$m^e \equiv m (mod , n)$ 。</p><p>由中国剩余定理可知，$m \equiv x (mod , p) ,m \equiv y (mod , q)$唯一确定一个$m \equiv qxq^{-1}+pyp^{-1} (mod , n)$ 。</p><p>故对于一个$e$ ，有$[gcd(p-1,e-1)+1]\times [gcd(q-1,e-1)+1]$ 个$m$ 满足$m^e \equiv m(mod ,n)$ 。</p><p>知道这个结论后，遍历一遍$e$ 即可得到答案，复杂度为$O(nlogn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll inf=<span class="hljs-number">100000000000</span>;ll p=<span class="hljs-number">1009</span>,q=<span class="hljs-number">3643</span>,e[<span class="hljs-number">4000000</span>];ll n=q*p,f=(p<span class="hljs-number">-1</span>)*(q<span class="hljs-number">-1</span>),minx=inf,ans;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125;<span class="hljs-function">ll <span class="hljs-title">Min</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;f;++i)<span class="hljs-keyword">if</span>(gcd(i,f)==<span class="hljs-number">1</span>)&#123;        e[i]=(gcd(i<span class="hljs-number">-1</span>,p<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>)*(gcd(i<span class="hljs-number">-1</span>,q<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>);        minx=Min(minx,e[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;f;++i)<span class="hljs-keyword">if</span>(e[i]==minx)        ans+=i;    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">"\n"</span>;&#125;</code></pre><h2 id="Problem-250-250250"><a href="#Problem-250-250250" class="headerlink" title="Problem 250 : 250250"></a>Problem 250 : 250250</h2><blockquote><p><a href="https://projecteuler.net/problem=250" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><p>预处理$1^1,2^2,3^3,…,250250^{250250}$ 模$250$ 后的值，做01背包即可。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll N=<span class="hljs-number">250250</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> ll p=<span class="hljs-number">250</span>;<span class="hljs-keyword">const</span> ll q=<span class="hljs-number">1e16</span>;ll a[N],dp[N][<span class="hljs-number">250</span>];<span class="hljs-function">ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> a*b%p;&#125;<span class="hljs-function">ll <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> (a+b)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">powmod</span><span class="hljs-params">(ll a,ll n)</span></span>&#123;    ll r=<span class="hljs-number">1</span>;a%=p;    <span class="hljs-keyword">while</span>(n)&#123;        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)r=mul(a,r);        a=mul(a,a);        n&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">250250</span>;++i)        a[i]=powmod(i,i);    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">250250</span>;++i)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">250</span>;++j)<span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j])&#123;            dp[i][add(j,a[i])]=(dp[i][add(j,a[i])]+dp[i<span class="hljs-number">-1</span>][j])%q;            dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j])%q;        &#125;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;(dp[<span class="hljs-number">250250</span>][<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>+q)%q;&#125;</code></pre><h2 id="Problem-531-Chinese-leftovers"><a href="#Problem-531-Chinese-leftovers" class="headerlink" title="Problem 531 : Chinese leftovers"></a>Problem 531 : Chinese leftovers</h2><blockquote><p><a href="https://projecteuler.net/problem=531" target="_blank" rel="noopener">题目链接</a></p></blockquote><h3 id="数论-2"><a href="#数论-2" class="headerlink" title="数论"></a>数论</h3><p>对于一个同余方程：<br>$$<br>\begin{cases}<br>x \equiv a_1(mod , n_1)\\<br>x \equiv a_2(mod , n_2)<br>\end{cases}\\<br>\begin{eqnarray}<br>&amp;&amp;\therefore x=a_1+k_1n_1=a_2+k_2n_2\\<br>&amp;&amp;\therefore a_1-a_2 \equiv k_2n_2(mod , n_1)<br>\end{eqnarray}<br>$$<br>设$g=gcd(n_1,n_2)$ ，可以得到若方程有解，则$g|(a_1-a_2)$ 必成立；其逆否命题成立。<br>$$<br>\begin{eqnarray}<br>&amp;&amp;\therefore \frac{a_1-a_2}{g} \equiv k_2 \frac{n_2}{g}(mod , \frac{n_1}{g})\\<br>&amp;&amp;\therefore k_2 \equiv \frac{a_1-a_2}{g} (\frac{n_2}{g})^{-1}(mod , \frac{n_1}{g})\\<br>&amp;&amp;\therefore k_2n_2 \equiv \frac{a_1-a_2}{g} (\frac{n_2}{g})^{-1}n_2(mod \frac{n_1n_2}{g})\\<br>&amp;&amp;\therefore x \equiv a_2+k_2n_2 \equiv a_2+\frac{a_1-a_2}{g} (\frac{n_2}{g})^{-1}n_2(mod \frac{n_1n_2}{g})<br>\end{eqnarray}<br>$$<br>复杂度$O(n^2logn)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> prime[<span class="hljs-number">1005005</span>],k,isprime[<span class="hljs-number">1005005</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,phi[<span class="hljs-number">1005005</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125;<span class="hljs-function">ll <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b,ll p)</span></span>&#123;<span class="hljs-keyword">return</span> (a+b)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">mul</span><span class="hljs-params">(ll a,ll b,ll p)</span></span>&#123;<span class="hljs-keyword">return</span> (a*b)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">powmod</span><span class="hljs-params">(ll a,ll n,ll p)</span></span>&#123;  ll r=<span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span>(n)&#123;    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)r=mul(r,a,p);    a=mul(a,a,p);    n&gt;&gt;=<span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a,ll n)</span></span>&#123;  <span class="hljs-keyword">return</span> powmod(a,phi[n]<span class="hljs-number">-1</span>,n);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;    <span class="hljs-keyword">if</span>(!isprime[i])&#123;      phi[i]=i<span class="hljs-number">-1</span>;      prime[k++]=i;    &#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;prime[j]*i&lt;=n;++j)&#123;      isprime[prime[j]*i]=<span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;        phi[prime[j]*i]=phi[i]*prime[j];        <span class="hljs-keyword">break</span>;      &#125;<span class="hljs-keyword">else</span> phi[prime[j]*i]=phi[i]*(prime[j]<span class="hljs-number">-1</span>);    &#125;  &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll n,ll m)</span></span>&#123;  <span class="hljs-keyword">if</span>(phi[n]&lt;phi[m])swap(n,m);  ll g=gcd(n,m),a1=phi[n],a2=phi[m];  <span class="hljs-keyword">if</span>((a1-a2)%g)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  ll k2=mul((a1-a2)/g%(n/g),inv(m/g,n/g),n/g);  <span class="hljs-keyword">return</span> add(k2*m,a2,n*m/g);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  init(<span class="hljs-number">1005000</span>);  ll ans=<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1000000</span>;i&lt;<span class="hljs-number">1005000</span>;++i)    <span class="hljs-keyword">for</span>(ll j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">1005000</span>;++j)      ans+=solve(i,j);  <span class="hljs-built_in">cout</span>&lt;&lt;ans;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CodeM美团点评编程大赛初赛A轮</title>
    <link href="/2017/06/21/CodeM%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9BA%E8%BD%AE/"/>
    <url>/2017/06/21/CodeM%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9BA%E8%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/test/question/3f8c8d5131fa4ebe8de31b7dbc015cde?pid=5523985&tid=8799405" target="_blank" rel="noopener">A.倒水</a></p><p><a href="https://www.nowcoder.com/question/next?pid=5523985&qid=105011&tid=8799405" target="_blank" rel="noopener">B.二分图染色(弱化版)</a></p><p><a href="https://www.nowcoder.com/question/next?pid=5523985&qid=105012&tid=8799405" target="_blank" rel="noopener">C.合并回文子串</a></p><p><a href="https://www.nowcoder.com/question/next?pid=5523985&qid=105013&tid=8799405" target="_blank" rel="noopener">D.身体训练</a></p><p><a href="https://www.nowcoder.com/question/next?pid=5523985&qid=105014&tid=8799405" target="_blank" rel="noopener">E.数列互质</a></p><p><a href="https://www.nowcoder.com/question/next?pid=5523985&qid=105015&tid=8799405" target="_blank" rel="noopener">F.最长树链</a></p><a id="more"></a><h2 id="A-倒水"><a href="#A-倒水" class="headerlink" title="A.倒水"></a>A.倒水</h2><blockquote><p>有一个大水缸，里面水的温度为T单位，体积为C升。另有n杯水（假设每个杯子的容量是无限的），每杯水的温度为t[i]单位，体积为c[i]升。</p><p>现在要把大水缸的水倒入n杯水中，使得n杯水的温度相同，请问这可能吗？并求出可行的最高温度，保留4位小数。</p><p>注意：一杯温度为$t_1$单位、体积为$c_1$升的水与另一杯温度为$t_2$单位、体积为$c_2$升的水混合后，温度变为$(t_1 \times c_1+t_2 \times c_2)/(c_1+c_2)$，体积变为$c_1+c_2$。</p></blockquote><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分最终温度。</p><p>注意确定好$l$和$r$ 的范围，可能出现的除零操作。</p><p>复杂度$O(nlog_2T)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,T,C,t[N],c[N];<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Abs</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>&#123;    <span class="hljs-keyword">return</span> x&gt;<span class="hljs-number">0</span>?x:-x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>&#123;    <span class="hljs-keyword">double</span> tot=<span class="hljs-number">0</span>,temp;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(Abs(*(t+i)-x)&lt;<span class="hljs-number">1e-8</span>)<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(Abs(T-x)&lt;<span class="hljs-number">1e-8</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(x&lt;T&amp;&amp;x&lt;*(t+i))<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(x&gt;T&amp;&amp;x&gt;*(t+i))<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        temp=*(c+i)*(x-*(t+i))/(T-x);        tot+=temp;    &#125;    <span class="hljs-keyword">return</span> tot&lt;=C;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;T,&amp;C);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,t,c);    <span class="hljs-keyword">double</span> l=Min(T,*(t+<span class="hljs-number">0</span>)),r=Max(T,*(t+<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,t+i,c+i);        r=Min(r,Max(T,*(t+i)));        l=Max(l,Min(T,*(t+i)));    &#125;    <span class="hljs-keyword">double</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-5</span>)&#123;        <span class="hljs-keyword">if</span>(check(mid))l=mid;        <span class="hljs-keyword">else</span> r=mid;        mid=(l+r)/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">if</span>(check(r)||check(l))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Possible\n%.4lf\n"</span>,r);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Impossible\n"</span>);&#125;</code></pre><h2 id="B-二分图染色-弱化版"><a href="#B-二分图染色-弱化版" class="headerlink" title="B.二分图染色(弱化版)"></a>B.二分图染色(弱化版)</h2><blockquote><p>待更</p></blockquote><h2 id="C-合并回文子串"><a href="#C-合并回文子串" class="headerlink" title="C.合并回文子串"></a>C.合并回文子串</h2><blockquote><p>输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。输出这个最大价值。</p></blockquote><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><h4 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h4><p>因为合并的字符串是连续的，故可以定义状态$dp[i][j][k][h]$ 表示字符串A从第$i$ 位开始连续$j$ 个字符与字符串B从第$k$ 位开始连续$h$ 个字符能否合并成一个回文串C。</p><h4 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h4><p>$dp[i][j][k][h] ;|= dp[i+1][j-2][k][h] ，a[i]=a[i+j-1]$ 且$j \geqslant 2$ ；</p><p>$dp[i][j][k][h] ;|= dp[i][j][k+1][h-2] ，b[k]=b[k+h-1]$ 且$ h\geqslant 2$ ；</p><p>$dp[i][j][k][h] ;|= dp[i][j-1][k+1][h-1] ，a[i+j-1]=b[k]$ 且$j \geqslant 1,h \geqslant 1$ ；</p><p>$dp[i][j][k][h] ;|= dp[i+1][j-1][k][h-1] ，a[i]=b[k+h-1]$ 且$j \geqslant 1,h \geqslant 1$ ；</p><h4 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h4><ul><li>当$j+h \leqslant 1$ 即合并串C的长度小于等于$1$ 时，该串必为回文串。</li></ul><ul><li>考虑到边界$+1$ 后会超过数组范围，故$i \leqslant strlen(a),k \leqslant strlen(b)$ 。</li></ul><p>复杂度$O(Tn^4)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> T,dp[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>],lan,lbn,ans;<span class="hljs-keyword">char</span> a[<span class="hljs-number">55</span>],b[<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%s"</span>,a,b);        lan=<span class="hljs-built_in">strlen</span>(a);        lbn=<span class="hljs-built_in">strlen</span>(b);        ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=lan;++j)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> h=<span class="hljs-number">0</span>;h&lt;=lbn;++h)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+j&lt;=lan;++i)&#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k+h&lt;=lbn;++k)&#123;                        <span class="hljs-keyword">if</span>((j+h&lt;=<span class="hljs-number">1</span>)                           ||(i&lt;lan&amp;&amp;j&gt;=<span class="hljs-number">2</span>&amp;&amp;a[i]==a[i+j<span class="hljs-number">-1</span>]&amp;&amp;dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-2</span>][k][h])                           ||(k&lt;lbn&amp;&amp;h&gt;=<span class="hljs-number">2</span>&amp;&amp;b[k]==b[k+h<span class="hljs-number">-1</span>]&amp;&amp;dp[i][j][k+<span class="hljs-number">1</span>][h<span class="hljs-number">-2</span>])                           ||(i&lt;lan&amp;&amp;k&lt;lbn&amp;&amp;j&gt;=<span class="hljs-number">1</span>&amp;&amp;h&gt;=<span class="hljs-number">1</span>&amp;&amp;a[i]==b[k+h<span class="hljs-number">-1</span>]&amp;&amp;dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>][k][h<span class="hljs-number">-1</span>])                           ||(i&lt;lan&amp;&amp;k&lt;lbn&amp;&amp;j&gt;=<span class="hljs-number">1</span>&amp;&amp;h&gt;=<span class="hljs-number">1</span>&amp;&amp;a[i+j<span class="hljs-number">-1</span>]==b[k]&amp;&amp;dp[i][j<span class="hljs-number">-1</span>][k+<span class="hljs-number">1</span>][h<span class="hljs-number">-1</span>]))&#123;                            dp[i][j][k][h]=<span class="hljs-number">1</span>;                            ans=Max(ans,j+h);                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;&#125;</code></pre><h2 id="D-身体训练"><a href="#D-身体训练" class="headerlink" title="D.身体训练"></a>D.身体训练</h2><blockquote><p>n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v 米/秒。</p><p>最后一个人需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v米/秒。每个人最初的最高速度为c[i] 米/秒，每轮衰减d[i]米/秒，也就是说，如果i是第j个跑的，那么他的速度就是c[i]-(j-1)*d[i] 米/秒。n个人初始以随机的顺序排列，每种顺序的概率完全相等，跑完一轮（每个人都追到排头一次，序列恢复原样）的期望需要的时间是多少？</p></blockquote><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>按题意直接暴力模拟$ans = \frac{1}{n}\sum_{i=1}^n\sum_{j=1}^n\frac{nu}{c[i]-(j-1)d[i]-v}$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">double</span> ans,v,u,c[<span class="hljs-number">1005</span>],d[<span class="hljs-number">1005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lf%lf"</span>,&amp;n,&amp;v,&amp;u);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf"</span>,c+i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf"</span>,d+i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)            ans+=u*n/(c[i]-(j<span class="hljs-number">-1</span>)*d[i]-v);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.3lf\n"</span>,ans/n);&#125;</code></pre><h2 id="E-数列互质"><a href="#E-数列互质" class="headerlink" title="E.数列互质"></a>E.数列互质</h2><blockquote><p>给出一个长度为 n 的数列 { a[1] , a[2] , a[3] , … , a[n] }，以及 m 组询问 ( l[i] , r[i], k[i])。求数列下标区间在 [ l[i] , r[i] ] 中有多少数在该区间中的出现次数与 k[i] 互质（最大公约数为1）。</p></blockquote><h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><p>考虑到查询可以离线，采用莫队算法。</p><p>用数组$cnt[x]$ 维护当前区间$[l,r]$ 中，数$x$ 的出现次数。</p><p>用$num[x]$ 维护当前区间$[l,r]$ 中，出现次数为$x$ 次的有$num[x]$ 个。设$num[x]$ 的长度为$len$ ，考虑极端情况$\frac{(1+len)len}{2}=n$ ，故$len &lt; \sqrt{n}$ ，可选择map。</p><p>查询时，只需遍历整个$num[x]$ ，求得$ans=\sum_{gcd(x,k)=1}num[x]$ ，查询复杂度为$O(\sqrt{n} log_2^2n)$ 。</p><p>总复杂度为$O(n^{\frac{3}{2}}log_2^2n)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 50005</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> D 250</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m,a[N],cnt[N],ans[N];<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;num;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> l,r,k,id;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b)&#123;        <span class="hljs-keyword">if</span>(a.l/D==b.l/D)<span class="hljs-keyword">return</span> a.r&lt;b.r;        <span class="hljs-keyword">return</span> a.l/D&lt;b.l/D;    &#125;&#125;q[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> temp=cnt[a[x]];    <span class="hljs-keyword">if</span>(num.count(temp))&#123;        num[temp]--;        <span class="hljs-keyword">if</span>(num[temp]==<span class="hljs-number">0</span>)            num.erase(temp);    &#125;    temp=++cnt[a[x]];    num[temp]++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> temp=cnt[a[x]];    num[temp]--;    <span class="hljs-keyword">if</span>(num[temp]==<span class="hljs-number">0</span>)        num.erase(temp);    temp=--cnt[a[x]];    <span class="hljs-keyword">if</span>(temp)num[temp]++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(it=num.<span class="hljs-built_in">begin</span>();it!=num.<span class="hljs-built_in">end</span>();++it)        <span class="hljs-keyword">if</span>(gcd(it-&gt;first,x)==<span class="hljs-number">1</span>)temp+=it-&gt;second;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,a+i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);        q[i].l--;        q[i].r--;        q[i].id=i;    &#125;    sort(q,q+m);    <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(r&lt;q[<span class="hljs-number">0</span>].r)&#123;++r;add(r);&#125;    <span class="hljs-keyword">while</span>(l&lt;q[<span class="hljs-number">0</span>].l)&#123;dec(l);++l;&#125;    ans[q[<span class="hljs-number">0</span>].id]=query(q[<span class="hljs-number">0</span>].k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)&#123;        <span class="hljs-keyword">while</span>(r&lt;q[i].r)&#123;++r;add(r);&#125;        <span class="hljs-keyword">while</span>(r&gt;q[i].r)&#123;dec(r);--r;&#125;        <span class="hljs-keyword">while</span>(l&lt;q[i].l)&#123;dec(l);++l;&#125;        <span class="hljs-keyword">while</span>(l&gt;q[i].l)&#123;--l;add(l);&#125;        ans[q[i].id]=query(q[i].k);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);&#125;</code></pre><h2 id="F-最长树链"><a href="#F-最长树链" class="headerlink" title="F.最长树链"></a>F.最长树链</h2><blockquote><p>待更</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>二分</tag>
      
      <tag>模拟</tag>
      
      <tag>莫队</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF杂项之隐写术读后的一些思考</title>
    <link href="/2017/06/09/CTF%E6%9D%82%E9%A1%B9%E4%B9%8B%E9%9A%90%E5%86%99%E6%9C%AF%E8%AF%BB%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <url>/2017/06/09/CTF%E6%9D%82%E9%A1%B9%E4%B9%8B%E9%9A%90%E5%86%99%E6%9C%AF%E8%AF%BB%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>昨天Tr0y更新了一篇博客 <a href="http://www.tr0y.wang/2017/06/07/CtfMiscStega/#" target="_blank" rel="noopener">CTF杂项之隐写术</a></p><p>看到图种那里有一些想法，记录如下。</p><a id="more"></a><h2 id="摘自原文"><a href="#摘自原文" class="headerlink" title="摘自原文"></a>摘自原文</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p><code>FF D9</code> 这是jpg文件的结束符，利用winhex可以看到正常的jpg结尾都是 <code>FF D9</code> 的。图片查看器会忽视jpg结束符之后的内容，所以我们可以在jpg结束符之后插入附加的zip， 既不会影响图片的显示，还隐藏了文件。</p><p>如果你想尝试，可以利用 <code>copy</code> 命令，将两个文件以二进制方式连接起来，生成 output.jpg 的新文件。首先制作一个zip(1.zip)，把想要隐藏的东西放进去，再准备一张jpg图片(1.jpg)，然后打开cmd可以执行一个命令 <code>copy /b 1.jpg + 1.zip output.jpg</code> 就可以得到一个图种。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p>这种类型的隐写很容易被发现，用winhex打开看一下图片是不是以标准的结束符结尾的。解法也简单，如果发现藏着zip文件，把图片改后缀为zip解压就行了，如果是其他的文件，可以用winhex提取到新的文件里，再进行下一步处理。</p></blockquote><h2 id="思考一"><a href="#思考一" class="headerlink" title="思考一"></a>思考一</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>如果图片是以标准的结束符结尾，但图片中藏着zip文件，如下图所示。</p><p><img src="/img/post/%E5%9B%BE%E7%A7%8D%E6%80%9D%E8%80%83/%E5%9B%BE%E7%A7%8D_%E6%80%9D%E8%80%83%E4%B8%80.png" srcset="/img/loading.gif" alt="图种_思考一"></p><p>这种文件结构就不会那么容易被发现。</p><h3 id="实例文件"><a href="#实例文件" class="headerlink" title="实例文件"></a>实例文件</h3><p><img src="/img/post/%E5%9B%BE%E7%A7%8D%E6%80%9D%E8%80%83/total.jpg" srcset="/img/loading.gif" alt="total"></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>用winhex打开看一下图片中是否含有压缩文件的文件头标记（如zip文件的文件头标记为0x504B0304，rar文件的文件头标记为0x52617221），如果存在，则有可能采用了这种拼接方式。</p><h2 id="思考二"><a href="#思考二" class="headerlink" title="思考二"></a>思考二</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>如果生成的jpg文件以1.jpg+2.zip格式生成，而1.jpg文件中包含了zip文件头，如下图所示。</p><p><img src="/img/post/%E5%9B%BE%E7%A7%8D%E6%80%9D%E8%80%83/%E5%9B%BE%E7%A7%8D_%E6%80%9D%E8%80%83%E4%BA%8C.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>那么即使知道了拼接方式，也会因为zip文件头匹配错误而导致解压缩失败。</p><h3 id="实例文件-1"><a href="#实例文件-1" class="headerlink" title="实例文件"></a>实例文件</h3><p><img src="/img/post/%E5%9B%BE%E7%A7%8D%E6%80%9D%E8%80%83/total2.jpg" srcset="/img/loading.gif" alt="by_barriery"></p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>辨认出jpg文件中含zip的文件头后，随意更改其中的几个数据，导致该处文件头匹配不成功即可。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>文件头</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北方大学ACM多校训练赛第十四场</title>
    <link href="/2017/06/04/%E5%8C%97%E6%96%B9%E5%A4%A7%E5%AD%A6ACM%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%B5%9B%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%9C%BA/"/>
    <url>/2017/06/04/%E5%8C%97%E6%96%B9%E5%A4%A7%E5%AD%A6ACM%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%B5%9B%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/15722" target="_blank" rel="noopener">A. 卡尔的连招</a></p><p><a href="https://nanti.jisuanke.com/t/15723" target="_blank" rel="noopener">B. 聪明的班主任</a></p><p><a href="https://nanti.jisuanke.com/t/15724" target="_blank" rel="noopener">C. 一道简单题</a></p><p><a href="https://nanti.jisuanke.com/t/15725" target="_blank" rel="noopener">D. 又是一道简单题</a></p><p><a href="https://nanti.jisuanke.com/t/15726" target="_blank" rel="noopener">E. 车轮轴迹</a></p><p><a href="https://nanti.jisuanke.com/t/15727" target="_blank" rel="noopener">F. Easy Number</a></p><a id="more"></a><h2 id="A-卡尔的连招"><a href="#A-卡尔的连招" class="headerlink" title="A. 卡尔的连招"></a>A. 卡尔的连招</h2><blockquote><p>待更</p></blockquote><h2 id="B-聪明的班主任"><a href="#B-聪明的班主任" class="headerlink" title="B. 聪明的班主任"></a>B. 聪明的班主任</h2><blockquote><p>题目大意：有$n$ 个人每人有$a_i$ 本书，每次可以使任意$m$ 个人将他的书送给相邻的一个人，问最少几次能使所有人有相同本书。</p></blockquote><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>具体思路见代码。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> T,n,a[<span class="hljs-number">10005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>,temp=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);            sum+=a[i];        &#125;        <span class="hljs-keyword">if</span>(sum%n!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);            <span class="hljs-keyword">continue</span>;        &#125;        sum/=n;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            temp+=sum-a[i];            ans=<span class="hljs-built_in">max</span>(ans,temp&gt;<span class="hljs-number">0</span>?temp:-temp);            ans=<span class="hljs-built_in">max</span>(ans,a[i]-sum&gt;<span class="hljs-number">0</span>?a[i]-sum:sum-a[i]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;&#125;</code></pre><h2 id="C-一道简单题"><a href="#C-一道简单题" class="headerlink" title="C. 一道简单题"></a>C. 一道简单题</h2><blockquote><p>待更</p></blockquote><h2 id="D-又是一道简单题"><a href="#D-又是一道简单题" class="headerlink" title="D. 又是一道简单题"></a>D. 又是一道简单题</h2><blockquote><p>题目大意：询问以树上两结点$u,v$ 的最近公共祖先为根的子树中，不在这$u,v$ 的简单路径中的最小编号。若无则输出$-1$ 。</p></blockquote><h3 id="LCA-DFS序"><a href="#LCA-DFS序" class="headerlink" title="LCA+DFS序"></a>LCA+DFS序</h3><p>首先预处理LCA，复杂度$O(nlgn)$ 。</p><p>DFS整棵树，并记录各个结点$x$ 的进入时间$in[x]$ ，出去时间$out[x]$ 以及以$x$ 为根的子树中最小的结点编号$minnode[x]$ 。</p><p>当且仅当，$in[x] \leqslant in[y]$ 且$out[y] \leqslant out[x]$ 时，结点$y$ 在以结点$x$ 为根的子树中。</p><p>如此一来，对每个询问，只需要遍历以$LCA(u,v)$ 为根的子树，$O(1)$ 的复杂度判定当前结点$x$ 是否位于$u$ 和$v$ 的简单路径中，若不在则直接返回$minnode[x]$ ，单次查询复杂度$O(deep)$ ，其中$deep$ 表示整颗树的深度。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 50010</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> T,minnode[N];<span class="hljs-keyword">int</span> n,m,u,v,tot,in[N],out[N],ans,father[N];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;e[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LCA</span>&#123;</span>    <span class="hljs-keyword">int</span> k,ver[<span class="hljs-number">2</span>*N],dep[<span class="hljs-number">2</span>*N],dp[<span class="hljs-number">2</span>*N][<span class="hljs-number">20</span>],f[N];    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        k=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span></span>&#123;        dfs(root,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);        rmq(k);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> fa)</span></span>&#123;        f[x]=k;        dep[k]=d;        ver[k++]=x;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)e[x].<span class="hljs-built_in">size</span>();++i)<span class="hljs-keyword">if</span>(e[x][i]!=fa)&#123;            dfs(e[x][i],d+<span class="hljs-number">1</span>,x);            dep[k]=d;            ver[k++]=x;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rmq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)dp[i][<span class="hljs-number">0</span>]=i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=k;++j)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=k;++i)&#123;                <span class="hljs-keyword">int</span> x=dp[i][j<span class="hljs-number">-1</span>],y=dp[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>];                dp[i][j]=dep[x]&lt;dep[y]?x:y;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-keyword">int</span> u=f[i],v=f[j];        <span class="hljs-keyword">if</span>(u&gt;v)swap(u,v);        <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">log</span>(v-u+<span class="hljs-number">1.0</span>)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2.0</span>);        <span class="hljs-keyword">int</span> x=dp[u][len],y=dp[v+<span class="hljs-number">1</span>-(<span class="hljs-number">1</span>&lt;&lt;len)][len];        <span class="hljs-keyword">return</span> ver[dep[x]&lt;dep[y]?x:y];    &#125;&#125;gao;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pdfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;    in[u]=++tot;    father[u]=fa;    minnode[u]=u;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)e[u].<span class="hljs-built_in">size</span>();++i)<span class="hljs-keyword">if</span>(e[u][i]!=fa)&#123;        pdfs(e[u][i],u);        minnode[u]=<span class="hljs-built_in">min</span>(minnode[u],minnode[e[u][i]]);    &#125;    out[u]=tot;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> fa)</span></span>&#123;    <span class="hljs-keyword">if</span>((in[x]&lt;=in[u]&amp;&amp;out[u]&lt;=out[x])       ||(in[x]&lt;=in[v]&amp;&amp;out[v]&lt;=out[x]))&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)e[x].<span class="hljs-built_in">size</span>();++i)<span class="hljs-keyword">if</span>(e[x][i]!=fa)            dfs(e[x][i],u,v,x);    &#125;<span class="hljs-keyword">else</span>&#123;        ans=<span class="hljs-built_in">min</span>(ans,minnode[x]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        gao.init();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;u,&amp;v);            e[u].push_back(v);            e[v].push_back(u);        &#125;        gao.<span class="hljs-built_in">prepare</span>(<span class="hljs-number">1</span>);        tot=<span class="hljs-number">0</span>;        pdfs(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);        <span class="hljs-keyword">while</span>(m--)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;u,&amp;v);            <span class="hljs-keyword">int</span> lca=gao.lca(u,v);            ans=N;            dfs(lca,u,v,father[lca]);            <span class="hljs-keyword">if</span>(ans!=N)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)            e[i].<span class="hljs-built_in">clear</span>();    &#125;&#125;</code></pre><h2 id="E-车轮轴迹"><a href="#E-车轮轴迹" class="headerlink" title="E. 车轮轴迹"></a>E. 车轮轴迹</h2><blockquote><p>待更</p></blockquote><h2 id="F-Easy-Number"><a href="#F-Easy-Number" class="headerlink" title="F. Easy Number"></a>F. Easy Number</h2><blockquote><p>题目大意：给出$n$ 个数，定义能被$n$ 个数中任意一个整除的数为Easy Number，问第$k$ 大的Easy Number是什么。</p></blockquote><h3 id="二分-容斥原理"><a href="#二分-容斥原理" class="headerlink" title="二分+容斥原理"></a>二分+容斥原理</h3><p>$[0,x]$ 中能被$p$ 整除的数的个数有$\lfloor \frac{x}{p} \rfloor$ 。</p><p>由此我们可以利用容斥原理求出$x$ 以内能被任意一个$n$ 个数整除的数的个数，即Easy Number的个数，复杂度为$O(n \times 2^n)$ 。</p><p>二分这个界，则可找出第$k$ 大的数。</p><p>总复杂度为$O(log_2k \times n \times 2^n)$ 。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll T,n,k,a[<span class="hljs-number">15</span>];<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125;<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;    <span class="hljs-keyword">return</span> a/gcd(a,b)*b;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)&#123;        ll cnt=<span class="hljs-number">0</span>,temp=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>;j&lt;n;++j)<span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))&#123;            temp=lcm(temp,a[j]);            cnt++;        &#125;        <span class="hljs-keyword">if</span>(cnt)ans+=(cnt&amp;<span class="hljs-number">1</span>)?x/temp:-x/temp;    &#125;    <span class="hljs-keyword">return</span> ans&gt;=k;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        ll l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1000000000</span>;        <span class="hljs-keyword">while</span>(l&lt;r)&#123;            ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(check(mid))r=mid;            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,r);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>贪心</tag>
      
      <tag>二分</tag>
      
      <tag>状压dp</tag>
      
      <tag>LCA</tag>
      
      <tag>DFS序</tag>
      
      <tag>容斥原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于SQL中的全称量词</title>
    <link href="/2017/06/04/%E5%85%B3%E4%BA%8ESQL%E4%B8%AD%E7%9A%84%E5%85%A8%E7%A7%B0%E9%87%8F%E8%AF%8D/"/>
    <url>/2017/06/04/%E5%85%B3%E4%BA%8ESQL%E4%B8%AD%E7%9A%84%E5%85%A8%E7%A7%B0%E9%87%8F%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>这几天数据库上机，关于全称量词的某道题想了很久才明白一些，写下这篇博客做下巩固。</p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>SQL中没有全程量词，但是可以将其转化为等价的带有存在量词的语句，即可以用<code>exists</code> 代替全称量词。</p><h2 id="转化公式"><a href="#转化公式" class="headerlink" title="转化公式"></a>转化公式</h2><h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><p>$(\forall x)P=\neg (\exists x(\neg P) )$</p><h3 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h3><p>对于所有$x$ ，$P$ 成立 等价于 存在$x$ 使$P$ 不成立的情况不存在。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>上面的没看懂没关系，来看一个教科书上的例子。</p><blockquote><p>查询至少选修了学号为03051066选修的全部课程的学生学号。</p></blockquote><h3 id="数学语言描述"><a href="#数学语言描述" class="headerlink" title="数学语言描述"></a>数学语言描述</h3><ul><li>$x$ 表示学号为$03051066$ 选修了课程$cno$</li></ul><ul><li>$P$ 表示学生$sno$ 也选修了课程$cno $</li></ul><p>则有，$(\forall x)P=\neg (\exists x(\neg P) )$ 。</p><h3 id="自然语言描述-1"><a href="#自然语言描述-1" class="headerlink" title="自然语言描述"></a>自然语言描述</h3><p>有上述数学描述可得，存在学号为$03051066$ 选修了课程$cno$ 而学生$sno$ 没有选修课程$cno $ 的情况不存在。</p><p>换句话来说，也就是：</p><p>从$sc$ 中筛选出的每个学号$Number$，不存在这样的课程</p><ul><li>学号为$03051066$ 的选修过</li><li>学号为$Number$ 的人未选修</li></ul><h3 id="C-C-语言描述"><a href="#C-C-语言描述" class="headerlink" title="C/C++语言描述"></a>C/C++语言描述</h3><pre><code class="hljs c++"><span class="hljs-built_in">set</span>&lt;sno&gt;select;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sc.<span class="hljs-built_in">size</span>();++i)&#123;    <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;sc.<span class="hljs-built_in">size</span>();++j)&#123;        if(sc[j].sno=='03051066')&#123;            <span class="hljs-keyword">bool</span> galf=<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;sc.<span class="hljs-built_in">size</span>();++k)&#123;                <span class="hljs-keyword">if</span>(sc[i].sno==sc[k].sno&amp;&amp;sc[j].cno==sc[k].cno)&#123;                    galf=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(galf)&#123;                flag=<span class="hljs-number">0</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    select.insert(sc[i].sno);&#125;</code></pre><h3 id="Python语言描述"><a href="#Python语言描述" class="headerlink" title="Python语言描述"></a>Python语言描述</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exists_3</span><span class="hljs-params">(Number, course)</span>:</span>  <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> sc:    <span class="hljs-keyword">if</span> z.sno == Number <span class="hljs-keyword">and</span> z.cno == course:      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exists_2</span><span class="hljs-params">(Number)</span>:</span>  <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> sc:    <span class="hljs-keyword">if</span> y.sno == <span class="hljs-string">'03051066'</span> <span class="hljs-keyword">and</span> exists_3(Number, y.course) == <span class="hljs-literal">True</span>:   <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>select = set()<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> sc:  <span class="hljs-keyword">if</span> exists_2(x.sno) == <span class="hljs-literal">False</span>:    select.add(x.sno)</code></pre><h3 id="SQL语言描述"><a href="#SQL语言描述" class="headerlink" title="SQL语言描述"></a>SQL语言描述</h3><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sno,sname<span class="hljs-keyword">from</span> student<span class="hljs-keyword">where</span> sno <span class="hljs-keyword">in</span> (  <span class="hljs-keyword">select</span> sno  <span class="hljs-keyword">from</span> sc scx  <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>(    <span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> sc scy    <span class="hljs-keyword">where</span> scy.sno=<span class="hljs-string">'03051066'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>(      <span class="hljs-keyword">select</span> *      <span class="hljs-keyword">from</span> sc scz     <span class="hljs-keyword">where</span> scz.sno=scx.sno <span class="hljs-keyword">and</span> scz.cno=scy.cno    )  ));</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于乘法逆元</title>
    <link href="/2017/06/03/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    <url>/2017/06/03/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>若$a \in Z$ ，$(a,m)=1$ ，则在模$m$ 的意义下存在唯一的整数$a^{-1}$ ，使得$aa^{-1}=a^{-1}a \equiv 1(mod m)$ ，称$a^{-1}$ 为$a$ 在模$m$ 下的乘法逆元。</p><a id="more"></a><h2 id="求一个数的逆元"><a href="#求一个数的逆元" class="headerlink" title="求一个数的逆元"></a>求一个数的逆元</h2><p>求一个数$a$ 的逆元有两种方法，欧拉定理和拓展欧几里得算法。</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>由欧拉定理$a^{\varphi(n)} \equiv 1(mod n)$ 得，$a \times a^{\varphi(n)-1} \equiv 1(mod n)$ ，因而$a^{\varphi(n)-1}$ 即为$a$ 在模$n$ 下的逆元。</p><p>通常情况下我们遇到的$n$ 为质数，此时等价于费马小定理$a^{n-1} \equiv 1(mod n)$ ，从而$a^{n-2}$ 为$a$ 在模$n$ 下的逆元。</p><p>$a^{\varphi(n)-1}$ 和$a^{n-2}$ 可以用快速幂求得，复杂度为$O(log_2n)$ 。</p><h3 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h3><p>拓展欧几里得可以求得模线性方程$ax+ny=(a,n)$的解，当$(a,n)=1$时，$x$即为$a$ 在$n$ 下的乘法逆元，复杂度为$O(log_2n))$ 。</p><h2 id="求n以内的逆元"><a href="#求n以内的逆元" class="headerlink" title="求n以内的逆元"></a>求n以内的逆元</h2><p>求$n$ 以内的逆元，用上述两种方法复杂度均为$O(nlog_2n)$ 。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>其实还有种复杂度为$O(n)$ 的算法：</p><p>令$Inv_a$为$a$在$n$下的逆元，则有<br>$$<br>Inv_x \equiv [(n - \lfloor \frac{n}{x} \rfloor ) \times Inv_{n%x}]\mod n<br>$$</p><h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3><p>设$n=kx+r$，其中$0 \leqslant r &lt; x$，</p><p>那么原式等于$Inv_x \equiv [(n-k) \times Inv_r] (mod n)$</p><p>$\Leftarrow r \equiv [(n-k) \times x] (mod n)$</p><p>$\Leftarrow r \equiv -kx(mod n)$</p><p>即$kx+r = n \equiv 0(mod p)$ 。</p>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Euclid算法</title>
    <link href="/2017/06/03/%E5%85%B3%E4%BA%8EEuclid%E7%AE%97%E6%B3%95/"/>
    <url>/2017/06/03/%E5%85%B3%E4%BA%8EEuclid%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>欧几里得算法用来求两个数的最大公因数。</p><a id="more"></a><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这个大概是我最早接触的东西了吧，下面是学长传授的代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;  <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);&#125;</code></pre><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>$a$和$b$的最大公因数记为$gcd(a,b)$，简写为$(a,b)$ 。</p><p>证明Euclid算法的正确性，即证明$(a,b)=(a,b-ka)$ ，$k=\lfloor \frac{a}{b} \rfloor$。</p><p>设$x=(a,b)$，$y=(a,b-ka)$，</p><p>$\because x=(a,b)$，$\therefore x|a$，$x|b$ 。</p><p>$\therefore x|(-ka+b)$，$\therefore x|(a,b-ka)=y$，</p><p>故$x \leqslant y$.</p><p>$\because y=(a,b-ka)$，$\therefore y|a$，$y|(b-ka)$ 。</p><p>$\therefore y|[ka+(b-ka)]=b$，$\therefore y|(a,b)$，即$y|x$，</p><p>故$y \leqslant x$.</p><p>$\therefore x=y$.</p><p>即$(a,b)=(a,b-ka)$ 。</p><h2 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><p>上述欧几里得算法仅求出$(a,b)$，而不能得到$(a,b)$关于$a$ 和$b$ 的线性表示，故有了拓展欧几里得算法。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EXGCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">int</span> d=EXGCD(b,a%b,x,y);    <span class="hljs-keyword">int</span> t=x;    x=y;y=t-a/b*y;    <span class="hljs-keyword">return</span> d;&#125;</code></pre><h4 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h4><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EXGCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;    <span class="hljs-keyword">int</span> x0=<span class="hljs-number">1</span>,x1=<span class="hljs-number">0</span>,x2=a;    <span class="hljs-keyword">int</span> y0=<span class="hljs-number">0</span>,y1=<span class="hljs-number">1</span>,y2=b;    <span class="hljs-keyword">while</span>(y2!=<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">int</span> q=x2/y2;        <span class="hljs-keyword">int</span> t0=x0,t1=x1,t2=x2;        x0=y0;x1=y1;x2=y2;        y0=t0-q*y0;y1=t1-q*y1;y2=t2-q*y2;    &#125;    x=x0;y=x1;    <span class="hljs-keyword">return</span> x2;&#125;</code></pre><p>上述算法可求得$x$ 和$y$ ，使满足$(a,b)=ax+by$ 。</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>为便于证明，以非递归版本为例。</p><p>若$ax_0+bx_1=x_2$，$ay_0+by_1=y_2$，</p><p>不难得到$a(x_0-qy_0)+b(x_1-qy_1)=x_2-qy_2$.</p><p>上述等式正式保证了拓展欧几里得算法的正确性。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用以求模线性方程$ax+by=(a,b)$ 的解。特别地，当$(a,b)=1$ 时，$x$ 即为$a$ 在$b$ 下的乘法逆元。</p>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于斜率优化DP</title>
    <link href="/2017/06/02/%E5%85%B3%E4%BA%8E%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/"/>
    <url>/2017/06/02/%E5%85%B3%E4%BA%8E%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96DP/</url>
    
    <content type="html"><![CDATA[<p>很多情况下，动态规划的转移方程都可以被优化，而斜率优化通常能将算法复杂度降低一个维度。</p><a id="more"></a><h2 id="从一道例题开始"><a href="#从一道例题开始" class="headerlink" title="从一道例题开始"></a>从一道例题开始</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">HDU 3507 Print Article</a></p><blockquote><p>题目大意：给定$n$，$m$，输出序列$n$个数，每连续输出代价为连续输出的数字和的平方加上$m$.</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$sum_{pq}=\sum_{k=p+1}^qa_k=pre[q]-pre[p]$，其中$pre[]$维护的是前缀和.</p><h3 id="朴素dp"><a href="#朴素dp" class="headerlink" title="朴素dp"></a>朴素dp</h3><p>定义状态$dp[i]$ 表示输出前$i$ 个数所需要的最小代价。</p><p>转移方程为 $dp[i]=min { dp[q]+sum_{qi}+m }(q&lt;i)$。</p><p>如此复杂度为$O(n^2)$，故需要优化。</p><h3 id="斜率优化dp"><a href="#斜率优化dp" class="headerlink" title="斜率优化dp"></a>斜率优化dp</h3><p>设$p&lt;q$，若从$q$转移而来比从$p$更优，则有$dp[q]+sum_{qi}+m&lt;dp[p]+sum_{pi}+m$，</p><p>化简可得，$\frac{(dp[q]+pre[q]^2)-(dp[p]+pre[p]^2)}{2pre[q]-2pre[p]}&lt;pre[i]$ 。</p><p>定义映射$f$，使得$k\xrightarrow{f} (2pre[k],dp[k]+pre[k]^2)$，$g[p,q]$为$f(p)$和$f(q)$两点的斜率，</p><p>则有，若$g[p,q]&lt;pre[i]$，则$q$比$p$更优。</p><p>当$p&lt;k&lt;q$且$g[p,k]&gt;g[k,q]$时，不难证明$k$一定不为最优：</p><p>当$g[k,q]&lt;pre[i]$时，$q$比$k$更优；当$g[k,q]\geqslant pre[i]$时，有$g[p,k]&gt;pre[i]$，故$p$比$k$更优。</p><p>考虑$pre[i]$数列的单调性，我们只需维护一个斜率递增的队列即可.</p><p><img src="/img/post/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96.bmp" srcset="/img/loading.gif" alt="斜率优化_barriery"></p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 500005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,m,dp[N],a[N],pre[N],deq[N],r,f;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-keyword">return</span> dp[n]+pre[n]*pre[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*pre[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m))&#123;        r=<span class="hljs-number">-1</span>,f=<span class="hljs-number">0</span>;        deq[++r]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);            pre[i]=pre[i<span class="hljs-number">-1</span>]+a[i];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">while</span>(r-f&gt;<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(y(deq[f+<span class="hljs-number">1</span>])-y(deq[f])                   &lt;=pre[i]*(x(deq[f+<span class="hljs-number">1</span>])-x(deq[f])))                    f++;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;            &#125;            dp[i]=dp[deq[f]]+(pre[i]-pre[deq[f]])*(pre[i]-pre[deq[f]])+m;            <span class="hljs-keyword">while</span>(r-f&gt;<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>((y(deq[r])-y(deq[r<span class="hljs-number">-1</span>]))*(x(i)-x(deq[r]))                    &gt;=(y(i)-y(deq[r]))*(x(deq[r])-x(deq[r<span class="hljs-number">-1</span>])))                    r--;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;            &#125;            deq[++r]=i;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[n]);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素性测试</title>
    <link href="/2017/06/02/%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/"/>
    <url>/2017/06/02/%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>判断一个数$n$ 是否为素数有很多做法，最常见的是枚举$i$ 从$2$ 到$\lfloor \sqrt{n} \rfloor$ ，判断$n$ 是否都不能被$i$ 整除。</p><a id="more"></a><h2 id="朴素的判断素数方法"><a href="#朴素的判断素数方法" class="headerlink" title="朴素的判断素数方法"></a>朴素的判断素数方法</h2><p>上述算法的复杂度为$O(\sqrt{n})$ ，其代码如下：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span>&#123;    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i*i&lt;=p;++i)        <span class="hljs-keyword">if</span>(p%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>对于大数来说，这个时间是无法接受的。</p><h2 id="Fermat测试"><a href="#Fermat测试" class="headerlink" title="Fermat测试"></a>Fermat测试</h2><p>为了解决大数的素性判断，有了下面的RP算法：Fermat测试。</p><p>根据Fermat小定理，若$p$为素数，则对任意$a$必有$a^{p-1} \equiv 1(mod p)$.</p><p>故对于一个$a$，若$a^{p-1} \not\equiv 1(mod p)$，则$p$为合数；若$a^{p-1} \equiv 1(mod p)$，则$p$有可能为素数，实际上当$p$为奇数时，$p$是合数的概率小于$\frac{1}{2}$.</p><p>于是对于一个奇数$p(p\geqslant 3)$和安全参数$k$：</p><ul><li>随机取一个数$n(2 \leqslant n \leqslant p-1)$</li><li>若$(n,p)\neq 1$，则$p$为合数</li><li>若$n^{p-1} \not\equiv 1(mod p)$则$p$为合数，否则假定$p$为素数</li><li>重复上述过程$k$次</li></ul><p>假定大数相乘的复杂度为$O(lgn \times lglgn)$，故算法复杂度为$O(k \times lg^2n \times lglgn)$，若测试得到$p$为素数，则准确率为$1-\frac{1}{2^k}$.代码如下（为了方便高精度运算，用python编写）：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GCD</span><span class="hljs-params">(a, b)</span>:</span>    <span class="hljs-keyword">while</span> b:        a, b = b, a % b    <span class="hljs-keyword">return</span> a<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PowMod</span><span class="hljs-params">(a, n, p)</span>:</span>    r, t = <span class="hljs-number">1</span>, a    <span class="hljs-keyword">while</span> n:        <span class="hljs-keyword">if</span> n &amp; <span class="hljs-number">1</span>:            r = (r * t) % p        t = (t * t) % p        n &gt;&gt;= <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> r<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FermatTest</span><span class="hljs-params">(p)</span>:</span>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">if</span> p % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    k = <span class="hljs-number">20</span>    <span class="hljs-keyword">while</span> k:        a = random.randint(<span class="hljs-number">2</span>, p - <span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> GCD(a, p) != <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> PowMod(a, p - <span class="hljs-number">1</span>, p) != <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        k -= <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>print(FermatTest(int(input())))</code></pre><h2 id="Miller-Rabin测试"><a href="#Miller-Rabin测试" class="headerlink" title="Miller-Rabin测试"></a>Miller-Rabin测试</h2><p>Fermat测试的复杂度还能被再次降低。</p><p>若$p$为奇数，则有$p-1=2^st$，其中$t$为奇数，则有以下分解式：</p><p>$n^{p-1}-1=(n^t-1)(n^t+1)(n^{2t}+1)\times …\times (n^{(s-1)t}+1)$</p><p>因此，如果有$n^{p-1} \equiv 1(mod p)$，则必有$n^t \equiv 1(mod p)$或者$n^{kt} \equiv -1(mod p)(1 \leqslant k \leqslant s-1)$成立。</p><p>故有了Miller-Rabin算法：</p><ul><li>将$p-1$表示成$2^st$</li><li>随机取一个数$n(2 \leqslant n \leqslant p-1)$</li><li>计算$n^t(mod p)$，若其等于$\pm1$，则假定$p$为素数</li><li>计算$n^{kt}(mod p)(2 \leqslant k \leqslant s-1)$，若其中有一个等于$-1$，则假定$p$为素数。否则$p$为合数</li><li>重复上述过程$k$次</li></ul><p>若测试得到$p$为素数，则准确率为$1-\frac{1}{4^k}$.代码如下：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GCD</span><span class="hljs-params">(a, b)</span>:</span>    <span class="hljs-keyword">while</span> b:        a, b = b, a % b    <span class="hljs-keyword">return</span> a<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PowMod</span><span class="hljs-params">(a, n, p)</span>:</span>    r, t = <span class="hljs-number">1</span>, a    <span class="hljs-keyword">while</span> n:        <span class="hljs-keyword">if</span> n &amp; <span class="hljs-number">1</span>:            r = (r * t) % p        t = (t * t) % p        n &gt;&gt;= <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> r<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MillerRabin</span><span class="hljs-params">(p)</span>:</span>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">if</span> p % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    s, t = <span class="hljs-number">0</span>, p - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:        t &gt;&gt;= <span class="hljs-number">1</span>        s += <span class="hljs-number">1</span>    k = <span class="hljs-number">10</span>    <span class="hljs-keyword">while</span> k:        a = random.randint(<span class="hljs-number">2</span>, p - <span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> GCD(a, p) != <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        m = PowMod(a, t, p)        npass = <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m == p - <span class="hljs-number">1</span>:            npass = <span class="hljs-number">0</span>        q = s - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> npass <span class="hljs-keyword">and</span> q:            m = (m * m) % p            <span class="hljs-keyword">if</span> m == p - <span class="hljs-number">1</span>:                npass = <span class="hljs-number">0</span>            q -= <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> npass:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        k -= <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>print(MillerRabin(int(input())))</code></pre>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 417(Div. 2)</title>
    <link href="/2017/06/02/Codeforces%20Round%20417%20(Div.%202)/"/>
    <url>/2017/06/02/Codeforces%20Round%20417%20(Div.%202)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/812/problem/A" target="_blank" rel="noopener">A. Sagheer and Crossroads</a></p><p><a href="http://codeforces.com/contest/812/problem/B" target="_blank" rel="noopener">B. Sagheer, the Hausmeister</a></p><p><a href="http://codeforces.com/contest/812/problem/C" target="_blank" rel="noopener">C. Sagheer and Nubian Market</a></p><p><a href="http://codeforces.com/contest/812/problem/D" target="_blank" rel="noopener">D. Sagheer and Kindergarten</a></p><p><a href="http://codeforces.com/contest/812/problem/E" target="_blank" rel="noopener">E. Sagheer and Apple Tree</a></p><a id="more"></a><h2 id="A-Sagheer-and-Crossroads"><a href="#A-Sagheer-and-Crossroads" class="headerlink" title="A. Sagheer and Crossroads"></a>A. Sagheer and Crossroads</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>需要注意：只要该路口有人，则不能有车。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> q[<span class="hljs-number">5</span>];<span class="hljs-keyword">int</span> c[<span class="hljs-number">5</span>];<span class="hljs-keyword">int</span> x[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">int</span> l,s,r,p;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;l,&amp;s,&amp;r,&amp;p);    <span class="hljs-keyword">if</span>(l)c[<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(s)c[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(r)c[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(p)q[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(l+s+r)x[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;l,&amp;s,&amp;r,&amp;p);    <span class="hljs-keyword">if</span>(l)c[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(s)c[<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(r)c[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(p)q[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(l+s+r)x[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;l,&amp;s,&amp;r,&amp;p);    <span class="hljs-keyword">if</span>(l)c[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(s)c[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(r)c[<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(p)q[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(l+s+r)x[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;l,&amp;s,&amp;r,&amp;p);    <span class="hljs-keyword">if</span>(l)c[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(s)c[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(r)c[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(p)q[<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(l+s+r)x[<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">bool</span> f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;++i)        <span class="hljs-keyword">if</span>((c[i]==<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-number">1</span>==q[i])||(q[i]==<span class="hljs-number">1</span>&amp;&amp;x[i]==<span class="hljs-number">1</span>))f=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(f)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);&#125;</code></pre><h2 id="B-Sagheer-the-Hausmeister"><a href="#B-Sagheer-the-Hausmeister" class="headerlink" title="B. Sagheer, the Hausmeister"></a>B. Sagheer, the Hausmeister</h2><blockquote><p>题目大意：给定一个楼层的亮灯状态，问从左下角开始灭掉所有灯最少需要走几步。不需要回到起点。</p></blockquote><h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>记录最高需要到达的层数$fl$ ，每层楼最左边亮着的灯$l[i]$ 以及最右边亮着的灯$r[i]$ .</p><p>定义状态$dp[i][0]$ 表示灭完第$i$ 层灯后在左边楼梯所需要的最少步数，$dp[i][1]$ 表示灭完第$i$ 层灯后在右边楼梯所需要的最少步数。复杂度$O(nm)$.</p><p>需要注意：$fl=0$ 时，需要特判。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> inf=<span class="hljs-number">100000000</span>;<span class="hljs-keyword">int</span> n,m,l[<span class="hljs-number">20</span>],r[<span class="hljs-number">20</span>],dp[<span class="hljs-number">20</span>][<span class="hljs-number">2</span>],fl=<span class="hljs-number">-1</span>;<span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>][<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,str[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m+<span class="hljs-number">2</span>;++j)<span class="hljs-keyword">if</span>(str[i][j]==<span class="hljs-string">'1'</span>)&#123;            <span class="hljs-keyword">if</span>(l[i]==<span class="hljs-number">0</span>)l[i]=r[i]=j;            <span class="hljs-keyword">else</span> r[i]=j;            fl=i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(fl==<span class="hljs-number">-1</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>*r[<span class="hljs-number">0</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=m+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>&amp;&amp;i&lt;fl;++i)&#123;        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">2</span>*r[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+m+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;        dp[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+m+<span class="hljs-number">1</span>,dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>*((l[i]!=<span class="hljs-number">0</span>)?(m+<span class="hljs-number">1</span>-l[i]):<span class="hljs-number">0</span>))+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(fl!=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,<span class="hljs-built_in">min</span>(dp[fl<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+r[fl],dp[fl<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+((l[fl]!=<span class="hljs-number">0</span>)?(m+<span class="hljs-number">1</span>-l[fl]):<span class="hljs-number">0</span>))+<span class="hljs-number">1</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,r[<span class="hljs-number">0</span>]);&#125;</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>注意到该题$n \leqslant 15$ ，故可以用$2^{15}$ 枚举灭完各层灯后所在的楼梯状态，复杂度为$O(nm+n \times 2^n)$.</p><p>代码如下<code>from xdujlx</code>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld;<span class="hljs-keyword">int</span> l[<span class="hljs-number">20</span>],r[<span class="hljs-number">20</span>];<span class="hljs-keyword">char</span> s[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)            <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">'1'</span>) r[i]=j;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)            <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">'1'</span>) l[i]=j;    &#125;    <span class="hljs-keyword">for</span>(;n&gt;=<span class="hljs-number">2</span>&amp;&amp;!l[n];--n);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1e9</span>;    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;(n<span class="hljs-number">-1</span>));i++)&#123;        <span class="hljs-keyword">bool</span> pL=<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> res=n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;            <span class="hljs-keyword">bool</span> L=(i&gt;&gt;(j<span class="hljs-number">-1</span>))&amp;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(pL!=L)&#123;                res+=m+<span class="hljs-number">1</span>;                pL=L;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pL&amp;&amp;r[j]) res+=<span class="hljs-number">2</span>*r[j];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!pL&amp;&amp;l[j]) res+=<span class="hljs-number">2</span>*(m+<span class="hljs-number">1</span>-l[j]);        &#125;        <span class="hljs-keyword">if</span>(pL&amp;&amp;r[n]) res+=r[n];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!pL&amp;&amp;l[n]) res+=(m+<span class="hljs-number">1</span>-l[n]);        ans=<span class="hljs-built_in">min</span>(ans,res);    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="C-Sagheer-and-Nubian-Market"><a href="#C-Sagheer-and-Nubian-Market" class="headerlink" title="C. Sagheer and Nubian Market"></a>C. Sagheer and Nubian Market</h2><blockquote><p>题目大意：有$n$ 个物品，每个价值$a_i$ 。若购买$k$ 个物品（这些物品下标为$x_1,x_2,…x_k$），则每个物品需要支付$a_{x_i}+kx_i$元 。现有$s$ 元，问最多能买多少个物品。</p></blockquote><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分$k$ 值，每次用优先队列检查是否能在$s$ 元内购买$k$ 个物品，复杂度为$O(nlog_2^2(n))$.</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll n,s,a[<span class="hljs-number">100005</span>],sum;priority_queue&lt;ll&gt;q;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll x)</span></span>&#123;    <span class="hljs-keyword">while</span>(!q.empty())q.pop();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)q.push(-(a[i]+x*i));&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span></span>&#123;    init(x);    sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;x;++i)&#123;        sum+=-q.top();        q.pop();        <span class="hljs-keyword">if</span>(sum&gt;s)<span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> sum&lt;=s;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d%I64d"</span>,&amp;n,&amp;s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>,&amp;a[i]);    ll l=<span class="hljs-number">0</span>,r=n;ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;        <span class="hljs-keyword">if</span>(check(mid))l=mid+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;        mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(check(r))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d %I64d\n"</span>,r,sum);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0 0\n"</span>);&#125;</code></pre><h2 id="D-Sagheer-and-Kindergarten"><a href="#D-Sagheer-and-Kindergarten" class="headerlink" title="D. Sagheer and Kindergarten"></a>D. Sagheer and Kindergarten</h2><blockquote><p>题目有毒，暂时放弃治疗。</p></blockquote><h2 id="E-Sagheer-and-Apple-Tree"><a href="#E-Sagheer-and-Apple-Tree" class="headerlink" title="E. Sagheer and Apple Tree"></a>E. Sagheer and Apple Tree</h2><blockquote><p>题目大意：给定一颗$n(n \leqslant 10^5)$ 的树，且每个结点上都有$a_i$ 个苹果，每次操作只能将一个结点上的若干个苹果（不能为空）移到它的孩子结点或者将一个孩子结点上的若干个苹果（不能为空）吃掉。现在两人轮流进行操作，后手先将两个不同结点的苹果个数互换后，先手开始操作，直到不能操作为输。问有多少种换苹果的方案，使得先手输。</p></blockquote><h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h3><h4 id="考虑一条链的情况"><a href="#考虑一条链的情况" class="headerlink" title="考虑一条链的情况"></a>考虑一条链的情况</h4><h5 id="当结点数为1时"><a href="#当结点数为1时" class="headerlink" title="当结点数为1时"></a>当结点数为1时</h5><p>该结点上没有苹果时，如下所示：</p><p><img src="/img/post/cf_417_E/cf_417_1.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>显然此时$SG$ 值为$0$ 。</p><p>该结点上有$n$ 个苹果时，如下所示：</p><p><img src="/img/post/cf_417_E/cf_417_2.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>由于其能转移到$0 \sim n-1$ 的任意状态，故此时$SG$ 值为$n$ 。</p><h5 id="当结点数为2时"><a href="#当结点数为2时" class="headerlink" title="当结点数为2时"></a>当结点数为2时</h5><p>父节点有$n$ 个苹果，孩子上无苹果时，如下图所示：</p><p><img src="/img/post/cf_417_E/cf_417_3.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>考虑先手无论从父节点移多少苹果到孩子，后手都将其吃掉，故先手必败，$SG$ 值为$0$ 。</p><h5 id="当结点数为3时"><a href="#当结点数为3时" class="headerlink" title="当结点数为3时"></a>当结点数为3时</h5><p>父节点有$n$ 个苹果，孩子和孙子结点上无苹果时，如下图所示：</p><p><img src="/img/post/cf_417_E/cf_417_4.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>若将$n$ 个苹果全部移到孩子结点，则转移到了上面两个结点的状态（$SG=0$），故若设该状态$SG=f(n)$ ，那么$f(n) \geqslant 1$ 。</p><p>将$n-m$ 个苹果移到孩子结点，如图：</p><p><img src="/img/post/cf_417_E/cf_417_5_.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>设该状态$SG=f(m)$ ，而该状态其实是由</p><p><img src="/img/post/cf_417_E/cf_417_6.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>和</p><p><img src="/img/post/cf_417_E/cf_417_7.png" srcset="/img/loading.gif" alt="by_barriery"></p><p>组合而成的，设前半部分的$SG$ 值为$f(m^{‘})$ ，后半部分的$SG$ 值为$0$ ，故有$f(m)=f(m^{‘}) \oplus  0=f(m^{‘})$ ，其中$\oplus$ 表示异或操作。</p><p>有了上面的结论后，有$f(n)$ 可以转移到$f(m)$ ，故$f(n)=n$ 。</p><h5 id="当结点数为更多时"><a href="#当结点数为更多时" class="headerlink" title="当结点数为更多时"></a>当结点数为更多时</h5><p>父节点有$n$ 个苹果，后继结点上均无苹果时，不难得到：</p><ul><li>当结点数为奇数时，$SG=n$ ；</li><li>当结点数为偶数时，$SG=0$ 。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>单条链的$SG$ 值为所有奇数结点的苹果个数的异或和。</p><h4 id="考虑一颗树的情况"><a href="#考虑一颗树的情况" class="headerlink" title="考虑一颗树的情况"></a>考虑一颗树的情况</h4><p>一颗树其实是由若干条链组合而成的，因为题目中说明所有叶节点的深度同奇偶，故一棵树的$SG$ 值为与叶节点同奇偶的所有结点上苹果个数的异或和。</p><h4 id="换苹果的方案"><a href="#换苹果的方案" class="headerlink" title="换苹果的方案"></a>换苹果的方案</h4><p>设初状态的$SG$ 值为$res$ ，所有层数与叶节点奇偶性相同的结点组成的集合为$S$ ，所有层数与叶节点奇偶性不同的结点组成的集合为$T$。</p><p>若$res=0$ ，即没交换前先手已经为输，此时$S$ 中结点可以互相交换，$T$ 中结点也可以互相交换。</p><p>之后将$T$ 中每个结点与$res$ 异或得到$temp_x$，若在$S$ 中找到与$temp_x$ 相等的结点，那么这两个结点可以互相交换。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,a[N],p;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;e[N],b[<span class="hljs-number">2</span>];<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;mp[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> d)</span></span>&#123;    <span class="hljs-keyword">int</span> deep=d;    b[d&amp;<span class="hljs-number">1</span>].push_back(a[u]);    mp[d&amp;<span class="hljs-number">1</span>][a[u]]++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)e[u].<span class="hljs-built_in">size</span>();++i)        deep=<span class="hljs-built_in">max</span>(deep,dfs(e[u][i],d+<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> deep;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;p);        e[p].push_back(i);    &#125;    <span class="hljs-keyword">int</span> d=dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-keyword">int</span>)b[d&amp;<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>();++i)        res^=b[d&amp;<span class="hljs-number">1</span>][i];    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">int</span> tot=b[d&amp;<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>();        ans+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)tot*(tot<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;        tot=b[!(d&amp;<span class="hljs-number">1</span>)].<span class="hljs-built_in">size</span>();        ans+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)tot*(tot<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it=mp[!(d&amp;<span class="hljs-number">1</span>)].<span class="hljs-built_in">begin</span>();it!=mp[!(d&amp;<span class="hljs-number">1</span>)].<span class="hljs-built_in">end</span>();++it)&#123;        <span class="hljs-keyword">int</span> temp=res^it-&gt;X;        ans+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(it-&gt;Y)*mp[d&amp;<span class="hljs-number">1</span>][temp];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,ans);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>二分</tag>
      
      <tag>模拟</tag>
      
      <tag>Codeforces</tag>
      
      <tag>枚举</tag>
      
      <tag>博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于积性函数</title>
    <link href="/2017/06/01/%E5%85%B3%E4%BA%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    <url>/2017/06/01/%E5%85%B3%E4%BA%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>​    对一切正整数$x$有确切值的函数$f(x)$ ，只要其在全体正整数上的函数值不全为零，就称为一个数论函数。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>设$f(x)$ 为一个数论函数，若对于每一对互质的正整数$a$ ，$b$ 都满足$f(ab)=f(a)f(b)$ ，则$f(x)$ 是积性函数。</li><li>设$f(x)$ 为一个数论函数，若对于每一对正整数$a$ ，$b$ 都满足$f(ab)=f(a)f(b)$ ，则$f(x)$ 是完全积性函数。</li></ul><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>线性筛可以以$O(n)$的复杂度求得$1 \sim n$的所有素数及各个数的最小素因子：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> prime[N],cnt;<span class="hljs-keyword">bool</span> isnotprime[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;    <span class="hljs-keyword">if</span>(!isnotprime[i])prime[cnt++]=i;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;++j)&#123;      isnotprime[i*prime[j]]=<span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;    &#125;  &#125;&#125;</code></pre><p>利用这些信息，可以以递推的方式求得前$n$ 项积性函数值。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="http://poj.org/problem?id=2478" target="_blank" rel="noopener">POJ 2478 Farey Sequence</a></p><blockquote><p>题目大意：求$\sum_{i=2}^n \varphi(i)$。</p></blockquote><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1000005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll var[N],pre[N],prime[N],k;<span class="hljs-keyword">bool</span> vis[N]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1000000</span>;++i)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            prime[k++]=i;            var[i]=i<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k&amp;&amp;prime[j]*i&lt;=<span class="hljs-number">1000000</span>;++j)&#123;            vis[prime[j]*i]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;                var[prime[j]*i]=var[i]*prime[j];                <span class="hljs-keyword">break</span>;            &#125;            var[prime[j]*i]=var[i]*var[prime[j]];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000000</span>;++i)        pre[i]=pre[i<span class="hljs-number">-1</span>]+var[i];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    init();    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n))&#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,pre[n]);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 416 (Div. 2)</title>
    <link href="/2017/06/01/Codeforces%20Round%20416%20(Div.%202)/"/>
    <url>/2017/06/01/Codeforces%20Round%20416%20(Div.%202)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/811/problem/A" target="_blank" rel="noopener">A. Vladik and Courtesy</a></p><p><a href="http://codeforces.com/contest/811/problem/B" target="_blank" rel="noopener">B. Vladik and Complicated Book</a></p><p><a href="http://codeforces.com/contest/811/problem/C" target="_blank" rel="noopener">C. Vladik and Memorable Trip</a></p><p><a href="http://codeforces.com/contest/811/problem/D" target="_blank" rel="noopener">D. Vladik and Favorite Game</a></p><p><a href="http://codeforces.com/contest/811/problem/E" target="_blank" rel="noopener">E. Vladik and Entertaining Flags</a></p><a id="more"></a><h2 id="A-Vladik-and-Courtesy"><a href="#A-Vladik-and-Courtesy" class="headerlink" title="A. Vladik and Courtesy"></a>A. Vladik and Courtesy</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a,b;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;    ll t=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">if</span>(t&amp;<span class="hljs-number">1</span>)a-=t;        <span class="hljs-keyword">else</span> b-=t;        t++;        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span>||b&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span>)<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Vladik"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Valera"</span>;&#125;</code></pre><h2 id="B-Vladik-and-Complicated-Book"><a href="#B-Vladik-and-Complicated-Book" class="headerlink" title="B. Vladik and Complicated Book"></a>B. Vladik and Complicated Book</h2><blockquote><p>题目大意：判断区间内第$k$大是否为$x$.</p></blockquote><h3 id="离线-树状数组"><a href="#离线-树状数组" class="headerlink" title="离线+树状数组"></a>离线+树状数组</h3><p>看到数据范围$10^4$ ，想成学校的老年机，半天想出个$O（mlgm+mlgn）$的。</p><p>考虑到每个数都不相同，可以先离线询问，然后将小于$x$ 的数插入树状数组后查询区间$[L,R]$ 内有多少比$x$ 小的数。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,m,a[<span class="hljs-number">10005</span>],c[<span class="hljs-number">10005</span>],f[<span class="hljs-number">10005</span>];<span class="hljs-keyword">bool</span> ans[<span class="hljs-number">10005</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> l,r,x,id;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node qq,node pp)&#123;        <span class="hljs-keyword">return</span> a[qq.x]&lt;a[pp.x];    &#125;&#125;q[<span class="hljs-number">10005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">return</span> x&amp;-x;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=n;i+=lowbit(i))        c[i]++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i))        ans+=c[i];    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        f[a[i]]=i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;q[i].l,&amp;q[i].r,&amp;q[i].x);        q[i].id=i;    &#125;    sort(q,q+m);    <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;        <span class="hljs-keyword">int</span> id=q[i].id;        <span class="hljs-keyword">while</span>(l&lt;a[q[i].x])&#123;            add(f[l]);            l++;        &#125;        <span class="hljs-keyword">int</span> t=sum(q[i].r)-sum(q[i].l<span class="hljs-number">-1</span>);        <span class="hljs-keyword">if</span>(q[i].l+t==q[i].x)ans[id]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> ans[id]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;        <span class="hljs-keyword">if</span>(ans[i])<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);    &#125;&#125;</code></pre><h3 id="主席树模板"><a href="#主席树模板" class="headerlink" title="主席树模板"></a>主席树模板</h3><p>主席树可以查询区间第$k$ 大，判断区间第$k$ 大是否为$x$ 自然不在话下，复杂度$O(mlgn)$ ，常数略比上面方法大，代码不贴。</p><h3 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h3><p>也可以直接暴力，复杂度$O(nm)$ 。</p><p>代码如下<code>form xdujlx</code>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> p[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">cin</span>&gt;&gt;p[i];    <span class="hljs-keyword">int</span> l,r,x;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;x;        <span class="hljs-keyword">int</span> rk=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            <span class="hljs-keyword">if</span>(p[i]&lt;p[x]) rk++;        <span class="hljs-keyword">if</span>(l+rk==x) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Yes"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"No"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="C-Vladik-and-Memorable-Trip"><a href="#C-Vladik-and-Memorable-Trip" class="headerlink" title="C. Vladik and Memorable Trip"></a>C. Vladik and Memorable Trip</h2><blockquote><p>题目大意：将一个数组划分成若干个不交叉的块，要求块外不含块内元素，每个块的价值为块内不同元素的异或值，总价值为所有块的价值和，问最大价值。</p></blockquote><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>想着先区间合并再dp，然后算法错误…</p><p>看到数据范围其实$O(n^2)$可过，直接dp就好了…</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,a[<span class="hljs-number">5005</span>],dp[<span class="hljs-number">5005</span>],r[<span class="hljs-number">5005</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">5005</span>],f[<span class="hljs-number">5005</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        r[a[i]]=i;    &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">int</span> t=a[i];        <span class="hljs-keyword">if</span>(!vis[t])&#123;            vis[t]=<span class="hljs-number">1</span>;            <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(f));            f[t]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> temp=t;            <span class="hljs-keyword">int</span> R=r[t];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;R;++j)&#123;                <span class="hljs-keyword">if</span>(vis[a[j]]&amp;&amp;a[j]!=t)&#123;                    flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span>(!f[a[j]])&#123;                    temp^=a[j];                    R=<span class="hljs-built_in">max</span>(R,r[a[j]]);                    f[a[j]]=<span class="hljs-number">1</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(flag)dp[R]=<span class="hljs-built_in">max</span>(dp[R],temp+ans);        &#125;        ans=<span class="hljs-built_in">max</span>(ans,dp[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;</code></pre><h2 id="D-Vladik-and-Favorite-Game"><a href="#D-Vladik-and-Favorite-Game" class="headerlink" title="D. Vladik and Favorite Game"></a>D. Vladik and Favorite Game</h2><blockquote><p>题目大意：交互题，要求输出从起点到终点的行动方向，其中左右和上下的方向可能会被改变一次。</p></blockquote><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>先dfs出不改变方向的情况下的原行动方向，然后一步一步模拟即可。</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m,d=<span class="hljs-number">-1</span>,x,y,px,py,nx,ny;<span class="hljs-keyword">char</span> mp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<span class="hljs-keyword">char</span> ans[<span class="hljs-number">10005</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> px,<span class="hljs-keyword">int</span> py,<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-keyword">if</span>(mp[px][py]==<span class="hljs-string">'F'</span>)&#123;        d=k;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> heng=<span class="hljs-number">0</span>,shu=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(px<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;mp[px<span class="hljs-number">-1</span>][py]!=<span class="hljs-string">'*'</span>)shu++;    <span class="hljs-keyword">if</span>(px+<span class="hljs-number">1</span>&lt;n&amp;&amp;mp[px+<span class="hljs-number">1</span>][py]!=<span class="hljs-string">'*'</span>)shu++;    <span class="hljs-keyword">if</span>(py<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;mp[px][py<span class="hljs-number">-1</span>]!=<span class="hljs-string">'*'</span>)heng++;    <span class="hljs-keyword">if</span>(py+<span class="hljs-number">1</span>&lt;m&amp;&amp;mp[px][py+<span class="hljs-number">1</span>]!=<span class="hljs-string">'*'</span>)heng++;    <span class="hljs-keyword">if</span>(shu&gt;heng)&#123;        <span class="hljs-keyword">if</span>(px<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;!vis[px<span class="hljs-number">-1</span>][py]&amp;&amp;mp[px<span class="hljs-number">-1</span>][py]!=<span class="hljs-string">'*'</span>)&#123;            vis[px<span class="hljs-number">-1</span>][py]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'U'</span>;            dfs(px<span class="hljs-number">-1</span>,py,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(px+<span class="hljs-number">1</span>&lt;n&amp;&amp;!vis[px+<span class="hljs-number">1</span>][py]&amp;&amp;mp[px+<span class="hljs-number">1</span>][py]!=<span class="hljs-string">'*'</span>)&#123;            vis[px+<span class="hljs-number">1</span>][py]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'D'</span>;            dfs(px+<span class="hljs-number">1</span>,py,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(py<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;!vis[px][py<span class="hljs-number">-1</span>]&amp;&amp;mp[px][py<span class="hljs-number">-1</span>]!=<span class="hljs-string">'*'</span>)&#123;            vis[px][py<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'L'</span>;            dfs(px,py<span class="hljs-number">-1</span>,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(py+<span class="hljs-number">1</span>&lt;m&amp;&amp;!vis[px][py+<span class="hljs-number">1</span>]&amp;&amp;mp[px][py+<span class="hljs-number">1</span>]!=<span class="hljs-string">'*'</span>)&#123;            vis[px][py+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'R'</span>;            dfs(px,py+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>(py<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;!vis[px][py<span class="hljs-number">-1</span>]&amp;&amp;mp[px][py<span class="hljs-number">-1</span>]!=<span class="hljs-string">'*'</span>)&#123;            vis[px][py<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'L'</span>;            dfs(px,py<span class="hljs-number">-1</span>,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(py+<span class="hljs-number">1</span>&lt;m&amp;&amp;!vis[px][py+<span class="hljs-number">1</span>]&amp;&amp;mp[px][py+<span class="hljs-number">1</span>]!=<span class="hljs-string">'*'</span>)&#123;            vis[px][py+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'R'</span>;            dfs(px,py+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(px<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;!vis[px<span class="hljs-number">-1</span>][py]&amp;&amp;mp[px<span class="hljs-number">-1</span>][py]!=<span class="hljs-string">'*'</span>)&#123;            vis[px<span class="hljs-number">-1</span>][py]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'U'</span>;            dfs(px<span class="hljs-number">-1</span>,py,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(px+<span class="hljs-number">1</span>&lt;n&amp;&amp;!vis[px+<span class="hljs-number">1</span>][py]&amp;&amp;mp[px+<span class="hljs-number">1</span>][py]!=<span class="hljs-string">'*'</span>)&#123;            vis[px+<span class="hljs-number">1</span>][py]=<span class="hljs-number">1</span>;            ans[k]=<span class="hljs-string">'D'</span>;            dfs(px+<span class="hljs-number">1</span>,py,k+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(d!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">another</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123;    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'R'</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">'L'</span>;    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'L'</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">'R'</span>;    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'U'</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">'D'</span>;    <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'D'</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">'U'</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,mp[i]);    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    px=nx=<span class="hljs-number">0</span>,py=ny=<span class="hljs-number">0</span>;    <span class="hljs-keyword">bool</span> heng=<span class="hljs-number">1</span>,shu=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;d;)&#123;        <span class="hljs-keyword">bool</span> LR=ans[i]==<span class="hljs-string">'L'</span>||ans[i]==<span class="hljs-string">'R'</span>;        <span class="hljs-keyword">bool</span> UD=ans[i]==<span class="hljs-string">'U'</span>||ans[i]==<span class="hljs-string">'D'</span>;        <span class="hljs-keyword">if</span>(LR)&#123;            <span class="hljs-keyword">if</span>(heng)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\n"</span>,ans[i]);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\n"</span>,another(ans[i]));            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'R'</span>)ny=py+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> ny=py<span class="hljs-number">-1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(shu)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\n"</span>,ans[i]);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\n"</span>,another(ans[i]));            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'D'</span>)nx=px+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> nx=px<span class="hljs-number">-1</span>;        &#125;        fflush(<span class="hljs-built_in">stdout</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);x--,y--;        <span class="hljs-keyword">if</span>((x==<span class="hljs-number">-2</span>&amp;&amp;y==<span class="hljs-number">-2</span>)||mp[x][y]==<span class="hljs-string">'F'</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(x==px&amp;&amp;y==py)&#123;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'L'</span>&amp;&amp;y+<span class="hljs-number">1</span>&gt;=m)heng=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'R'</span>&amp;&amp;y<span class="hljs-number">-1</span>&lt;<span class="hljs-number">0</span>)heng=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'D'</span>&amp;&amp;x<span class="hljs-number">-1</span>&lt;<span class="hljs-number">0</span>)shu=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'U'</span>&amp;&amp;x+<span class="hljs-number">1</span>&gt;=n)shu=<span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=nx||y!=ny)&#123;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'R'</span>&amp;&amp;y!=ny)&#123;                heng=<span class="hljs-number">0</span>;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"L\n"</span>);                fflush(<span class="hljs-built_in">stdout</span>);                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);x--,y--;            &#125;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'L'</span>&amp;&amp;y!=ny)&#123;                heng=<span class="hljs-number">0</span>;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"R\n"</span>);                fflush(<span class="hljs-built_in">stdout</span>);                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);x--,y--;            &#125;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'U'</span>&amp;&amp;y!=ny)&#123;                shu=<span class="hljs-number">0</span>;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"D\n"</span>);                fflush(<span class="hljs-built_in">stdout</span>);                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);x--,y--;            &#125;            <span class="hljs-keyword">if</span>(ans[i]==<span class="hljs-string">'D'</span>&amp;&amp;y!=ny)&#123;                shu=<span class="hljs-number">0</span>;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"U\n"</span>);                fflush(<span class="hljs-built_in">stdout</span>);                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);x--,y--;            &#125;        &#125;<span class="hljs-keyword">else</span> i++;        nx=px=x,ny=py=y;    &#125;&#125;</code></pre><h2 id="E-Vladik-and-Entertaining-Flags"><a href="#E-Vladik-and-Entertaining-Flags" class="headerlink" title="E. Vladik and Entertaining Flags"></a>E. Vladik and Entertaining Flags</h2><blockquote><p>题目大意：有一个$n×m$的矩阵，$q$次询问，每次询问l列到r列围成的图中有多少连通块。</p></blockquote><h3 id="线段树-并查集"><a href="#线段树-并查集" class="headerlink" title="线段树+并查集"></a>线段树+并查集</h3><p>注意到$n \leqslant 10$，故可以用线段树维护。</p><p>每段维护从$L$列到$R$列的图中有多少连通块，以及$L$列及$R$列的段内数字编号（保证段内的联通的数字编号是相同的）。</p><p>段与段合并时，只需判断相邻的数字是否相同，若相同且不为同一连通块，则合并。</p><p>查询前，需要将段两端的数字编号的$pre$指向自己（build操作中有可能将$pre$指向了其他段中的数字编号；同时因为段内联通的数字编号相同，故该操作不会改变段内数字的连通性），之后同合并操作。</p><p>复杂度$O(nmlgm+qnlgm)$.</p><p>代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson x&lt;&lt;1,l,mid</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson x&lt;&lt;1|1,mid+1,r</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,m,q,mp[<span class="hljs-number">12</span>][<span class="hljs-number">100005</span>],pre[<span class="hljs-number">1000005</span>],tot;<span class="hljs-keyword">bool</span> flag;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">int</span> L[<span class="hljs-number">12</span>],R[<span class="hljs-number">12</span>];&#125;a[<span class="hljs-number">100005</span>&lt;&lt;<span class="hljs-number">2</span>],ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=x;++i)pre[i]=i;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">return</span> pre[x]==x?x:pre[x]=Find(pre[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> x=Find(a),y=Find(b);    <span class="hljs-keyword">if</span>(x!=y)pre[x]=y;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> mid)</span></span>&#123;    <span class="hljs-keyword">int</span> l=x&lt;&lt;<span class="hljs-number">1</span>,r=x&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>;    a[x].num=a[l].num+a[r].num;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(mp[i][mid]==mp[i][mid+<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">if</span>(Find(a[l].R[i])!=Find(a[r].L[i]))&#123;                a[x].num--;                Union(a[l].R[i],a[r].L[i]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        a[x].L[i]=Find(a[l].L[i]);        a[x].R[i]=Find(a[r].R[i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(l==r)&#123;        a[x].num=<span class="hljs-number">1</span>;        a[x].L[<span class="hljs-number">0</span>]=a[x].R[<span class="hljs-number">0</span>]=++tot;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(mp[i][r]==mp[i<span class="hljs-number">-1</span>][r])&#123;                a[x].L[i]=a[x].R[i]=tot;            &#125;<span class="hljs-keyword">else</span>&#123;                tot++,a[x].num++;                a[x].L[i]=a[x].R[i]=tot;            &#125;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(lson);    build(rson);    push_up(x,mid);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> ql,<span class="hljs-keyword">int</span> qr)</span></span>&#123;    <span class="hljs-keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;        <span class="hljs-keyword">if</span>(flag)&#123;            flag=<span class="hljs-number">0</span>;            ans=a[x];            <span class="hljs-keyword">return</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            ans.num+=a[x].num;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;                pre[ans.R[i]]=ans.R[i];                pre[a[x].L[i]]=a[x].L[i];                pre[a[x].R[i]]=a[x].R[i];            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;                <span class="hljs-keyword">if</span>(mp[i][l<span class="hljs-number">-1</span>]==mp[i][l])&#123;                    <span class="hljs-keyword">if</span>(Find(ans.R[i])!=Find(a[x].L[i]))&#123;                        ans.num--;                        Union(ans.R[i],a[x].L[i]);                    &#125;                &#125;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)                ans.R[i]=Find(a[x].R[i]);            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(ql&lt;=mid)query(lson,ql,qr);    <span class="hljs-keyword">if</span>(mid&lt;qr)query(rson,ql,qr);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);    init(n*m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;mp[i][j]);    build(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>);    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> x,y;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);x--;y--;        flag=<span class="hljs-number">1</span>;        query(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,m<span class="hljs-number">-1</span>,x,y);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans.num);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Acm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>模拟</tag>
      
      <tag>Codeforces</tag>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于博客的搭建</title>
    <link href="/2017/06/01/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2017/06/01/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>感谢Tr0y和Xieldy的技术支持。</p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>博客搭建：<a href="https://www.tr0y.wang/2017/05/27/Hexo_Coding/" target="_blank" rel="noopener">Hexo + Coding 折腾记录</a></p><p>主题配置：采用ICARUS主题，相关配置参考<a href="https://dp2px.com/2019/06/04/icarus-theme/" target="_blank" rel="noopener">这里</a>以及github上ICARUS的issue</p><p>Mathjax公式渲染：<a href="http://blog.xieldy.cn/2017/06/01/hexo%E4%B8%AD%E5%88%A9%E7%94%A8mathjex%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="noopener">Hexo中利用Mathjex渲染数学公式</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2017/06/01/hello-world/"/>
    <url>/2017/06/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>!  <a id="more"></a> This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
